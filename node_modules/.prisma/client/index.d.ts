
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model administrateur
 * 
 */
export type administrateur = $Result.DefaultSelection<Prisma.$administrateurPayload>
/**
 * Model affectation
 * 
 */
export type affectation = $Result.DefaultSelection<Prisma.$affectationPayload>
/**
 * Model dossier
 * 
 */
export type dossier = $Result.DefaultSelection<Prisma.$dossierPayload>
/**
 * Model encadreur
 * 
 */
export type encadreur = $Result.DefaultSelection<Prisma.$encadreurPayload>
/**
 * Model etudiant
 * 
 */
export type etudiant = $Result.DefaultSelection<Prisma.$etudiantPayload>
/**
 * Model logs_actions
 * 
 */
export type logs_actions = $Result.DefaultSelection<Prisma.$logs_actionsPayload>
/**
 * Model rapport
 * 
 */
export type rapport = $Result.DefaultSelection<Prisma.$rapportPayload>
/**
 * Model lettreAcceptation
 * 
 */
export type lettreAcceptation = $Result.DefaultSelection<Prisma.$lettreAcceptationPayload>
/**
 * Model structures
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type structures = $Result.DefaultSelection<Prisma.$structuresPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Administrateurs
 * const administrateurs = await prisma.administrateur.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Administrateurs
   * const administrateurs = await prisma.administrateur.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.administrateur`: Exposes CRUD operations for the **administrateur** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Administrateurs
    * const administrateurs = await prisma.administrateur.findMany()
    * ```
    */
  get administrateur(): Prisma.administrateurDelegate<ExtArgs>;

  /**
   * `prisma.affectation`: Exposes CRUD operations for the **affectation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Affectations
    * const affectations = await prisma.affectation.findMany()
    * ```
    */
  get affectation(): Prisma.affectationDelegate<ExtArgs>;

  /**
   * `prisma.dossier`: Exposes CRUD operations for the **dossier** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Dossiers
    * const dossiers = await prisma.dossier.findMany()
    * ```
    */
  get dossier(): Prisma.dossierDelegate<ExtArgs>;

  /**
   * `prisma.encadreur`: Exposes CRUD operations for the **encadreur** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Encadreurs
    * const encadreurs = await prisma.encadreur.findMany()
    * ```
    */
  get encadreur(): Prisma.encadreurDelegate<ExtArgs>;

  /**
   * `prisma.etudiant`: Exposes CRUD operations for the **etudiant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Etudiants
    * const etudiants = await prisma.etudiant.findMany()
    * ```
    */
  get etudiant(): Prisma.etudiantDelegate<ExtArgs>;

  /**
   * `prisma.logs_actions`: Exposes CRUD operations for the **logs_actions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Logs_actions
    * const logs_actions = await prisma.logs_actions.findMany()
    * ```
    */
  get logs_actions(): Prisma.logs_actionsDelegate<ExtArgs>;

  /**
   * `prisma.rapport`: Exposes CRUD operations for the **rapport** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Rapports
    * const rapports = await prisma.rapport.findMany()
    * ```
    */
  get rapport(): Prisma.rapportDelegate<ExtArgs>;

  /**
   * `prisma.lettreAcceptation`: Exposes CRUD operations for the **lettreAcceptation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LettreAcceptations
    * const lettreAcceptations = await prisma.lettreAcceptation.findMany()
    * ```
    */
  get lettreAcceptation(): Prisma.lettreAcceptationDelegate<ExtArgs>;

  /**
   * `prisma.structures`: Exposes CRUD operations for the **structures** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Structures
    * const structures = await prisma.structures.findMany()
    * ```
    */
  get structures(): Prisma.structuresDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.1.0
   * Query Engine version: 11f085a2012c0f4778414c8db2651556ee0ef959
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    administrateur: 'administrateur',
    affectation: 'affectation',
    dossier: 'dossier',
    encadreur: 'encadreur',
    etudiant: 'etudiant',
    logs_actions: 'logs_actions',
    rapport: 'rapport',
    lettreAcceptation: 'lettreAcceptation',
    structures: 'structures'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "administrateur" | "affectation" | "dossier" | "encadreur" | "etudiant" | "logs_actions" | "rapport" | "lettreAcceptation" | "structures"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      administrateur: {
        payload: Prisma.$administrateurPayload<ExtArgs>
        fields: Prisma.administrateurFieldRefs
        operations: {
          findUnique: {
            args: Prisma.administrateurFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$administrateurPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.administrateurFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$administrateurPayload>
          }
          findFirst: {
            args: Prisma.administrateurFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$administrateurPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.administrateurFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$administrateurPayload>
          }
          findMany: {
            args: Prisma.administrateurFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$administrateurPayload>[]
          }
          create: {
            args: Prisma.administrateurCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$administrateurPayload>
          }
          createMany: {
            args: Prisma.administrateurCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.administrateurDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$administrateurPayload>
          }
          update: {
            args: Prisma.administrateurUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$administrateurPayload>
          }
          deleteMany: {
            args: Prisma.administrateurDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.administrateurUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.administrateurUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$administrateurPayload>
          }
          aggregate: {
            args: Prisma.AdministrateurAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAdministrateur>
          }
          groupBy: {
            args: Prisma.administrateurGroupByArgs<ExtArgs>
            result: $Utils.Optional<AdministrateurGroupByOutputType>[]
          }
          count: {
            args: Prisma.administrateurCountArgs<ExtArgs>
            result: $Utils.Optional<AdministrateurCountAggregateOutputType> | number
          }
        }
      }
      affectation: {
        payload: Prisma.$affectationPayload<ExtArgs>
        fields: Prisma.affectationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.affectationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$affectationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.affectationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$affectationPayload>
          }
          findFirst: {
            args: Prisma.affectationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$affectationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.affectationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$affectationPayload>
          }
          findMany: {
            args: Prisma.affectationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$affectationPayload>[]
          }
          create: {
            args: Prisma.affectationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$affectationPayload>
          }
          createMany: {
            args: Prisma.affectationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.affectationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$affectationPayload>
          }
          update: {
            args: Prisma.affectationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$affectationPayload>
          }
          deleteMany: {
            args: Prisma.affectationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.affectationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.affectationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$affectationPayload>
          }
          aggregate: {
            args: Prisma.AffectationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAffectation>
          }
          groupBy: {
            args: Prisma.affectationGroupByArgs<ExtArgs>
            result: $Utils.Optional<AffectationGroupByOutputType>[]
          }
          count: {
            args: Prisma.affectationCountArgs<ExtArgs>
            result: $Utils.Optional<AffectationCountAggregateOutputType> | number
          }
        }
      }
      dossier: {
        payload: Prisma.$dossierPayload<ExtArgs>
        fields: Prisma.dossierFieldRefs
        operations: {
          findUnique: {
            args: Prisma.dossierFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$dossierPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.dossierFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$dossierPayload>
          }
          findFirst: {
            args: Prisma.dossierFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$dossierPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.dossierFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$dossierPayload>
          }
          findMany: {
            args: Prisma.dossierFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$dossierPayload>[]
          }
          create: {
            args: Prisma.dossierCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$dossierPayload>
          }
          createMany: {
            args: Prisma.dossierCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.dossierDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$dossierPayload>
          }
          update: {
            args: Prisma.dossierUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$dossierPayload>
          }
          deleteMany: {
            args: Prisma.dossierDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.dossierUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.dossierUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$dossierPayload>
          }
          aggregate: {
            args: Prisma.DossierAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDossier>
          }
          groupBy: {
            args: Prisma.dossierGroupByArgs<ExtArgs>
            result: $Utils.Optional<DossierGroupByOutputType>[]
          }
          count: {
            args: Prisma.dossierCountArgs<ExtArgs>
            result: $Utils.Optional<DossierCountAggregateOutputType> | number
          }
        }
      }
      encadreur: {
        payload: Prisma.$encadreurPayload<ExtArgs>
        fields: Prisma.encadreurFieldRefs
        operations: {
          findUnique: {
            args: Prisma.encadreurFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$encadreurPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.encadreurFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$encadreurPayload>
          }
          findFirst: {
            args: Prisma.encadreurFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$encadreurPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.encadreurFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$encadreurPayload>
          }
          findMany: {
            args: Prisma.encadreurFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$encadreurPayload>[]
          }
          create: {
            args: Prisma.encadreurCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$encadreurPayload>
          }
          createMany: {
            args: Prisma.encadreurCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.encadreurDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$encadreurPayload>
          }
          update: {
            args: Prisma.encadreurUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$encadreurPayload>
          }
          deleteMany: {
            args: Prisma.encadreurDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.encadreurUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.encadreurUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$encadreurPayload>
          }
          aggregate: {
            args: Prisma.EncadreurAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEncadreur>
          }
          groupBy: {
            args: Prisma.encadreurGroupByArgs<ExtArgs>
            result: $Utils.Optional<EncadreurGroupByOutputType>[]
          }
          count: {
            args: Prisma.encadreurCountArgs<ExtArgs>
            result: $Utils.Optional<EncadreurCountAggregateOutputType> | number
          }
        }
      }
      etudiant: {
        payload: Prisma.$etudiantPayload<ExtArgs>
        fields: Prisma.etudiantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.etudiantFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$etudiantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.etudiantFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$etudiantPayload>
          }
          findFirst: {
            args: Prisma.etudiantFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$etudiantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.etudiantFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$etudiantPayload>
          }
          findMany: {
            args: Prisma.etudiantFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$etudiantPayload>[]
          }
          create: {
            args: Prisma.etudiantCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$etudiantPayload>
          }
          createMany: {
            args: Prisma.etudiantCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.etudiantDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$etudiantPayload>
          }
          update: {
            args: Prisma.etudiantUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$etudiantPayload>
          }
          deleteMany: {
            args: Prisma.etudiantDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.etudiantUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.etudiantUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$etudiantPayload>
          }
          aggregate: {
            args: Prisma.EtudiantAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEtudiant>
          }
          groupBy: {
            args: Prisma.etudiantGroupByArgs<ExtArgs>
            result: $Utils.Optional<EtudiantGroupByOutputType>[]
          }
          count: {
            args: Prisma.etudiantCountArgs<ExtArgs>
            result: $Utils.Optional<EtudiantCountAggregateOutputType> | number
          }
        }
      }
      logs_actions: {
        payload: Prisma.$logs_actionsPayload<ExtArgs>
        fields: Prisma.logs_actionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.logs_actionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$logs_actionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.logs_actionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$logs_actionsPayload>
          }
          findFirst: {
            args: Prisma.logs_actionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$logs_actionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.logs_actionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$logs_actionsPayload>
          }
          findMany: {
            args: Prisma.logs_actionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$logs_actionsPayload>[]
          }
          create: {
            args: Prisma.logs_actionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$logs_actionsPayload>
          }
          createMany: {
            args: Prisma.logs_actionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.logs_actionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$logs_actionsPayload>
          }
          update: {
            args: Prisma.logs_actionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$logs_actionsPayload>
          }
          deleteMany: {
            args: Prisma.logs_actionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.logs_actionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.logs_actionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$logs_actionsPayload>
          }
          aggregate: {
            args: Prisma.Logs_actionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLogs_actions>
          }
          groupBy: {
            args: Prisma.logs_actionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Logs_actionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.logs_actionsCountArgs<ExtArgs>
            result: $Utils.Optional<Logs_actionsCountAggregateOutputType> | number
          }
        }
      }
      rapport: {
        payload: Prisma.$rapportPayload<ExtArgs>
        fields: Prisma.rapportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.rapportFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rapportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.rapportFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rapportPayload>
          }
          findFirst: {
            args: Prisma.rapportFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rapportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.rapportFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rapportPayload>
          }
          findMany: {
            args: Prisma.rapportFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rapportPayload>[]
          }
          create: {
            args: Prisma.rapportCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rapportPayload>
          }
          createMany: {
            args: Prisma.rapportCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.rapportDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rapportPayload>
          }
          update: {
            args: Prisma.rapportUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rapportPayload>
          }
          deleteMany: {
            args: Prisma.rapportDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.rapportUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.rapportUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rapportPayload>
          }
          aggregate: {
            args: Prisma.RapportAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRapport>
          }
          groupBy: {
            args: Prisma.rapportGroupByArgs<ExtArgs>
            result: $Utils.Optional<RapportGroupByOutputType>[]
          }
          count: {
            args: Prisma.rapportCountArgs<ExtArgs>
            result: $Utils.Optional<RapportCountAggregateOutputType> | number
          }
        }
      }
      lettreAcceptation: {
        payload: Prisma.$lettreAcceptationPayload<ExtArgs>
        fields: Prisma.lettreAcceptationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.lettreAcceptationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lettreAcceptationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.lettreAcceptationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lettreAcceptationPayload>
          }
          findFirst: {
            args: Prisma.lettreAcceptationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lettreAcceptationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.lettreAcceptationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lettreAcceptationPayload>
          }
          findMany: {
            args: Prisma.lettreAcceptationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lettreAcceptationPayload>[]
          }
          create: {
            args: Prisma.lettreAcceptationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lettreAcceptationPayload>
          }
          createMany: {
            args: Prisma.lettreAcceptationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.lettreAcceptationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lettreAcceptationPayload>
          }
          update: {
            args: Prisma.lettreAcceptationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lettreAcceptationPayload>
          }
          deleteMany: {
            args: Prisma.lettreAcceptationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.lettreAcceptationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.lettreAcceptationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$lettreAcceptationPayload>
          }
          aggregate: {
            args: Prisma.LettreAcceptationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLettreAcceptation>
          }
          groupBy: {
            args: Prisma.lettreAcceptationGroupByArgs<ExtArgs>
            result: $Utils.Optional<LettreAcceptationGroupByOutputType>[]
          }
          count: {
            args: Prisma.lettreAcceptationCountArgs<ExtArgs>
            result: $Utils.Optional<LettreAcceptationCountAggregateOutputType> | number
          }
        }
      }
      structures: {
        payload: Prisma.$structuresPayload<ExtArgs>
        fields: Prisma.structuresFieldRefs
        operations: {
          findUnique: {
            args: Prisma.structuresFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$structuresPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.structuresFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$structuresPayload>
          }
          findFirst: {
            args: Prisma.structuresFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$structuresPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.structuresFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$structuresPayload>
          }
          findMany: {
            args: Prisma.structuresFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$structuresPayload>[]
          }
          create: {
            args: Prisma.structuresCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$structuresPayload>
          }
          createMany: {
            args: Prisma.structuresCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.structuresDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$structuresPayload>
          }
          update: {
            args: Prisma.structuresUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$structuresPayload>
          }
          deleteMany: {
            args: Prisma.structuresDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.structuresUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.structuresUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$structuresPayload>
          }
          aggregate: {
            args: Prisma.StructuresAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStructures>
          }
          groupBy: {
            args: Prisma.structuresGroupByArgs<ExtArgs>
            result: $Utils.Optional<StructuresGroupByOutputType>[]
          }
          count: {
            args: Prisma.structuresCountArgs<ExtArgs>
            result: $Utils.Optional<StructuresCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type AdministrateurCountOutputType
   */

  export type AdministrateurCountOutputType = {
    affectation: number
  }

  export type AdministrateurCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    affectation?: boolean | AdministrateurCountOutputTypeCountAffectationArgs
  }

  // Custom InputTypes
  /**
   * AdministrateurCountOutputType without action
   */
  export type AdministrateurCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AdministrateurCountOutputType
     */
    select?: AdministrateurCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AdministrateurCountOutputType without action
   */
  export type AdministrateurCountOutputTypeCountAffectationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: affectationWhereInput
  }


  /**
   * Count Type DossierCountOutputType
   */

  export type DossierCountOutputType = {
    affectation: number
    lettreAcceptation: number
  }

  export type DossierCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    affectation?: boolean | DossierCountOutputTypeCountAffectationArgs
    lettreAcceptation?: boolean | DossierCountOutputTypeCountLettreAcceptationArgs
  }

  // Custom InputTypes
  /**
   * DossierCountOutputType without action
   */
  export type DossierCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DossierCountOutputType
     */
    select?: DossierCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DossierCountOutputType without action
   */
  export type DossierCountOutputTypeCountAffectationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: affectationWhereInput
  }

  /**
   * DossierCountOutputType without action
   */
  export type DossierCountOutputTypeCountLettreAcceptationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: lettreAcceptationWhereInput
  }


  /**
   * Count Type EncadreurCountOutputType
   */

  export type EncadreurCountOutputType = {
    affectation: number
  }

  export type EncadreurCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    affectation?: boolean | EncadreurCountOutputTypeCountAffectationArgs
  }

  // Custom InputTypes
  /**
   * EncadreurCountOutputType without action
   */
  export type EncadreurCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EncadreurCountOutputType
     */
    select?: EncadreurCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EncadreurCountOutputType without action
   */
  export type EncadreurCountOutputTypeCountAffectationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: affectationWhereInput
  }


  /**
   * Count Type EtudiantCountOutputType
   */

  export type EtudiantCountOutputType = {
    dossier: number
    rapport: number
  }

  export type EtudiantCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dossier?: boolean | EtudiantCountOutputTypeCountDossierArgs
    rapport?: boolean | EtudiantCountOutputTypeCountRapportArgs
  }

  // Custom InputTypes
  /**
   * EtudiantCountOutputType without action
   */
  export type EtudiantCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EtudiantCountOutputType
     */
    select?: EtudiantCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EtudiantCountOutputType without action
   */
  export type EtudiantCountOutputTypeCountDossierArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: dossierWhereInput
  }

  /**
   * EtudiantCountOutputType without action
   */
  export type EtudiantCountOutputTypeCountRapportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: rapportWhereInput
  }


  /**
   * Count Type StructuresCountOutputType
   */

  export type StructuresCountOutputType = {
    affectation: number
    encadreur: number
    other_structures: number
  }

  export type StructuresCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    affectation?: boolean | StructuresCountOutputTypeCountAffectationArgs
    encadreur?: boolean | StructuresCountOutputTypeCountEncadreurArgs
    other_structures?: boolean | StructuresCountOutputTypeCountOther_structuresArgs
  }

  // Custom InputTypes
  /**
   * StructuresCountOutputType without action
   */
  export type StructuresCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StructuresCountOutputType
     */
    select?: StructuresCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StructuresCountOutputType without action
   */
  export type StructuresCountOutputTypeCountAffectationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: affectationWhereInput
  }

  /**
   * StructuresCountOutputType without action
   */
  export type StructuresCountOutputTypeCountEncadreurArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: encadreurWhereInput
  }

  /**
   * StructuresCountOutputType without action
   */
  export type StructuresCountOutputTypeCountOther_structuresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: structuresWhereInput
  }


  /**
   * Models
   */

  /**
   * Model administrateur
   */

  export type AggregateAdministrateur = {
    _count: AdministrateurCountAggregateOutputType | null
    _avg: AdministrateurAvgAggregateOutputType | null
    _sum: AdministrateurSumAggregateOutputType | null
    _min: AdministrateurMinAggregateOutputType | null
    _max: AdministrateurMaxAggregateOutputType | null
  }

  export type AdministrateurAvgAggregateOutputType = {
    IDADMIN: number | null
  }

  export type AdministrateurSumAggregateOutputType = {
    IDADMIN: number | null
  }

  export type AdministrateurMinAggregateOutputType = {
    IDADMIN: number | null
    MATRICULEADMIN: string | null
    NOMADMIN: string | null
    PRENOMADMIN: string | null
    EMAILADMIN: string | null
    PASSWARDADMIN: string | null
    PHOTOADMIN: string | null
  }

  export type AdministrateurMaxAggregateOutputType = {
    IDADMIN: number | null
    MATRICULEADMIN: string | null
    NOMADMIN: string | null
    PRENOMADMIN: string | null
    EMAILADMIN: string | null
    PASSWARDADMIN: string | null
    PHOTOADMIN: string | null
  }

  export type AdministrateurCountAggregateOutputType = {
    IDADMIN: number
    MATRICULEADMIN: number
    NOMADMIN: number
    PRENOMADMIN: number
    EMAILADMIN: number
    PASSWARDADMIN: number
    PHOTOADMIN: number
    _all: number
  }


  export type AdministrateurAvgAggregateInputType = {
    IDADMIN?: true
  }

  export type AdministrateurSumAggregateInputType = {
    IDADMIN?: true
  }

  export type AdministrateurMinAggregateInputType = {
    IDADMIN?: true
    MATRICULEADMIN?: true
    NOMADMIN?: true
    PRENOMADMIN?: true
    EMAILADMIN?: true
    PASSWARDADMIN?: true
    PHOTOADMIN?: true
  }

  export type AdministrateurMaxAggregateInputType = {
    IDADMIN?: true
    MATRICULEADMIN?: true
    NOMADMIN?: true
    PRENOMADMIN?: true
    EMAILADMIN?: true
    PASSWARDADMIN?: true
    PHOTOADMIN?: true
  }

  export type AdministrateurCountAggregateInputType = {
    IDADMIN?: true
    MATRICULEADMIN?: true
    NOMADMIN?: true
    PRENOMADMIN?: true
    EMAILADMIN?: true
    PASSWARDADMIN?: true
    PHOTOADMIN?: true
    _all?: true
  }

  export type AdministrateurAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which administrateur to aggregate.
     */
    where?: administrateurWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of administrateurs to fetch.
     */
    orderBy?: administrateurOrderByWithRelationInput | administrateurOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: administrateurWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` administrateurs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` administrateurs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned administrateurs
    **/
    _count?: true | AdministrateurCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AdministrateurAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AdministrateurSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AdministrateurMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AdministrateurMaxAggregateInputType
  }

  export type GetAdministrateurAggregateType<T extends AdministrateurAggregateArgs> = {
        [P in keyof T & keyof AggregateAdministrateur]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAdministrateur[P]>
      : GetScalarType<T[P], AggregateAdministrateur[P]>
  }




  export type administrateurGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: administrateurWhereInput
    orderBy?: administrateurOrderByWithAggregationInput | administrateurOrderByWithAggregationInput[]
    by: AdministrateurScalarFieldEnum[] | AdministrateurScalarFieldEnum
    having?: administrateurScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AdministrateurCountAggregateInputType | true
    _avg?: AdministrateurAvgAggregateInputType
    _sum?: AdministrateurSumAggregateInputType
    _min?: AdministrateurMinAggregateInputType
    _max?: AdministrateurMaxAggregateInputType
  }

  export type AdministrateurGroupByOutputType = {
    IDADMIN: number
    MATRICULEADMIN: string
    NOMADMIN: string
    PRENOMADMIN: string
    EMAILADMIN: string
    PASSWARDADMIN: string
    PHOTOADMIN: string
    _count: AdministrateurCountAggregateOutputType | null
    _avg: AdministrateurAvgAggregateOutputType | null
    _sum: AdministrateurSumAggregateOutputType | null
    _min: AdministrateurMinAggregateOutputType | null
    _max: AdministrateurMaxAggregateOutputType | null
  }

  type GetAdministrateurGroupByPayload<T extends administrateurGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AdministrateurGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AdministrateurGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AdministrateurGroupByOutputType[P]>
            : GetScalarType<T[P], AdministrateurGroupByOutputType[P]>
        }
      >
    >


  export type administrateurSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    IDADMIN?: boolean
    MATRICULEADMIN?: boolean
    NOMADMIN?: boolean
    PRENOMADMIN?: boolean
    EMAILADMIN?: boolean
    PASSWARDADMIN?: boolean
    PHOTOADMIN?: boolean
    affectation?: boolean | administrateur$affectationArgs<ExtArgs>
    _count?: boolean | AdministrateurCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["administrateur"]>


  export type administrateurSelectScalar = {
    IDADMIN?: boolean
    MATRICULEADMIN?: boolean
    NOMADMIN?: boolean
    PRENOMADMIN?: boolean
    EMAILADMIN?: boolean
    PASSWARDADMIN?: boolean
    PHOTOADMIN?: boolean
  }

  export type administrateurInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    affectation?: boolean | administrateur$affectationArgs<ExtArgs>
    _count?: boolean | AdministrateurCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $administrateurPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "administrateur"
    objects: {
      affectation: Prisma.$affectationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      IDADMIN: number
      MATRICULEADMIN: string
      NOMADMIN: string
      PRENOMADMIN: string
      EMAILADMIN: string
      PASSWARDADMIN: string
      PHOTOADMIN: string
    }, ExtArgs["result"]["administrateur"]>
    composites: {}
  }

  type administrateurGetPayload<S extends boolean | null | undefined | administrateurDefaultArgs> = $Result.GetResult<Prisma.$administrateurPayload, S>

  type administrateurCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<administrateurFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AdministrateurCountAggregateInputType | true
    }

  export interface administrateurDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['administrateur'], meta: { name: 'administrateur' } }
    /**
     * Find zero or one Administrateur that matches the filter.
     * @param {administrateurFindUniqueArgs} args - Arguments to find a Administrateur
     * @example
     * // Get one Administrateur
     * const administrateur = await prisma.administrateur.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends administrateurFindUniqueArgs>(args: SelectSubset<T, administrateurFindUniqueArgs<ExtArgs>>): Prisma__administrateurClient<$Result.GetResult<Prisma.$administrateurPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Administrateur that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {administrateurFindUniqueOrThrowArgs} args - Arguments to find a Administrateur
     * @example
     * // Get one Administrateur
     * const administrateur = await prisma.administrateur.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends administrateurFindUniqueOrThrowArgs>(args: SelectSubset<T, administrateurFindUniqueOrThrowArgs<ExtArgs>>): Prisma__administrateurClient<$Result.GetResult<Prisma.$administrateurPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Administrateur that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {administrateurFindFirstArgs} args - Arguments to find a Administrateur
     * @example
     * // Get one Administrateur
     * const administrateur = await prisma.administrateur.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends administrateurFindFirstArgs>(args?: SelectSubset<T, administrateurFindFirstArgs<ExtArgs>>): Prisma__administrateurClient<$Result.GetResult<Prisma.$administrateurPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Administrateur that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {administrateurFindFirstOrThrowArgs} args - Arguments to find a Administrateur
     * @example
     * // Get one Administrateur
     * const administrateur = await prisma.administrateur.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends administrateurFindFirstOrThrowArgs>(args?: SelectSubset<T, administrateurFindFirstOrThrowArgs<ExtArgs>>): Prisma__administrateurClient<$Result.GetResult<Prisma.$administrateurPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Administrateurs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {administrateurFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Administrateurs
     * const administrateurs = await prisma.administrateur.findMany()
     * 
     * // Get first 10 Administrateurs
     * const administrateurs = await prisma.administrateur.findMany({ take: 10 })
     * 
     * // Only select the `IDADMIN`
     * const administrateurWithIDADMINOnly = await prisma.administrateur.findMany({ select: { IDADMIN: true } })
     * 
     */
    findMany<T extends administrateurFindManyArgs>(args?: SelectSubset<T, administrateurFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$administrateurPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Administrateur.
     * @param {administrateurCreateArgs} args - Arguments to create a Administrateur.
     * @example
     * // Create one Administrateur
     * const Administrateur = await prisma.administrateur.create({
     *   data: {
     *     // ... data to create a Administrateur
     *   }
     * })
     * 
     */
    create<T extends administrateurCreateArgs>(args: SelectSubset<T, administrateurCreateArgs<ExtArgs>>): Prisma__administrateurClient<$Result.GetResult<Prisma.$administrateurPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Administrateurs.
     * @param {administrateurCreateManyArgs} args - Arguments to create many Administrateurs.
     * @example
     * // Create many Administrateurs
     * const administrateur = await prisma.administrateur.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends administrateurCreateManyArgs>(args?: SelectSubset<T, administrateurCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Administrateur.
     * @param {administrateurDeleteArgs} args - Arguments to delete one Administrateur.
     * @example
     * // Delete one Administrateur
     * const Administrateur = await prisma.administrateur.delete({
     *   where: {
     *     // ... filter to delete one Administrateur
     *   }
     * })
     * 
     */
    delete<T extends administrateurDeleteArgs>(args: SelectSubset<T, administrateurDeleteArgs<ExtArgs>>): Prisma__administrateurClient<$Result.GetResult<Prisma.$administrateurPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Administrateur.
     * @param {administrateurUpdateArgs} args - Arguments to update one Administrateur.
     * @example
     * // Update one Administrateur
     * const administrateur = await prisma.administrateur.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends administrateurUpdateArgs>(args: SelectSubset<T, administrateurUpdateArgs<ExtArgs>>): Prisma__administrateurClient<$Result.GetResult<Prisma.$administrateurPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Administrateurs.
     * @param {administrateurDeleteManyArgs} args - Arguments to filter Administrateurs to delete.
     * @example
     * // Delete a few Administrateurs
     * const { count } = await prisma.administrateur.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends administrateurDeleteManyArgs>(args?: SelectSubset<T, administrateurDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Administrateurs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {administrateurUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Administrateurs
     * const administrateur = await prisma.administrateur.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends administrateurUpdateManyArgs>(args: SelectSubset<T, administrateurUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Administrateur.
     * @param {administrateurUpsertArgs} args - Arguments to update or create a Administrateur.
     * @example
     * // Update or create a Administrateur
     * const administrateur = await prisma.administrateur.upsert({
     *   create: {
     *     // ... data to create a Administrateur
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Administrateur we want to update
     *   }
     * })
     */
    upsert<T extends administrateurUpsertArgs>(args: SelectSubset<T, administrateurUpsertArgs<ExtArgs>>): Prisma__administrateurClient<$Result.GetResult<Prisma.$administrateurPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Administrateurs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {administrateurCountArgs} args - Arguments to filter Administrateurs to count.
     * @example
     * // Count the number of Administrateurs
     * const count = await prisma.administrateur.count({
     *   where: {
     *     // ... the filter for the Administrateurs we want to count
     *   }
     * })
    **/
    count<T extends administrateurCountArgs>(
      args?: Subset<T, administrateurCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AdministrateurCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Administrateur.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AdministrateurAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AdministrateurAggregateArgs>(args: Subset<T, AdministrateurAggregateArgs>): Prisma.PrismaPromise<GetAdministrateurAggregateType<T>>

    /**
     * Group by Administrateur.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {administrateurGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends administrateurGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: administrateurGroupByArgs['orderBy'] }
        : { orderBy?: administrateurGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, administrateurGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAdministrateurGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the administrateur model
   */
  readonly fields: administrateurFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for administrateur.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__administrateurClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    affectation<T extends administrateur$affectationArgs<ExtArgs> = {}>(args?: Subset<T, administrateur$affectationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$affectationPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the administrateur model
   */ 
  interface administrateurFieldRefs {
    readonly IDADMIN: FieldRef<"administrateur", 'Int'>
    readonly MATRICULEADMIN: FieldRef<"administrateur", 'String'>
    readonly NOMADMIN: FieldRef<"administrateur", 'String'>
    readonly PRENOMADMIN: FieldRef<"administrateur", 'String'>
    readonly EMAILADMIN: FieldRef<"administrateur", 'String'>
    readonly PASSWARDADMIN: FieldRef<"administrateur", 'String'>
    readonly PHOTOADMIN: FieldRef<"administrateur", 'String'>
  }
    

  // Custom InputTypes
  /**
   * administrateur findUnique
   */
  export type administrateurFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the administrateur
     */
    select?: administrateurSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: administrateurInclude<ExtArgs> | null
    /**
     * Filter, which administrateur to fetch.
     */
    where: administrateurWhereUniqueInput
  }

  /**
   * administrateur findUniqueOrThrow
   */
  export type administrateurFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the administrateur
     */
    select?: administrateurSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: administrateurInclude<ExtArgs> | null
    /**
     * Filter, which administrateur to fetch.
     */
    where: administrateurWhereUniqueInput
  }

  /**
   * administrateur findFirst
   */
  export type administrateurFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the administrateur
     */
    select?: administrateurSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: administrateurInclude<ExtArgs> | null
    /**
     * Filter, which administrateur to fetch.
     */
    where?: administrateurWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of administrateurs to fetch.
     */
    orderBy?: administrateurOrderByWithRelationInput | administrateurOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for administrateurs.
     */
    cursor?: administrateurWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` administrateurs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` administrateurs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of administrateurs.
     */
    distinct?: AdministrateurScalarFieldEnum | AdministrateurScalarFieldEnum[]
  }

  /**
   * administrateur findFirstOrThrow
   */
  export type administrateurFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the administrateur
     */
    select?: administrateurSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: administrateurInclude<ExtArgs> | null
    /**
     * Filter, which administrateur to fetch.
     */
    where?: administrateurWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of administrateurs to fetch.
     */
    orderBy?: administrateurOrderByWithRelationInput | administrateurOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for administrateurs.
     */
    cursor?: administrateurWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` administrateurs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` administrateurs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of administrateurs.
     */
    distinct?: AdministrateurScalarFieldEnum | AdministrateurScalarFieldEnum[]
  }

  /**
   * administrateur findMany
   */
  export type administrateurFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the administrateur
     */
    select?: administrateurSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: administrateurInclude<ExtArgs> | null
    /**
     * Filter, which administrateurs to fetch.
     */
    where?: administrateurWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of administrateurs to fetch.
     */
    orderBy?: administrateurOrderByWithRelationInput | administrateurOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing administrateurs.
     */
    cursor?: administrateurWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` administrateurs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` administrateurs.
     */
    skip?: number
    distinct?: AdministrateurScalarFieldEnum | AdministrateurScalarFieldEnum[]
  }

  /**
   * administrateur create
   */
  export type administrateurCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the administrateur
     */
    select?: administrateurSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: administrateurInclude<ExtArgs> | null
    /**
     * The data needed to create a administrateur.
     */
    data: XOR<administrateurCreateInput, administrateurUncheckedCreateInput>
  }

  /**
   * administrateur createMany
   */
  export type administrateurCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many administrateurs.
     */
    data: administrateurCreateManyInput | administrateurCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * administrateur update
   */
  export type administrateurUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the administrateur
     */
    select?: administrateurSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: administrateurInclude<ExtArgs> | null
    /**
     * The data needed to update a administrateur.
     */
    data: XOR<administrateurUpdateInput, administrateurUncheckedUpdateInput>
    /**
     * Choose, which administrateur to update.
     */
    where: administrateurWhereUniqueInput
  }

  /**
   * administrateur updateMany
   */
  export type administrateurUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update administrateurs.
     */
    data: XOR<administrateurUpdateManyMutationInput, administrateurUncheckedUpdateManyInput>
    /**
     * Filter which administrateurs to update
     */
    where?: administrateurWhereInput
  }

  /**
   * administrateur upsert
   */
  export type administrateurUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the administrateur
     */
    select?: administrateurSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: administrateurInclude<ExtArgs> | null
    /**
     * The filter to search for the administrateur to update in case it exists.
     */
    where: administrateurWhereUniqueInput
    /**
     * In case the administrateur found by the `where` argument doesn't exist, create a new administrateur with this data.
     */
    create: XOR<administrateurCreateInput, administrateurUncheckedCreateInput>
    /**
     * In case the administrateur was found with the provided `where` argument, update it with this data.
     */
    update: XOR<administrateurUpdateInput, administrateurUncheckedUpdateInput>
  }

  /**
   * administrateur delete
   */
  export type administrateurDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the administrateur
     */
    select?: administrateurSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: administrateurInclude<ExtArgs> | null
    /**
     * Filter which administrateur to delete.
     */
    where: administrateurWhereUniqueInput
  }

  /**
   * administrateur deleteMany
   */
  export type administrateurDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which administrateurs to delete
     */
    where?: administrateurWhereInput
  }

  /**
   * administrateur.affectation
   */
  export type administrateur$affectationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the affectation
     */
    select?: affectationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: affectationInclude<ExtArgs> | null
    where?: affectationWhereInput
    orderBy?: affectationOrderByWithRelationInput | affectationOrderByWithRelationInput[]
    cursor?: affectationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AffectationScalarFieldEnum | AffectationScalarFieldEnum[]
  }

  /**
   * administrateur without action
   */
  export type administrateurDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the administrateur
     */
    select?: administrateurSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: administrateurInclude<ExtArgs> | null
  }


  /**
   * Model affectation
   */

  export type AggregateAffectation = {
    _count: AffectationCountAggregateOutputType | null
    _avg: AffectationAvgAggregateOutputType | null
    _sum: AffectationSumAggregateOutputType | null
    _min: AffectationMinAggregateOutputType | null
    _max: AffectationMaxAggregateOutputType | null
  }

  export type AffectationAvgAggregateOutputType = {
    IDADMIN: number | null
    IDENCADREUR: number | null
    IDDOSSIER: number | null
    IDSTRUCTURE: number | null
  }

  export type AffectationSumAggregateOutputType = {
    IDADMIN: number | null
    IDENCADREUR: number | null
    IDDOSSIER: number | null
    IDSTRUCTURE: number | null
  }

  export type AffectationMinAggregateOutputType = {
    IDADMIN: number | null
    IDENCADREUR: number | null
    IDDOSSIER: number | null
    IDSTRUCTURE: number | null
  }

  export type AffectationMaxAggregateOutputType = {
    IDADMIN: number | null
    IDENCADREUR: number | null
    IDDOSSIER: number | null
    IDSTRUCTURE: number | null
  }

  export type AffectationCountAggregateOutputType = {
    IDADMIN: number
    IDENCADREUR: number
    IDDOSSIER: number
    IDSTRUCTURE: number
    _all: number
  }


  export type AffectationAvgAggregateInputType = {
    IDADMIN?: true
    IDENCADREUR?: true
    IDDOSSIER?: true
    IDSTRUCTURE?: true
  }

  export type AffectationSumAggregateInputType = {
    IDADMIN?: true
    IDENCADREUR?: true
    IDDOSSIER?: true
    IDSTRUCTURE?: true
  }

  export type AffectationMinAggregateInputType = {
    IDADMIN?: true
    IDENCADREUR?: true
    IDDOSSIER?: true
    IDSTRUCTURE?: true
  }

  export type AffectationMaxAggregateInputType = {
    IDADMIN?: true
    IDENCADREUR?: true
    IDDOSSIER?: true
    IDSTRUCTURE?: true
  }

  export type AffectationCountAggregateInputType = {
    IDADMIN?: true
    IDENCADREUR?: true
    IDDOSSIER?: true
    IDSTRUCTURE?: true
    _all?: true
  }

  export type AffectationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which affectation to aggregate.
     */
    where?: affectationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of affectations to fetch.
     */
    orderBy?: affectationOrderByWithRelationInput | affectationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: affectationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` affectations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` affectations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned affectations
    **/
    _count?: true | AffectationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AffectationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AffectationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AffectationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AffectationMaxAggregateInputType
  }

  export type GetAffectationAggregateType<T extends AffectationAggregateArgs> = {
        [P in keyof T & keyof AggregateAffectation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAffectation[P]>
      : GetScalarType<T[P], AggregateAffectation[P]>
  }




  export type affectationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: affectationWhereInput
    orderBy?: affectationOrderByWithAggregationInput | affectationOrderByWithAggregationInput[]
    by: AffectationScalarFieldEnum[] | AffectationScalarFieldEnum
    having?: affectationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AffectationCountAggregateInputType | true
    _avg?: AffectationAvgAggregateInputType
    _sum?: AffectationSumAggregateInputType
    _min?: AffectationMinAggregateInputType
    _max?: AffectationMaxAggregateInputType
  }

  export type AffectationGroupByOutputType = {
    IDADMIN: number
    IDENCADREUR: number
    IDDOSSIER: number
    IDSTRUCTURE: number
    _count: AffectationCountAggregateOutputType | null
    _avg: AffectationAvgAggregateOutputType | null
    _sum: AffectationSumAggregateOutputType | null
    _min: AffectationMinAggregateOutputType | null
    _max: AffectationMaxAggregateOutputType | null
  }

  type GetAffectationGroupByPayload<T extends affectationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AffectationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AffectationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AffectationGroupByOutputType[P]>
            : GetScalarType<T[P], AffectationGroupByOutputType[P]>
        }
      >
    >


  export type affectationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    IDADMIN?: boolean
    IDENCADREUR?: boolean
    IDDOSSIER?: boolean
    IDSTRUCTURE?: boolean
    administrateur?: boolean | administrateurDefaultArgs<ExtArgs>
    encadreur?: boolean | encadreurDefaultArgs<ExtArgs>
    dossier?: boolean | dossierDefaultArgs<ExtArgs>
    structures?: boolean | structuresDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["affectation"]>


  export type affectationSelectScalar = {
    IDADMIN?: boolean
    IDENCADREUR?: boolean
    IDDOSSIER?: boolean
    IDSTRUCTURE?: boolean
  }

  export type affectationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    administrateur?: boolean | administrateurDefaultArgs<ExtArgs>
    encadreur?: boolean | encadreurDefaultArgs<ExtArgs>
    dossier?: boolean | dossierDefaultArgs<ExtArgs>
    structures?: boolean | structuresDefaultArgs<ExtArgs>
  }

  export type $affectationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "affectation"
    objects: {
      administrateur: Prisma.$administrateurPayload<ExtArgs>
      encadreur: Prisma.$encadreurPayload<ExtArgs>
      dossier: Prisma.$dossierPayload<ExtArgs>
      structures: Prisma.$structuresPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      IDADMIN: number
      IDENCADREUR: number
      IDDOSSIER: number
      IDSTRUCTURE: number
    }, ExtArgs["result"]["affectation"]>
    composites: {}
  }

  type affectationGetPayload<S extends boolean | null | undefined | affectationDefaultArgs> = $Result.GetResult<Prisma.$affectationPayload, S>

  type affectationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<affectationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AffectationCountAggregateInputType | true
    }

  export interface affectationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['affectation'], meta: { name: 'affectation' } }
    /**
     * Find zero or one Affectation that matches the filter.
     * @param {affectationFindUniqueArgs} args - Arguments to find a Affectation
     * @example
     * // Get one Affectation
     * const affectation = await prisma.affectation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends affectationFindUniqueArgs>(args: SelectSubset<T, affectationFindUniqueArgs<ExtArgs>>): Prisma__affectationClient<$Result.GetResult<Prisma.$affectationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Affectation that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {affectationFindUniqueOrThrowArgs} args - Arguments to find a Affectation
     * @example
     * // Get one Affectation
     * const affectation = await prisma.affectation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends affectationFindUniqueOrThrowArgs>(args: SelectSubset<T, affectationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__affectationClient<$Result.GetResult<Prisma.$affectationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Affectation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {affectationFindFirstArgs} args - Arguments to find a Affectation
     * @example
     * // Get one Affectation
     * const affectation = await prisma.affectation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends affectationFindFirstArgs>(args?: SelectSubset<T, affectationFindFirstArgs<ExtArgs>>): Prisma__affectationClient<$Result.GetResult<Prisma.$affectationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Affectation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {affectationFindFirstOrThrowArgs} args - Arguments to find a Affectation
     * @example
     * // Get one Affectation
     * const affectation = await prisma.affectation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends affectationFindFirstOrThrowArgs>(args?: SelectSubset<T, affectationFindFirstOrThrowArgs<ExtArgs>>): Prisma__affectationClient<$Result.GetResult<Prisma.$affectationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Affectations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {affectationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Affectations
     * const affectations = await prisma.affectation.findMany()
     * 
     * // Get first 10 Affectations
     * const affectations = await prisma.affectation.findMany({ take: 10 })
     * 
     * // Only select the `IDADMIN`
     * const affectationWithIDADMINOnly = await prisma.affectation.findMany({ select: { IDADMIN: true } })
     * 
     */
    findMany<T extends affectationFindManyArgs>(args?: SelectSubset<T, affectationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$affectationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Affectation.
     * @param {affectationCreateArgs} args - Arguments to create a Affectation.
     * @example
     * // Create one Affectation
     * const Affectation = await prisma.affectation.create({
     *   data: {
     *     // ... data to create a Affectation
     *   }
     * })
     * 
     */
    create<T extends affectationCreateArgs>(args: SelectSubset<T, affectationCreateArgs<ExtArgs>>): Prisma__affectationClient<$Result.GetResult<Prisma.$affectationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Affectations.
     * @param {affectationCreateManyArgs} args - Arguments to create many Affectations.
     * @example
     * // Create many Affectations
     * const affectation = await prisma.affectation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends affectationCreateManyArgs>(args?: SelectSubset<T, affectationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Affectation.
     * @param {affectationDeleteArgs} args - Arguments to delete one Affectation.
     * @example
     * // Delete one Affectation
     * const Affectation = await prisma.affectation.delete({
     *   where: {
     *     // ... filter to delete one Affectation
     *   }
     * })
     * 
     */
    delete<T extends affectationDeleteArgs>(args: SelectSubset<T, affectationDeleteArgs<ExtArgs>>): Prisma__affectationClient<$Result.GetResult<Prisma.$affectationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Affectation.
     * @param {affectationUpdateArgs} args - Arguments to update one Affectation.
     * @example
     * // Update one Affectation
     * const affectation = await prisma.affectation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends affectationUpdateArgs>(args: SelectSubset<T, affectationUpdateArgs<ExtArgs>>): Prisma__affectationClient<$Result.GetResult<Prisma.$affectationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Affectations.
     * @param {affectationDeleteManyArgs} args - Arguments to filter Affectations to delete.
     * @example
     * // Delete a few Affectations
     * const { count } = await prisma.affectation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends affectationDeleteManyArgs>(args?: SelectSubset<T, affectationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Affectations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {affectationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Affectations
     * const affectation = await prisma.affectation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends affectationUpdateManyArgs>(args: SelectSubset<T, affectationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Affectation.
     * @param {affectationUpsertArgs} args - Arguments to update or create a Affectation.
     * @example
     * // Update or create a Affectation
     * const affectation = await prisma.affectation.upsert({
     *   create: {
     *     // ... data to create a Affectation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Affectation we want to update
     *   }
     * })
     */
    upsert<T extends affectationUpsertArgs>(args: SelectSubset<T, affectationUpsertArgs<ExtArgs>>): Prisma__affectationClient<$Result.GetResult<Prisma.$affectationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Affectations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {affectationCountArgs} args - Arguments to filter Affectations to count.
     * @example
     * // Count the number of Affectations
     * const count = await prisma.affectation.count({
     *   where: {
     *     // ... the filter for the Affectations we want to count
     *   }
     * })
    **/
    count<T extends affectationCountArgs>(
      args?: Subset<T, affectationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AffectationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Affectation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AffectationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AffectationAggregateArgs>(args: Subset<T, AffectationAggregateArgs>): Prisma.PrismaPromise<GetAffectationAggregateType<T>>

    /**
     * Group by Affectation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {affectationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends affectationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: affectationGroupByArgs['orderBy'] }
        : { orderBy?: affectationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, affectationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAffectationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the affectation model
   */
  readonly fields: affectationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for affectation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__affectationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    administrateur<T extends administrateurDefaultArgs<ExtArgs> = {}>(args?: Subset<T, administrateurDefaultArgs<ExtArgs>>): Prisma__administrateurClient<$Result.GetResult<Prisma.$administrateurPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    encadreur<T extends encadreurDefaultArgs<ExtArgs> = {}>(args?: Subset<T, encadreurDefaultArgs<ExtArgs>>): Prisma__encadreurClient<$Result.GetResult<Prisma.$encadreurPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    dossier<T extends dossierDefaultArgs<ExtArgs> = {}>(args?: Subset<T, dossierDefaultArgs<ExtArgs>>): Prisma__dossierClient<$Result.GetResult<Prisma.$dossierPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    structures<T extends structuresDefaultArgs<ExtArgs> = {}>(args?: Subset<T, structuresDefaultArgs<ExtArgs>>): Prisma__structuresClient<$Result.GetResult<Prisma.$structuresPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the affectation model
   */ 
  interface affectationFieldRefs {
    readonly IDADMIN: FieldRef<"affectation", 'Int'>
    readonly IDENCADREUR: FieldRef<"affectation", 'Int'>
    readonly IDDOSSIER: FieldRef<"affectation", 'Int'>
    readonly IDSTRUCTURE: FieldRef<"affectation", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * affectation findUnique
   */
  export type affectationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the affectation
     */
    select?: affectationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: affectationInclude<ExtArgs> | null
    /**
     * Filter, which affectation to fetch.
     */
    where: affectationWhereUniqueInput
  }

  /**
   * affectation findUniqueOrThrow
   */
  export type affectationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the affectation
     */
    select?: affectationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: affectationInclude<ExtArgs> | null
    /**
     * Filter, which affectation to fetch.
     */
    where: affectationWhereUniqueInput
  }

  /**
   * affectation findFirst
   */
  export type affectationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the affectation
     */
    select?: affectationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: affectationInclude<ExtArgs> | null
    /**
     * Filter, which affectation to fetch.
     */
    where?: affectationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of affectations to fetch.
     */
    orderBy?: affectationOrderByWithRelationInput | affectationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for affectations.
     */
    cursor?: affectationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` affectations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` affectations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of affectations.
     */
    distinct?: AffectationScalarFieldEnum | AffectationScalarFieldEnum[]
  }

  /**
   * affectation findFirstOrThrow
   */
  export type affectationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the affectation
     */
    select?: affectationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: affectationInclude<ExtArgs> | null
    /**
     * Filter, which affectation to fetch.
     */
    where?: affectationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of affectations to fetch.
     */
    orderBy?: affectationOrderByWithRelationInput | affectationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for affectations.
     */
    cursor?: affectationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` affectations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` affectations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of affectations.
     */
    distinct?: AffectationScalarFieldEnum | AffectationScalarFieldEnum[]
  }

  /**
   * affectation findMany
   */
  export type affectationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the affectation
     */
    select?: affectationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: affectationInclude<ExtArgs> | null
    /**
     * Filter, which affectations to fetch.
     */
    where?: affectationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of affectations to fetch.
     */
    orderBy?: affectationOrderByWithRelationInput | affectationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing affectations.
     */
    cursor?: affectationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` affectations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` affectations.
     */
    skip?: number
    distinct?: AffectationScalarFieldEnum | AffectationScalarFieldEnum[]
  }

  /**
   * affectation create
   */
  export type affectationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the affectation
     */
    select?: affectationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: affectationInclude<ExtArgs> | null
    /**
     * The data needed to create a affectation.
     */
    data: XOR<affectationCreateInput, affectationUncheckedCreateInput>
  }

  /**
   * affectation createMany
   */
  export type affectationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many affectations.
     */
    data: affectationCreateManyInput | affectationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * affectation update
   */
  export type affectationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the affectation
     */
    select?: affectationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: affectationInclude<ExtArgs> | null
    /**
     * The data needed to update a affectation.
     */
    data: XOR<affectationUpdateInput, affectationUncheckedUpdateInput>
    /**
     * Choose, which affectation to update.
     */
    where: affectationWhereUniqueInput
  }

  /**
   * affectation updateMany
   */
  export type affectationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update affectations.
     */
    data: XOR<affectationUpdateManyMutationInput, affectationUncheckedUpdateManyInput>
    /**
     * Filter which affectations to update
     */
    where?: affectationWhereInput
  }

  /**
   * affectation upsert
   */
  export type affectationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the affectation
     */
    select?: affectationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: affectationInclude<ExtArgs> | null
    /**
     * The filter to search for the affectation to update in case it exists.
     */
    where: affectationWhereUniqueInput
    /**
     * In case the affectation found by the `where` argument doesn't exist, create a new affectation with this data.
     */
    create: XOR<affectationCreateInput, affectationUncheckedCreateInput>
    /**
     * In case the affectation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<affectationUpdateInput, affectationUncheckedUpdateInput>
  }

  /**
   * affectation delete
   */
  export type affectationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the affectation
     */
    select?: affectationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: affectationInclude<ExtArgs> | null
    /**
     * Filter which affectation to delete.
     */
    where: affectationWhereUniqueInput
  }

  /**
   * affectation deleteMany
   */
  export type affectationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which affectations to delete
     */
    where?: affectationWhereInput
  }

  /**
   * affectation without action
   */
  export type affectationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the affectation
     */
    select?: affectationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: affectationInclude<ExtArgs> | null
  }


  /**
   * Model dossier
   */

  export type AggregateDossier = {
    _count: DossierCountAggregateOutputType | null
    _avg: DossierAvgAggregateOutputType | null
    _sum: DossierSumAggregateOutputType | null
    _min: DossierMinAggregateOutputType | null
    _max: DossierMaxAggregateOutputType | null
  }

  export type DossierAvgAggregateOutputType = {
    IDDOSSIER: number | null
  }

  export type DossierSumAggregateOutputType = {
    IDDOSSIER: number | null
  }

  export type DossierMinAggregateOutputType = {
    IDDOSSIER: number | null
    MATRICULEETUDIANT: string | null
    DATEDEBUTDESEANCE: Date | null
    DATEFINDESEANCE: Date | null
    ETAT: string | null
    THEME: string | null
    CNI: string | null
    CERTIFICAT: string | null
    LETTREMOTIVATION: string | null
    LETTRERECOMMENDATION: string | null
    PHOTOPROFIL: string | null
    CV: string | null
    CAHIERDECHARGE: string | null
    DATEDEPOT: Date | null
    EMAILSENT: boolean | null
  }

  export type DossierMaxAggregateOutputType = {
    IDDOSSIER: number | null
    MATRICULEETUDIANT: string | null
    DATEDEBUTDESEANCE: Date | null
    DATEFINDESEANCE: Date | null
    ETAT: string | null
    THEME: string | null
    CNI: string | null
    CERTIFICAT: string | null
    LETTREMOTIVATION: string | null
    LETTRERECOMMENDATION: string | null
    PHOTOPROFIL: string | null
    CV: string | null
    CAHIERDECHARGE: string | null
    DATEDEPOT: Date | null
    EMAILSENT: boolean | null
  }

  export type DossierCountAggregateOutputType = {
    IDDOSSIER: number
    MATRICULEETUDIANT: number
    DATEDEBUTDESEANCE: number
    DATEFINDESEANCE: number
    ETAT: number
    THEME: number
    CNI: number
    CERTIFICAT: number
    LETTREMOTIVATION: number
    LETTRERECOMMENDATION: number
    PHOTOPROFIL: number
    CV: number
    CAHIERDECHARGE: number
    DATEDEPOT: number
    EMAILSENT: number
    _all: number
  }


  export type DossierAvgAggregateInputType = {
    IDDOSSIER?: true
  }

  export type DossierSumAggregateInputType = {
    IDDOSSIER?: true
  }

  export type DossierMinAggregateInputType = {
    IDDOSSIER?: true
    MATRICULEETUDIANT?: true
    DATEDEBUTDESEANCE?: true
    DATEFINDESEANCE?: true
    ETAT?: true
    THEME?: true
    CNI?: true
    CERTIFICAT?: true
    LETTREMOTIVATION?: true
    LETTRERECOMMENDATION?: true
    PHOTOPROFIL?: true
    CV?: true
    CAHIERDECHARGE?: true
    DATEDEPOT?: true
    EMAILSENT?: true
  }

  export type DossierMaxAggregateInputType = {
    IDDOSSIER?: true
    MATRICULEETUDIANT?: true
    DATEDEBUTDESEANCE?: true
    DATEFINDESEANCE?: true
    ETAT?: true
    THEME?: true
    CNI?: true
    CERTIFICAT?: true
    LETTREMOTIVATION?: true
    LETTRERECOMMENDATION?: true
    PHOTOPROFIL?: true
    CV?: true
    CAHIERDECHARGE?: true
    DATEDEPOT?: true
    EMAILSENT?: true
  }

  export type DossierCountAggregateInputType = {
    IDDOSSIER?: true
    MATRICULEETUDIANT?: true
    DATEDEBUTDESEANCE?: true
    DATEFINDESEANCE?: true
    ETAT?: true
    THEME?: true
    CNI?: true
    CERTIFICAT?: true
    LETTREMOTIVATION?: true
    LETTRERECOMMENDATION?: true
    PHOTOPROFIL?: true
    CV?: true
    CAHIERDECHARGE?: true
    DATEDEPOT?: true
    EMAILSENT?: true
    _all?: true
  }

  export type DossierAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which dossier to aggregate.
     */
    where?: dossierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of dossiers to fetch.
     */
    orderBy?: dossierOrderByWithRelationInput | dossierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: dossierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` dossiers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` dossiers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned dossiers
    **/
    _count?: true | DossierCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DossierAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DossierSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DossierMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DossierMaxAggregateInputType
  }

  export type GetDossierAggregateType<T extends DossierAggregateArgs> = {
        [P in keyof T & keyof AggregateDossier]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDossier[P]>
      : GetScalarType<T[P], AggregateDossier[P]>
  }




  export type dossierGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: dossierWhereInput
    orderBy?: dossierOrderByWithAggregationInput | dossierOrderByWithAggregationInput[]
    by: DossierScalarFieldEnum[] | DossierScalarFieldEnum
    having?: dossierScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DossierCountAggregateInputType | true
    _avg?: DossierAvgAggregateInputType
    _sum?: DossierSumAggregateInputType
    _min?: DossierMinAggregateInputType
    _max?: DossierMaxAggregateInputType
  }

  export type DossierGroupByOutputType = {
    IDDOSSIER: number
    MATRICULEETUDIANT: string | null
    DATEDEBUTDESEANCE: Date | null
    DATEFINDESEANCE: Date | null
    ETAT: string | null
    THEME: string | null
    CNI: string
    CERTIFICAT: string
    LETTREMOTIVATION: string
    LETTRERECOMMENDATION: string
    PHOTOPROFIL: string
    CV: string | null
    CAHIERDECHARGE: string | null
    DATEDEPOT: Date
    EMAILSENT: boolean | null
    _count: DossierCountAggregateOutputType | null
    _avg: DossierAvgAggregateOutputType | null
    _sum: DossierSumAggregateOutputType | null
    _min: DossierMinAggregateOutputType | null
    _max: DossierMaxAggregateOutputType | null
  }

  type GetDossierGroupByPayload<T extends dossierGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DossierGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DossierGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DossierGroupByOutputType[P]>
            : GetScalarType<T[P], DossierGroupByOutputType[P]>
        }
      >
    >


  export type dossierSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    IDDOSSIER?: boolean
    MATRICULEETUDIANT?: boolean
    DATEDEBUTDESEANCE?: boolean
    DATEFINDESEANCE?: boolean
    ETAT?: boolean
    THEME?: boolean
    CNI?: boolean
    CERTIFICAT?: boolean
    LETTREMOTIVATION?: boolean
    LETTRERECOMMENDATION?: boolean
    PHOTOPROFIL?: boolean
    CV?: boolean
    CAHIERDECHARGE?: boolean
    DATEDEPOT?: boolean
    EMAILSENT?: boolean
    affectation?: boolean | dossier$affectationArgs<ExtArgs>
    etudiant?: boolean | dossier$etudiantArgs<ExtArgs>
    lettreAcceptation?: boolean | dossier$lettreAcceptationArgs<ExtArgs>
    _count?: boolean | DossierCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dossier"]>


  export type dossierSelectScalar = {
    IDDOSSIER?: boolean
    MATRICULEETUDIANT?: boolean
    DATEDEBUTDESEANCE?: boolean
    DATEFINDESEANCE?: boolean
    ETAT?: boolean
    THEME?: boolean
    CNI?: boolean
    CERTIFICAT?: boolean
    LETTREMOTIVATION?: boolean
    LETTRERECOMMENDATION?: boolean
    PHOTOPROFIL?: boolean
    CV?: boolean
    CAHIERDECHARGE?: boolean
    DATEDEPOT?: boolean
    EMAILSENT?: boolean
  }

  export type dossierInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    affectation?: boolean | dossier$affectationArgs<ExtArgs>
    etudiant?: boolean | dossier$etudiantArgs<ExtArgs>
    lettreAcceptation?: boolean | dossier$lettreAcceptationArgs<ExtArgs>
    _count?: boolean | DossierCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $dossierPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "dossier"
    objects: {
      affectation: Prisma.$affectationPayload<ExtArgs>[]
      etudiant: Prisma.$etudiantPayload<ExtArgs> | null
      lettreAcceptation: Prisma.$lettreAcceptationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      IDDOSSIER: number
      MATRICULEETUDIANT: string | null
      DATEDEBUTDESEANCE: Date | null
      DATEFINDESEANCE: Date | null
      ETAT: string | null
      THEME: string | null
      CNI: string
      CERTIFICAT: string
      LETTREMOTIVATION: string
      LETTRERECOMMENDATION: string
      PHOTOPROFIL: string
      CV: string | null
      CAHIERDECHARGE: string | null
      DATEDEPOT: Date
      EMAILSENT: boolean | null
    }, ExtArgs["result"]["dossier"]>
    composites: {}
  }

  type dossierGetPayload<S extends boolean | null | undefined | dossierDefaultArgs> = $Result.GetResult<Prisma.$dossierPayload, S>

  type dossierCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<dossierFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DossierCountAggregateInputType | true
    }

  export interface dossierDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['dossier'], meta: { name: 'dossier' } }
    /**
     * Find zero or one Dossier that matches the filter.
     * @param {dossierFindUniqueArgs} args - Arguments to find a Dossier
     * @example
     * // Get one Dossier
     * const dossier = await prisma.dossier.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends dossierFindUniqueArgs>(args: SelectSubset<T, dossierFindUniqueArgs<ExtArgs>>): Prisma__dossierClient<$Result.GetResult<Prisma.$dossierPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Dossier that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {dossierFindUniqueOrThrowArgs} args - Arguments to find a Dossier
     * @example
     * // Get one Dossier
     * const dossier = await prisma.dossier.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends dossierFindUniqueOrThrowArgs>(args: SelectSubset<T, dossierFindUniqueOrThrowArgs<ExtArgs>>): Prisma__dossierClient<$Result.GetResult<Prisma.$dossierPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Dossier that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dossierFindFirstArgs} args - Arguments to find a Dossier
     * @example
     * // Get one Dossier
     * const dossier = await prisma.dossier.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends dossierFindFirstArgs>(args?: SelectSubset<T, dossierFindFirstArgs<ExtArgs>>): Prisma__dossierClient<$Result.GetResult<Prisma.$dossierPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Dossier that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dossierFindFirstOrThrowArgs} args - Arguments to find a Dossier
     * @example
     * // Get one Dossier
     * const dossier = await prisma.dossier.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends dossierFindFirstOrThrowArgs>(args?: SelectSubset<T, dossierFindFirstOrThrowArgs<ExtArgs>>): Prisma__dossierClient<$Result.GetResult<Prisma.$dossierPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Dossiers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dossierFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Dossiers
     * const dossiers = await prisma.dossier.findMany()
     * 
     * // Get first 10 Dossiers
     * const dossiers = await prisma.dossier.findMany({ take: 10 })
     * 
     * // Only select the `IDDOSSIER`
     * const dossierWithIDDOSSIEROnly = await prisma.dossier.findMany({ select: { IDDOSSIER: true } })
     * 
     */
    findMany<T extends dossierFindManyArgs>(args?: SelectSubset<T, dossierFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$dossierPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Dossier.
     * @param {dossierCreateArgs} args - Arguments to create a Dossier.
     * @example
     * // Create one Dossier
     * const Dossier = await prisma.dossier.create({
     *   data: {
     *     // ... data to create a Dossier
     *   }
     * })
     * 
     */
    create<T extends dossierCreateArgs>(args: SelectSubset<T, dossierCreateArgs<ExtArgs>>): Prisma__dossierClient<$Result.GetResult<Prisma.$dossierPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Dossiers.
     * @param {dossierCreateManyArgs} args - Arguments to create many Dossiers.
     * @example
     * // Create many Dossiers
     * const dossier = await prisma.dossier.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends dossierCreateManyArgs>(args?: SelectSubset<T, dossierCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Dossier.
     * @param {dossierDeleteArgs} args - Arguments to delete one Dossier.
     * @example
     * // Delete one Dossier
     * const Dossier = await prisma.dossier.delete({
     *   where: {
     *     // ... filter to delete one Dossier
     *   }
     * })
     * 
     */
    delete<T extends dossierDeleteArgs>(args: SelectSubset<T, dossierDeleteArgs<ExtArgs>>): Prisma__dossierClient<$Result.GetResult<Prisma.$dossierPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Dossier.
     * @param {dossierUpdateArgs} args - Arguments to update one Dossier.
     * @example
     * // Update one Dossier
     * const dossier = await prisma.dossier.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends dossierUpdateArgs>(args: SelectSubset<T, dossierUpdateArgs<ExtArgs>>): Prisma__dossierClient<$Result.GetResult<Prisma.$dossierPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Dossiers.
     * @param {dossierDeleteManyArgs} args - Arguments to filter Dossiers to delete.
     * @example
     * // Delete a few Dossiers
     * const { count } = await prisma.dossier.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends dossierDeleteManyArgs>(args?: SelectSubset<T, dossierDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Dossiers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dossierUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Dossiers
     * const dossier = await prisma.dossier.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends dossierUpdateManyArgs>(args: SelectSubset<T, dossierUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Dossier.
     * @param {dossierUpsertArgs} args - Arguments to update or create a Dossier.
     * @example
     * // Update or create a Dossier
     * const dossier = await prisma.dossier.upsert({
     *   create: {
     *     // ... data to create a Dossier
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Dossier we want to update
     *   }
     * })
     */
    upsert<T extends dossierUpsertArgs>(args: SelectSubset<T, dossierUpsertArgs<ExtArgs>>): Prisma__dossierClient<$Result.GetResult<Prisma.$dossierPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Dossiers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dossierCountArgs} args - Arguments to filter Dossiers to count.
     * @example
     * // Count the number of Dossiers
     * const count = await prisma.dossier.count({
     *   where: {
     *     // ... the filter for the Dossiers we want to count
     *   }
     * })
    **/
    count<T extends dossierCountArgs>(
      args?: Subset<T, dossierCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DossierCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Dossier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DossierAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DossierAggregateArgs>(args: Subset<T, DossierAggregateArgs>): Prisma.PrismaPromise<GetDossierAggregateType<T>>

    /**
     * Group by Dossier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {dossierGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends dossierGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: dossierGroupByArgs['orderBy'] }
        : { orderBy?: dossierGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, dossierGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDossierGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the dossier model
   */
  readonly fields: dossierFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for dossier.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__dossierClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    affectation<T extends dossier$affectationArgs<ExtArgs> = {}>(args?: Subset<T, dossier$affectationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$affectationPayload<ExtArgs>, T, "findMany"> | Null>
    etudiant<T extends dossier$etudiantArgs<ExtArgs> = {}>(args?: Subset<T, dossier$etudiantArgs<ExtArgs>>): Prisma__etudiantClient<$Result.GetResult<Prisma.$etudiantPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    lettreAcceptation<T extends dossier$lettreAcceptationArgs<ExtArgs> = {}>(args?: Subset<T, dossier$lettreAcceptationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$lettreAcceptationPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the dossier model
   */ 
  interface dossierFieldRefs {
    readonly IDDOSSIER: FieldRef<"dossier", 'Int'>
    readonly MATRICULEETUDIANT: FieldRef<"dossier", 'String'>
    readonly DATEDEBUTDESEANCE: FieldRef<"dossier", 'DateTime'>
    readonly DATEFINDESEANCE: FieldRef<"dossier", 'DateTime'>
    readonly ETAT: FieldRef<"dossier", 'String'>
    readonly THEME: FieldRef<"dossier", 'String'>
    readonly CNI: FieldRef<"dossier", 'String'>
    readonly CERTIFICAT: FieldRef<"dossier", 'String'>
    readonly LETTREMOTIVATION: FieldRef<"dossier", 'String'>
    readonly LETTRERECOMMENDATION: FieldRef<"dossier", 'String'>
    readonly PHOTOPROFIL: FieldRef<"dossier", 'String'>
    readonly CV: FieldRef<"dossier", 'String'>
    readonly CAHIERDECHARGE: FieldRef<"dossier", 'String'>
    readonly DATEDEPOT: FieldRef<"dossier", 'DateTime'>
    readonly EMAILSENT: FieldRef<"dossier", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * dossier findUnique
   */
  export type dossierFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dossier
     */
    select?: dossierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: dossierInclude<ExtArgs> | null
    /**
     * Filter, which dossier to fetch.
     */
    where: dossierWhereUniqueInput
  }

  /**
   * dossier findUniqueOrThrow
   */
  export type dossierFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dossier
     */
    select?: dossierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: dossierInclude<ExtArgs> | null
    /**
     * Filter, which dossier to fetch.
     */
    where: dossierWhereUniqueInput
  }

  /**
   * dossier findFirst
   */
  export type dossierFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dossier
     */
    select?: dossierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: dossierInclude<ExtArgs> | null
    /**
     * Filter, which dossier to fetch.
     */
    where?: dossierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of dossiers to fetch.
     */
    orderBy?: dossierOrderByWithRelationInput | dossierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for dossiers.
     */
    cursor?: dossierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` dossiers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` dossiers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of dossiers.
     */
    distinct?: DossierScalarFieldEnum | DossierScalarFieldEnum[]
  }

  /**
   * dossier findFirstOrThrow
   */
  export type dossierFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dossier
     */
    select?: dossierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: dossierInclude<ExtArgs> | null
    /**
     * Filter, which dossier to fetch.
     */
    where?: dossierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of dossiers to fetch.
     */
    orderBy?: dossierOrderByWithRelationInput | dossierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for dossiers.
     */
    cursor?: dossierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` dossiers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` dossiers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of dossiers.
     */
    distinct?: DossierScalarFieldEnum | DossierScalarFieldEnum[]
  }

  /**
   * dossier findMany
   */
  export type dossierFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dossier
     */
    select?: dossierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: dossierInclude<ExtArgs> | null
    /**
     * Filter, which dossiers to fetch.
     */
    where?: dossierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of dossiers to fetch.
     */
    orderBy?: dossierOrderByWithRelationInput | dossierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing dossiers.
     */
    cursor?: dossierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` dossiers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` dossiers.
     */
    skip?: number
    distinct?: DossierScalarFieldEnum | DossierScalarFieldEnum[]
  }

  /**
   * dossier create
   */
  export type dossierCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dossier
     */
    select?: dossierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: dossierInclude<ExtArgs> | null
    /**
     * The data needed to create a dossier.
     */
    data: XOR<dossierCreateInput, dossierUncheckedCreateInput>
  }

  /**
   * dossier createMany
   */
  export type dossierCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many dossiers.
     */
    data: dossierCreateManyInput | dossierCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * dossier update
   */
  export type dossierUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dossier
     */
    select?: dossierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: dossierInclude<ExtArgs> | null
    /**
     * The data needed to update a dossier.
     */
    data: XOR<dossierUpdateInput, dossierUncheckedUpdateInput>
    /**
     * Choose, which dossier to update.
     */
    where: dossierWhereUniqueInput
  }

  /**
   * dossier updateMany
   */
  export type dossierUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update dossiers.
     */
    data: XOR<dossierUpdateManyMutationInput, dossierUncheckedUpdateManyInput>
    /**
     * Filter which dossiers to update
     */
    where?: dossierWhereInput
  }

  /**
   * dossier upsert
   */
  export type dossierUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dossier
     */
    select?: dossierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: dossierInclude<ExtArgs> | null
    /**
     * The filter to search for the dossier to update in case it exists.
     */
    where: dossierWhereUniqueInput
    /**
     * In case the dossier found by the `where` argument doesn't exist, create a new dossier with this data.
     */
    create: XOR<dossierCreateInput, dossierUncheckedCreateInput>
    /**
     * In case the dossier was found with the provided `where` argument, update it with this data.
     */
    update: XOR<dossierUpdateInput, dossierUncheckedUpdateInput>
  }

  /**
   * dossier delete
   */
  export type dossierDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dossier
     */
    select?: dossierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: dossierInclude<ExtArgs> | null
    /**
     * Filter which dossier to delete.
     */
    where: dossierWhereUniqueInput
  }

  /**
   * dossier deleteMany
   */
  export type dossierDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which dossiers to delete
     */
    where?: dossierWhereInput
  }

  /**
   * dossier.affectation
   */
  export type dossier$affectationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the affectation
     */
    select?: affectationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: affectationInclude<ExtArgs> | null
    where?: affectationWhereInput
    orderBy?: affectationOrderByWithRelationInput | affectationOrderByWithRelationInput[]
    cursor?: affectationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AffectationScalarFieldEnum | AffectationScalarFieldEnum[]
  }

  /**
   * dossier.etudiant
   */
  export type dossier$etudiantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the etudiant
     */
    select?: etudiantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: etudiantInclude<ExtArgs> | null
    where?: etudiantWhereInput
  }

  /**
   * dossier.lettreAcceptation
   */
  export type dossier$lettreAcceptationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lettreAcceptation
     */
    select?: lettreAcceptationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: lettreAcceptationInclude<ExtArgs> | null
    where?: lettreAcceptationWhereInput
    orderBy?: lettreAcceptationOrderByWithRelationInput | lettreAcceptationOrderByWithRelationInput[]
    cursor?: lettreAcceptationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LettreAcceptationScalarFieldEnum | LettreAcceptationScalarFieldEnum[]
  }

  /**
   * dossier without action
   */
  export type dossierDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dossier
     */
    select?: dossierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: dossierInclude<ExtArgs> | null
  }


  /**
   * Model encadreur
   */

  export type AggregateEncadreur = {
    _count: EncadreurCountAggregateOutputType | null
    _avg: EncadreurAvgAggregateOutputType | null
    _sum: EncadreurSumAggregateOutputType | null
    _min: EncadreurMinAggregateOutputType | null
    _max: EncadreurMaxAggregateOutputType | null
  }

  export type EncadreurAvgAggregateOutputType = {
    IDENCADREUR: number | null
    IDSTRUCTURE: number | null
  }

  export type EncadreurSumAggregateOutputType = {
    IDENCADREUR: number | null
    IDSTRUCTURE: number | null
  }

  export type EncadreurMinAggregateOutputType = {
    IDENCADREUR: number | null
    MATRICULEENCADREUR: string | null
    NOMENCADREUR: string | null
    PRENOMENCADREUR: string | null
    IDSTRUCTURE: number | null
    POSTE: string | null
  }

  export type EncadreurMaxAggregateOutputType = {
    IDENCADREUR: number | null
    MATRICULEENCADREUR: string | null
    NOMENCADREUR: string | null
    PRENOMENCADREUR: string | null
    IDSTRUCTURE: number | null
    POSTE: string | null
  }

  export type EncadreurCountAggregateOutputType = {
    IDENCADREUR: number
    MATRICULEENCADREUR: number
    NOMENCADREUR: number
    PRENOMENCADREUR: number
    IDSTRUCTURE: number
    POSTE: number
    _all: number
  }


  export type EncadreurAvgAggregateInputType = {
    IDENCADREUR?: true
    IDSTRUCTURE?: true
  }

  export type EncadreurSumAggregateInputType = {
    IDENCADREUR?: true
    IDSTRUCTURE?: true
  }

  export type EncadreurMinAggregateInputType = {
    IDENCADREUR?: true
    MATRICULEENCADREUR?: true
    NOMENCADREUR?: true
    PRENOMENCADREUR?: true
    IDSTRUCTURE?: true
    POSTE?: true
  }

  export type EncadreurMaxAggregateInputType = {
    IDENCADREUR?: true
    MATRICULEENCADREUR?: true
    NOMENCADREUR?: true
    PRENOMENCADREUR?: true
    IDSTRUCTURE?: true
    POSTE?: true
  }

  export type EncadreurCountAggregateInputType = {
    IDENCADREUR?: true
    MATRICULEENCADREUR?: true
    NOMENCADREUR?: true
    PRENOMENCADREUR?: true
    IDSTRUCTURE?: true
    POSTE?: true
    _all?: true
  }

  export type EncadreurAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which encadreur to aggregate.
     */
    where?: encadreurWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of encadreurs to fetch.
     */
    orderBy?: encadreurOrderByWithRelationInput | encadreurOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: encadreurWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` encadreurs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` encadreurs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned encadreurs
    **/
    _count?: true | EncadreurCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EncadreurAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EncadreurSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EncadreurMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EncadreurMaxAggregateInputType
  }

  export type GetEncadreurAggregateType<T extends EncadreurAggregateArgs> = {
        [P in keyof T & keyof AggregateEncadreur]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEncadreur[P]>
      : GetScalarType<T[P], AggregateEncadreur[P]>
  }




  export type encadreurGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: encadreurWhereInput
    orderBy?: encadreurOrderByWithAggregationInput | encadreurOrderByWithAggregationInput[]
    by: EncadreurScalarFieldEnum[] | EncadreurScalarFieldEnum
    having?: encadreurScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EncadreurCountAggregateInputType | true
    _avg?: EncadreurAvgAggregateInputType
    _sum?: EncadreurSumAggregateInputType
    _min?: EncadreurMinAggregateInputType
    _max?: EncadreurMaxAggregateInputType
  }

  export type EncadreurGroupByOutputType = {
    IDENCADREUR: number
    MATRICULEENCADREUR: string
    NOMENCADREUR: string | null
    PRENOMENCADREUR: string | null
    IDSTRUCTURE: number | null
    POSTE: string | null
    _count: EncadreurCountAggregateOutputType | null
    _avg: EncadreurAvgAggregateOutputType | null
    _sum: EncadreurSumAggregateOutputType | null
    _min: EncadreurMinAggregateOutputType | null
    _max: EncadreurMaxAggregateOutputType | null
  }

  type GetEncadreurGroupByPayload<T extends encadreurGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EncadreurGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EncadreurGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EncadreurGroupByOutputType[P]>
            : GetScalarType<T[P], EncadreurGroupByOutputType[P]>
        }
      >
    >


  export type encadreurSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    IDENCADREUR?: boolean
    MATRICULEENCADREUR?: boolean
    NOMENCADREUR?: boolean
    PRENOMENCADREUR?: boolean
    IDSTRUCTURE?: boolean
    POSTE?: boolean
    affectation?: boolean | encadreur$affectationArgs<ExtArgs>
    structures?: boolean | encadreur$structuresArgs<ExtArgs>
    _count?: boolean | EncadreurCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["encadreur"]>


  export type encadreurSelectScalar = {
    IDENCADREUR?: boolean
    MATRICULEENCADREUR?: boolean
    NOMENCADREUR?: boolean
    PRENOMENCADREUR?: boolean
    IDSTRUCTURE?: boolean
    POSTE?: boolean
  }

  export type encadreurInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    affectation?: boolean | encadreur$affectationArgs<ExtArgs>
    structures?: boolean | encadreur$structuresArgs<ExtArgs>
    _count?: boolean | EncadreurCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $encadreurPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "encadreur"
    objects: {
      affectation: Prisma.$affectationPayload<ExtArgs>[]
      structures: Prisma.$structuresPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      IDENCADREUR: number
      MATRICULEENCADREUR: string
      NOMENCADREUR: string | null
      PRENOMENCADREUR: string | null
      IDSTRUCTURE: number | null
      POSTE: string | null
    }, ExtArgs["result"]["encadreur"]>
    composites: {}
  }

  type encadreurGetPayload<S extends boolean | null | undefined | encadreurDefaultArgs> = $Result.GetResult<Prisma.$encadreurPayload, S>

  type encadreurCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<encadreurFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EncadreurCountAggregateInputType | true
    }

  export interface encadreurDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['encadreur'], meta: { name: 'encadreur' } }
    /**
     * Find zero or one Encadreur that matches the filter.
     * @param {encadreurFindUniqueArgs} args - Arguments to find a Encadreur
     * @example
     * // Get one Encadreur
     * const encadreur = await prisma.encadreur.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends encadreurFindUniqueArgs>(args: SelectSubset<T, encadreurFindUniqueArgs<ExtArgs>>): Prisma__encadreurClient<$Result.GetResult<Prisma.$encadreurPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Encadreur that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {encadreurFindUniqueOrThrowArgs} args - Arguments to find a Encadreur
     * @example
     * // Get one Encadreur
     * const encadreur = await prisma.encadreur.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends encadreurFindUniqueOrThrowArgs>(args: SelectSubset<T, encadreurFindUniqueOrThrowArgs<ExtArgs>>): Prisma__encadreurClient<$Result.GetResult<Prisma.$encadreurPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Encadreur that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {encadreurFindFirstArgs} args - Arguments to find a Encadreur
     * @example
     * // Get one Encadreur
     * const encadreur = await prisma.encadreur.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends encadreurFindFirstArgs>(args?: SelectSubset<T, encadreurFindFirstArgs<ExtArgs>>): Prisma__encadreurClient<$Result.GetResult<Prisma.$encadreurPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Encadreur that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {encadreurFindFirstOrThrowArgs} args - Arguments to find a Encadreur
     * @example
     * // Get one Encadreur
     * const encadreur = await prisma.encadreur.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends encadreurFindFirstOrThrowArgs>(args?: SelectSubset<T, encadreurFindFirstOrThrowArgs<ExtArgs>>): Prisma__encadreurClient<$Result.GetResult<Prisma.$encadreurPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Encadreurs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {encadreurFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Encadreurs
     * const encadreurs = await prisma.encadreur.findMany()
     * 
     * // Get first 10 Encadreurs
     * const encadreurs = await prisma.encadreur.findMany({ take: 10 })
     * 
     * // Only select the `IDENCADREUR`
     * const encadreurWithIDENCADREUROnly = await prisma.encadreur.findMany({ select: { IDENCADREUR: true } })
     * 
     */
    findMany<T extends encadreurFindManyArgs>(args?: SelectSubset<T, encadreurFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$encadreurPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Encadreur.
     * @param {encadreurCreateArgs} args - Arguments to create a Encadreur.
     * @example
     * // Create one Encadreur
     * const Encadreur = await prisma.encadreur.create({
     *   data: {
     *     // ... data to create a Encadreur
     *   }
     * })
     * 
     */
    create<T extends encadreurCreateArgs>(args: SelectSubset<T, encadreurCreateArgs<ExtArgs>>): Prisma__encadreurClient<$Result.GetResult<Prisma.$encadreurPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Encadreurs.
     * @param {encadreurCreateManyArgs} args - Arguments to create many Encadreurs.
     * @example
     * // Create many Encadreurs
     * const encadreur = await prisma.encadreur.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends encadreurCreateManyArgs>(args?: SelectSubset<T, encadreurCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Encadreur.
     * @param {encadreurDeleteArgs} args - Arguments to delete one Encadreur.
     * @example
     * // Delete one Encadreur
     * const Encadreur = await prisma.encadreur.delete({
     *   where: {
     *     // ... filter to delete one Encadreur
     *   }
     * })
     * 
     */
    delete<T extends encadreurDeleteArgs>(args: SelectSubset<T, encadreurDeleteArgs<ExtArgs>>): Prisma__encadreurClient<$Result.GetResult<Prisma.$encadreurPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Encadreur.
     * @param {encadreurUpdateArgs} args - Arguments to update one Encadreur.
     * @example
     * // Update one Encadreur
     * const encadreur = await prisma.encadreur.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends encadreurUpdateArgs>(args: SelectSubset<T, encadreurUpdateArgs<ExtArgs>>): Prisma__encadreurClient<$Result.GetResult<Prisma.$encadreurPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Encadreurs.
     * @param {encadreurDeleteManyArgs} args - Arguments to filter Encadreurs to delete.
     * @example
     * // Delete a few Encadreurs
     * const { count } = await prisma.encadreur.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends encadreurDeleteManyArgs>(args?: SelectSubset<T, encadreurDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Encadreurs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {encadreurUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Encadreurs
     * const encadreur = await prisma.encadreur.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends encadreurUpdateManyArgs>(args: SelectSubset<T, encadreurUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Encadreur.
     * @param {encadreurUpsertArgs} args - Arguments to update or create a Encadreur.
     * @example
     * // Update or create a Encadreur
     * const encadreur = await prisma.encadreur.upsert({
     *   create: {
     *     // ... data to create a Encadreur
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Encadreur we want to update
     *   }
     * })
     */
    upsert<T extends encadreurUpsertArgs>(args: SelectSubset<T, encadreurUpsertArgs<ExtArgs>>): Prisma__encadreurClient<$Result.GetResult<Prisma.$encadreurPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Encadreurs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {encadreurCountArgs} args - Arguments to filter Encadreurs to count.
     * @example
     * // Count the number of Encadreurs
     * const count = await prisma.encadreur.count({
     *   where: {
     *     // ... the filter for the Encadreurs we want to count
     *   }
     * })
    **/
    count<T extends encadreurCountArgs>(
      args?: Subset<T, encadreurCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EncadreurCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Encadreur.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EncadreurAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EncadreurAggregateArgs>(args: Subset<T, EncadreurAggregateArgs>): Prisma.PrismaPromise<GetEncadreurAggregateType<T>>

    /**
     * Group by Encadreur.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {encadreurGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends encadreurGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: encadreurGroupByArgs['orderBy'] }
        : { orderBy?: encadreurGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, encadreurGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEncadreurGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the encadreur model
   */
  readonly fields: encadreurFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for encadreur.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__encadreurClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    affectation<T extends encadreur$affectationArgs<ExtArgs> = {}>(args?: Subset<T, encadreur$affectationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$affectationPayload<ExtArgs>, T, "findMany"> | Null>
    structures<T extends encadreur$structuresArgs<ExtArgs> = {}>(args?: Subset<T, encadreur$structuresArgs<ExtArgs>>): Prisma__structuresClient<$Result.GetResult<Prisma.$structuresPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the encadreur model
   */ 
  interface encadreurFieldRefs {
    readonly IDENCADREUR: FieldRef<"encadreur", 'Int'>
    readonly MATRICULEENCADREUR: FieldRef<"encadreur", 'String'>
    readonly NOMENCADREUR: FieldRef<"encadreur", 'String'>
    readonly PRENOMENCADREUR: FieldRef<"encadreur", 'String'>
    readonly IDSTRUCTURE: FieldRef<"encadreur", 'Int'>
    readonly POSTE: FieldRef<"encadreur", 'String'>
  }
    

  // Custom InputTypes
  /**
   * encadreur findUnique
   */
  export type encadreurFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the encadreur
     */
    select?: encadreurSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: encadreurInclude<ExtArgs> | null
    /**
     * Filter, which encadreur to fetch.
     */
    where: encadreurWhereUniqueInput
  }

  /**
   * encadreur findUniqueOrThrow
   */
  export type encadreurFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the encadreur
     */
    select?: encadreurSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: encadreurInclude<ExtArgs> | null
    /**
     * Filter, which encadreur to fetch.
     */
    where: encadreurWhereUniqueInput
  }

  /**
   * encadreur findFirst
   */
  export type encadreurFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the encadreur
     */
    select?: encadreurSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: encadreurInclude<ExtArgs> | null
    /**
     * Filter, which encadreur to fetch.
     */
    where?: encadreurWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of encadreurs to fetch.
     */
    orderBy?: encadreurOrderByWithRelationInput | encadreurOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for encadreurs.
     */
    cursor?: encadreurWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` encadreurs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` encadreurs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of encadreurs.
     */
    distinct?: EncadreurScalarFieldEnum | EncadreurScalarFieldEnum[]
  }

  /**
   * encadreur findFirstOrThrow
   */
  export type encadreurFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the encadreur
     */
    select?: encadreurSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: encadreurInclude<ExtArgs> | null
    /**
     * Filter, which encadreur to fetch.
     */
    where?: encadreurWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of encadreurs to fetch.
     */
    orderBy?: encadreurOrderByWithRelationInput | encadreurOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for encadreurs.
     */
    cursor?: encadreurWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` encadreurs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` encadreurs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of encadreurs.
     */
    distinct?: EncadreurScalarFieldEnum | EncadreurScalarFieldEnum[]
  }

  /**
   * encadreur findMany
   */
  export type encadreurFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the encadreur
     */
    select?: encadreurSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: encadreurInclude<ExtArgs> | null
    /**
     * Filter, which encadreurs to fetch.
     */
    where?: encadreurWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of encadreurs to fetch.
     */
    orderBy?: encadreurOrderByWithRelationInput | encadreurOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing encadreurs.
     */
    cursor?: encadreurWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` encadreurs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` encadreurs.
     */
    skip?: number
    distinct?: EncadreurScalarFieldEnum | EncadreurScalarFieldEnum[]
  }

  /**
   * encadreur create
   */
  export type encadreurCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the encadreur
     */
    select?: encadreurSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: encadreurInclude<ExtArgs> | null
    /**
     * The data needed to create a encadreur.
     */
    data: XOR<encadreurCreateInput, encadreurUncheckedCreateInput>
  }

  /**
   * encadreur createMany
   */
  export type encadreurCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many encadreurs.
     */
    data: encadreurCreateManyInput | encadreurCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * encadreur update
   */
  export type encadreurUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the encadreur
     */
    select?: encadreurSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: encadreurInclude<ExtArgs> | null
    /**
     * The data needed to update a encadreur.
     */
    data: XOR<encadreurUpdateInput, encadreurUncheckedUpdateInput>
    /**
     * Choose, which encadreur to update.
     */
    where: encadreurWhereUniqueInput
  }

  /**
   * encadreur updateMany
   */
  export type encadreurUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update encadreurs.
     */
    data: XOR<encadreurUpdateManyMutationInput, encadreurUncheckedUpdateManyInput>
    /**
     * Filter which encadreurs to update
     */
    where?: encadreurWhereInput
  }

  /**
   * encadreur upsert
   */
  export type encadreurUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the encadreur
     */
    select?: encadreurSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: encadreurInclude<ExtArgs> | null
    /**
     * The filter to search for the encadreur to update in case it exists.
     */
    where: encadreurWhereUniqueInput
    /**
     * In case the encadreur found by the `where` argument doesn't exist, create a new encadreur with this data.
     */
    create: XOR<encadreurCreateInput, encadreurUncheckedCreateInput>
    /**
     * In case the encadreur was found with the provided `where` argument, update it with this data.
     */
    update: XOR<encadreurUpdateInput, encadreurUncheckedUpdateInput>
  }

  /**
   * encadreur delete
   */
  export type encadreurDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the encadreur
     */
    select?: encadreurSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: encadreurInclude<ExtArgs> | null
    /**
     * Filter which encadreur to delete.
     */
    where: encadreurWhereUniqueInput
  }

  /**
   * encadreur deleteMany
   */
  export type encadreurDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which encadreurs to delete
     */
    where?: encadreurWhereInput
  }

  /**
   * encadreur.affectation
   */
  export type encadreur$affectationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the affectation
     */
    select?: affectationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: affectationInclude<ExtArgs> | null
    where?: affectationWhereInput
    orderBy?: affectationOrderByWithRelationInput | affectationOrderByWithRelationInput[]
    cursor?: affectationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AffectationScalarFieldEnum | AffectationScalarFieldEnum[]
  }

  /**
   * encadreur.structures
   */
  export type encadreur$structuresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the structures
     */
    select?: structuresSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: structuresInclude<ExtArgs> | null
    where?: structuresWhereInput
  }

  /**
   * encadreur without action
   */
  export type encadreurDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the encadreur
     */
    select?: encadreurSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: encadreurInclude<ExtArgs> | null
  }


  /**
   * Model etudiant
   */

  export type AggregateEtudiant = {
    _count: EtudiantCountAggregateOutputType | null
    _min: EtudiantMinAggregateOutputType | null
    _max: EtudiantMaxAggregateOutputType | null
  }

  export type EtudiantMinAggregateOutputType = {
    MATRICULEETUDIANT: string | null
    NOMETUDIANT: string | null
    PRENOMETUDIANT: string | null
    ETABLISSEMENT: string | null
    VILLERESIDENCE: string | null
    PARCOURS: string | null
    NIVEAU: string | null
    EMAIL: string | null
    TEL: string | null
    FILIERE: string | null
    SEXE: string | null
    DATE: Date | null
  }

  export type EtudiantMaxAggregateOutputType = {
    MATRICULEETUDIANT: string | null
    NOMETUDIANT: string | null
    PRENOMETUDIANT: string | null
    ETABLISSEMENT: string | null
    VILLERESIDENCE: string | null
    PARCOURS: string | null
    NIVEAU: string | null
    EMAIL: string | null
    TEL: string | null
    FILIERE: string | null
    SEXE: string | null
    DATE: Date | null
  }

  export type EtudiantCountAggregateOutputType = {
    MATRICULEETUDIANT: number
    NOMETUDIANT: number
    PRENOMETUDIANT: number
    ETABLISSEMENT: number
    VILLERESIDENCE: number
    PARCOURS: number
    NIVEAU: number
    EMAIL: number
    TEL: number
    FILIERE: number
    SEXE: number
    DATE: number
    _all: number
  }


  export type EtudiantMinAggregateInputType = {
    MATRICULEETUDIANT?: true
    NOMETUDIANT?: true
    PRENOMETUDIANT?: true
    ETABLISSEMENT?: true
    VILLERESIDENCE?: true
    PARCOURS?: true
    NIVEAU?: true
    EMAIL?: true
    TEL?: true
    FILIERE?: true
    SEXE?: true
    DATE?: true
  }

  export type EtudiantMaxAggregateInputType = {
    MATRICULEETUDIANT?: true
    NOMETUDIANT?: true
    PRENOMETUDIANT?: true
    ETABLISSEMENT?: true
    VILLERESIDENCE?: true
    PARCOURS?: true
    NIVEAU?: true
    EMAIL?: true
    TEL?: true
    FILIERE?: true
    SEXE?: true
    DATE?: true
  }

  export type EtudiantCountAggregateInputType = {
    MATRICULEETUDIANT?: true
    NOMETUDIANT?: true
    PRENOMETUDIANT?: true
    ETABLISSEMENT?: true
    VILLERESIDENCE?: true
    PARCOURS?: true
    NIVEAU?: true
    EMAIL?: true
    TEL?: true
    FILIERE?: true
    SEXE?: true
    DATE?: true
    _all?: true
  }

  export type EtudiantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which etudiant to aggregate.
     */
    where?: etudiantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of etudiants to fetch.
     */
    orderBy?: etudiantOrderByWithRelationInput | etudiantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: etudiantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` etudiants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` etudiants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned etudiants
    **/
    _count?: true | EtudiantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EtudiantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EtudiantMaxAggregateInputType
  }

  export type GetEtudiantAggregateType<T extends EtudiantAggregateArgs> = {
        [P in keyof T & keyof AggregateEtudiant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEtudiant[P]>
      : GetScalarType<T[P], AggregateEtudiant[P]>
  }




  export type etudiantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: etudiantWhereInput
    orderBy?: etudiantOrderByWithAggregationInput | etudiantOrderByWithAggregationInput[]
    by: EtudiantScalarFieldEnum[] | EtudiantScalarFieldEnum
    having?: etudiantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EtudiantCountAggregateInputType | true
    _min?: EtudiantMinAggregateInputType
    _max?: EtudiantMaxAggregateInputType
  }

  export type EtudiantGroupByOutputType = {
    MATRICULEETUDIANT: string
    NOMETUDIANT: string | null
    PRENOMETUDIANT: string | null
    ETABLISSEMENT: string | null
    VILLERESIDENCE: string | null
    PARCOURS: string | null
    NIVEAU: string | null
    EMAIL: string
    TEL: string
    FILIERE: string
    SEXE: string
    DATE: Date
    _count: EtudiantCountAggregateOutputType | null
    _min: EtudiantMinAggregateOutputType | null
    _max: EtudiantMaxAggregateOutputType | null
  }

  type GetEtudiantGroupByPayload<T extends etudiantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EtudiantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EtudiantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EtudiantGroupByOutputType[P]>
            : GetScalarType<T[P], EtudiantGroupByOutputType[P]>
        }
      >
    >


  export type etudiantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    MATRICULEETUDIANT?: boolean
    NOMETUDIANT?: boolean
    PRENOMETUDIANT?: boolean
    ETABLISSEMENT?: boolean
    VILLERESIDENCE?: boolean
    PARCOURS?: boolean
    NIVEAU?: boolean
    EMAIL?: boolean
    TEL?: boolean
    FILIERE?: boolean
    SEXE?: boolean
    DATE?: boolean
    dossier?: boolean | etudiant$dossierArgs<ExtArgs>
    rapport?: boolean | etudiant$rapportArgs<ExtArgs>
    _count?: boolean | EtudiantCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["etudiant"]>


  export type etudiantSelectScalar = {
    MATRICULEETUDIANT?: boolean
    NOMETUDIANT?: boolean
    PRENOMETUDIANT?: boolean
    ETABLISSEMENT?: boolean
    VILLERESIDENCE?: boolean
    PARCOURS?: boolean
    NIVEAU?: boolean
    EMAIL?: boolean
    TEL?: boolean
    FILIERE?: boolean
    SEXE?: boolean
    DATE?: boolean
  }

  export type etudiantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dossier?: boolean | etudiant$dossierArgs<ExtArgs>
    rapport?: boolean | etudiant$rapportArgs<ExtArgs>
    _count?: boolean | EtudiantCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $etudiantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "etudiant"
    objects: {
      dossier: Prisma.$dossierPayload<ExtArgs>[]
      rapport: Prisma.$rapportPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      MATRICULEETUDIANT: string
      NOMETUDIANT: string | null
      PRENOMETUDIANT: string | null
      ETABLISSEMENT: string | null
      VILLERESIDENCE: string | null
      PARCOURS: string | null
      NIVEAU: string | null
      EMAIL: string
      TEL: string
      FILIERE: string
      SEXE: string
      DATE: Date
    }, ExtArgs["result"]["etudiant"]>
    composites: {}
  }

  type etudiantGetPayload<S extends boolean | null | undefined | etudiantDefaultArgs> = $Result.GetResult<Prisma.$etudiantPayload, S>

  type etudiantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<etudiantFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EtudiantCountAggregateInputType | true
    }

  export interface etudiantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['etudiant'], meta: { name: 'etudiant' } }
    /**
     * Find zero or one Etudiant that matches the filter.
     * @param {etudiantFindUniqueArgs} args - Arguments to find a Etudiant
     * @example
     * // Get one Etudiant
     * const etudiant = await prisma.etudiant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends etudiantFindUniqueArgs>(args: SelectSubset<T, etudiantFindUniqueArgs<ExtArgs>>): Prisma__etudiantClient<$Result.GetResult<Prisma.$etudiantPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Etudiant that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {etudiantFindUniqueOrThrowArgs} args - Arguments to find a Etudiant
     * @example
     * // Get one Etudiant
     * const etudiant = await prisma.etudiant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends etudiantFindUniqueOrThrowArgs>(args: SelectSubset<T, etudiantFindUniqueOrThrowArgs<ExtArgs>>): Prisma__etudiantClient<$Result.GetResult<Prisma.$etudiantPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Etudiant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {etudiantFindFirstArgs} args - Arguments to find a Etudiant
     * @example
     * // Get one Etudiant
     * const etudiant = await prisma.etudiant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends etudiantFindFirstArgs>(args?: SelectSubset<T, etudiantFindFirstArgs<ExtArgs>>): Prisma__etudiantClient<$Result.GetResult<Prisma.$etudiantPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Etudiant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {etudiantFindFirstOrThrowArgs} args - Arguments to find a Etudiant
     * @example
     * // Get one Etudiant
     * const etudiant = await prisma.etudiant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends etudiantFindFirstOrThrowArgs>(args?: SelectSubset<T, etudiantFindFirstOrThrowArgs<ExtArgs>>): Prisma__etudiantClient<$Result.GetResult<Prisma.$etudiantPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Etudiants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {etudiantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Etudiants
     * const etudiants = await prisma.etudiant.findMany()
     * 
     * // Get first 10 Etudiants
     * const etudiants = await prisma.etudiant.findMany({ take: 10 })
     * 
     * // Only select the `MATRICULEETUDIANT`
     * const etudiantWithMATRICULEETUDIANTOnly = await prisma.etudiant.findMany({ select: { MATRICULEETUDIANT: true } })
     * 
     */
    findMany<T extends etudiantFindManyArgs>(args?: SelectSubset<T, etudiantFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$etudiantPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Etudiant.
     * @param {etudiantCreateArgs} args - Arguments to create a Etudiant.
     * @example
     * // Create one Etudiant
     * const Etudiant = await prisma.etudiant.create({
     *   data: {
     *     // ... data to create a Etudiant
     *   }
     * })
     * 
     */
    create<T extends etudiantCreateArgs>(args: SelectSubset<T, etudiantCreateArgs<ExtArgs>>): Prisma__etudiantClient<$Result.GetResult<Prisma.$etudiantPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Etudiants.
     * @param {etudiantCreateManyArgs} args - Arguments to create many Etudiants.
     * @example
     * // Create many Etudiants
     * const etudiant = await prisma.etudiant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends etudiantCreateManyArgs>(args?: SelectSubset<T, etudiantCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Etudiant.
     * @param {etudiantDeleteArgs} args - Arguments to delete one Etudiant.
     * @example
     * // Delete one Etudiant
     * const Etudiant = await prisma.etudiant.delete({
     *   where: {
     *     // ... filter to delete one Etudiant
     *   }
     * })
     * 
     */
    delete<T extends etudiantDeleteArgs>(args: SelectSubset<T, etudiantDeleteArgs<ExtArgs>>): Prisma__etudiantClient<$Result.GetResult<Prisma.$etudiantPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Etudiant.
     * @param {etudiantUpdateArgs} args - Arguments to update one Etudiant.
     * @example
     * // Update one Etudiant
     * const etudiant = await prisma.etudiant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends etudiantUpdateArgs>(args: SelectSubset<T, etudiantUpdateArgs<ExtArgs>>): Prisma__etudiantClient<$Result.GetResult<Prisma.$etudiantPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Etudiants.
     * @param {etudiantDeleteManyArgs} args - Arguments to filter Etudiants to delete.
     * @example
     * // Delete a few Etudiants
     * const { count } = await prisma.etudiant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends etudiantDeleteManyArgs>(args?: SelectSubset<T, etudiantDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Etudiants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {etudiantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Etudiants
     * const etudiant = await prisma.etudiant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends etudiantUpdateManyArgs>(args: SelectSubset<T, etudiantUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Etudiant.
     * @param {etudiantUpsertArgs} args - Arguments to update or create a Etudiant.
     * @example
     * // Update or create a Etudiant
     * const etudiant = await prisma.etudiant.upsert({
     *   create: {
     *     // ... data to create a Etudiant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Etudiant we want to update
     *   }
     * })
     */
    upsert<T extends etudiantUpsertArgs>(args: SelectSubset<T, etudiantUpsertArgs<ExtArgs>>): Prisma__etudiantClient<$Result.GetResult<Prisma.$etudiantPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Etudiants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {etudiantCountArgs} args - Arguments to filter Etudiants to count.
     * @example
     * // Count the number of Etudiants
     * const count = await prisma.etudiant.count({
     *   where: {
     *     // ... the filter for the Etudiants we want to count
     *   }
     * })
    **/
    count<T extends etudiantCountArgs>(
      args?: Subset<T, etudiantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EtudiantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Etudiant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EtudiantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EtudiantAggregateArgs>(args: Subset<T, EtudiantAggregateArgs>): Prisma.PrismaPromise<GetEtudiantAggregateType<T>>

    /**
     * Group by Etudiant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {etudiantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends etudiantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: etudiantGroupByArgs['orderBy'] }
        : { orderBy?: etudiantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, etudiantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEtudiantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the etudiant model
   */
  readonly fields: etudiantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for etudiant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__etudiantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    dossier<T extends etudiant$dossierArgs<ExtArgs> = {}>(args?: Subset<T, etudiant$dossierArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$dossierPayload<ExtArgs>, T, "findMany"> | Null>
    rapport<T extends etudiant$rapportArgs<ExtArgs> = {}>(args?: Subset<T, etudiant$rapportArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$rapportPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the etudiant model
   */ 
  interface etudiantFieldRefs {
    readonly MATRICULEETUDIANT: FieldRef<"etudiant", 'String'>
    readonly NOMETUDIANT: FieldRef<"etudiant", 'String'>
    readonly PRENOMETUDIANT: FieldRef<"etudiant", 'String'>
    readonly ETABLISSEMENT: FieldRef<"etudiant", 'String'>
    readonly VILLERESIDENCE: FieldRef<"etudiant", 'String'>
    readonly PARCOURS: FieldRef<"etudiant", 'String'>
    readonly NIVEAU: FieldRef<"etudiant", 'String'>
    readonly EMAIL: FieldRef<"etudiant", 'String'>
    readonly TEL: FieldRef<"etudiant", 'String'>
    readonly FILIERE: FieldRef<"etudiant", 'String'>
    readonly SEXE: FieldRef<"etudiant", 'String'>
    readonly DATE: FieldRef<"etudiant", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * etudiant findUnique
   */
  export type etudiantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the etudiant
     */
    select?: etudiantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: etudiantInclude<ExtArgs> | null
    /**
     * Filter, which etudiant to fetch.
     */
    where: etudiantWhereUniqueInput
  }

  /**
   * etudiant findUniqueOrThrow
   */
  export type etudiantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the etudiant
     */
    select?: etudiantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: etudiantInclude<ExtArgs> | null
    /**
     * Filter, which etudiant to fetch.
     */
    where: etudiantWhereUniqueInput
  }

  /**
   * etudiant findFirst
   */
  export type etudiantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the etudiant
     */
    select?: etudiantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: etudiantInclude<ExtArgs> | null
    /**
     * Filter, which etudiant to fetch.
     */
    where?: etudiantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of etudiants to fetch.
     */
    orderBy?: etudiantOrderByWithRelationInput | etudiantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for etudiants.
     */
    cursor?: etudiantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` etudiants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` etudiants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of etudiants.
     */
    distinct?: EtudiantScalarFieldEnum | EtudiantScalarFieldEnum[]
  }

  /**
   * etudiant findFirstOrThrow
   */
  export type etudiantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the etudiant
     */
    select?: etudiantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: etudiantInclude<ExtArgs> | null
    /**
     * Filter, which etudiant to fetch.
     */
    where?: etudiantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of etudiants to fetch.
     */
    orderBy?: etudiantOrderByWithRelationInput | etudiantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for etudiants.
     */
    cursor?: etudiantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` etudiants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` etudiants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of etudiants.
     */
    distinct?: EtudiantScalarFieldEnum | EtudiantScalarFieldEnum[]
  }

  /**
   * etudiant findMany
   */
  export type etudiantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the etudiant
     */
    select?: etudiantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: etudiantInclude<ExtArgs> | null
    /**
     * Filter, which etudiants to fetch.
     */
    where?: etudiantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of etudiants to fetch.
     */
    orderBy?: etudiantOrderByWithRelationInput | etudiantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing etudiants.
     */
    cursor?: etudiantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` etudiants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` etudiants.
     */
    skip?: number
    distinct?: EtudiantScalarFieldEnum | EtudiantScalarFieldEnum[]
  }

  /**
   * etudiant create
   */
  export type etudiantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the etudiant
     */
    select?: etudiantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: etudiantInclude<ExtArgs> | null
    /**
     * The data needed to create a etudiant.
     */
    data: XOR<etudiantCreateInput, etudiantUncheckedCreateInput>
  }

  /**
   * etudiant createMany
   */
  export type etudiantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many etudiants.
     */
    data: etudiantCreateManyInput | etudiantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * etudiant update
   */
  export type etudiantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the etudiant
     */
    select?: etudiantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: etudiantInclude<ExtArgs> | null
    /**
     * The data needed to update a etudiant.
     */
    data: XOR<etudiantUpdateInput, etudiantUncheckedUpdateInput>
    /**
     * Choose, which etudiant to update.
     */
    where: etudiantWhereUniqueInput
  }

  /**
   * etudiant updateMany
   */
  export type etudiantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update etudiants.
     */
    data: XOR<etudiantUpdateManyMutationInput, etudiantUncheckedUpdateManyInput>
    /**
     * Filter which etudiants to update
     */
    where?: etudiantWhereInput
  }

  /**
   * etudiant upsert
   */
  export type etudiantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the etudiant
     */
    select?: etudiantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: etudiantInclude<ExtArgs> | null
    /**
     * The filter to search for the etudiant to update in case it exists.
     */
    where: etudiantWhereUniqueInput
    /**
     * In case the etudiant found by the `where` argument doesn't exist, create a new etudiant with this data.
     */
    create: XOR<etudiantCreateInput, etudiantUncheckedCreateInput>
    /**
     * In case the etudiant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<etudiantUpdateInput, etudiantUncheckedUpdateInput>
  }

  /**
   * etudiant delete
   */
  export type etudiantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the etudiant
     */
    select?: etudiantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: etudiantInclude<ExtArgs> | null
    /**
     * Filter which etudiant to delete.
     */
    where: etudiantWhereUniqueInput
  }

  /**
   * etudiant deleteMany
   */
  export type etudiantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which etudiants to delete
     */
    where?: etudiantWhereInput
  }

  /**
   * etudiant.dossier
   */
  export type etudiant$dossierArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the dossier
     */
    select?: dossierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: dossierInclude<ExtArgs> | null
    where?: dossierWhereInput
    orderBy?: dossierOrderByWithRelationInput | dossierOrderByWithRelationInput[]
    cursor?: dossierWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DossierScalarFieldEnum | DossierScalarFieldEnum[]
  }

  /**
   * etudiant.rapport
   */
  export type etudiant$rapportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rapport
     */
    select?: rapportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rapportInclude<ExtArgs> | null
    where?: rapportWhereInput
    orderBy?: rapportOrderByWithRelationInput | rapportOrderByWithRelationInput[]
    cursor?: rapportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RapportScalarFieldEnum | RapportScalarFieldEnum[]
  }

  /**
   * etudiant without action
   */
  export type etudiantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the etudiant
     */
    select?: etudiantSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: etudiantInclude<ExtArgs> | null
  }


  /**
   * Model logs_actions
   */

  export type AggregateLogs_actions = {
    _count: Logs_actionsCountAggregateOutputType | null
    _avg: Logs_actionsAvgAggregateOutputType | null
    _sum: Logs_actionsSumAggregateOutputType | null
    _min: Logs_actionsMinAggregateOutputType | null
    _max: Logs_actionsMaxAggregateOutputType | null
  }

  export type Logs_actionsAvgAggregateOutputType = {
    id: number | null
    status_code: number | null
  }

  export type Logs_actionsSumAggregateOutputType = {
    id: number | null
    status_code: number | null
  }

  export type Logs_actionsMinAggregateOutputType = {
    id: number | null
    user_email: string | null
    user_name: string | null
    action: string | null
    methode_http: string | null
    endpoint: string | null
    requete_executee: string | null
    ip_address: string | null
    user_agent: string | null
    status_code: number | null
    horodatage: Date | null
  }

  export type Logs_actionsMaxAggregateOutputType = {
    id: number | null
    user_email: string | null
    user_name: string | null
    action: string | null
    methode_http: string | null
    endpoint: string | null
    requete_executee: string | null
    ip_address: string | null
    user_agent: string | null
    status_code: number | null
    horodatage: Date | null
  }

  export type Logs_actionsCountAggregateOutputType = {
    id: number
    user_email: number
    user_name: number
    action: number
    methode_http: number
    endpoint: number
    requete_executee: number
    ip_address: number
    user_agent: number
    status_code: number
    horodatage: number
    _all: number
  }


  export type Logs_actionsAvgAggregateInputType = {
    id?: true
    status_code?: true
  }

  export type Logs_actionsSumAggregateInputType = {
    id?: true
    status_code?: true
  }

  export type Logs_actionsMinAggregateInputType = {
    id?: true
    user_email?: true
    user_name?: true
    action?: true
    methode_http?: true
    endpoint?: true
    requete_executee?: true
    ip_address?: true
    user_agent?: true
    status_code?: true
    horodatage?: true
  }

  export type Logs_actionsMaxAggregateInputType = {
    id?: true
    user_email?: true
    user_name?: true
    action?: true
    methode_http?: true
    endpoint?: true
    requete_executee?: true
    ip_address?: true
    user_agent?: true
    status_code?: true
    horodatage?: true
  }

  export type Logs_actionsCountAggregateInputType = {
    id?: true
    user_email?: true
    user_name?: true
    action?: true
    methode_http?: true
    endpoint?: true
    requete_executee?: true
    ip_address?: true
    user_agent?: true
    status_code?: true
    horodatage?: true
    _all?: true
  }

  export type Logs_actionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which logs_actions to aggregate.
     */
    where?: logs_actionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of logs_actions to fetch.
     */
    orderBy?: logs_actionsOrderByWithRelationInput | logs_actionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: logs_actionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` logs_actions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` logs_actions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned logs_actions
    **/
    _count?: true | Logs_actionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Logs_actionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Logs_actionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Logs_actionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Logs_actionsMaxAggregateInputType
  }

  export type GetLogs_actionsAggregateType<T extends Logs_actionsAggregateArgs> = {
        [P in keyof T & keyof AggregateLogs_actions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLogs_actions[P]>
      : GetScalarType<T[P], AggregateLogs_actions[P]>
  }




  export type logs_actionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: logs_actionsWhereInput
    orderBy?: logs_actionsOrderByWithAggregationInput | logs_actionsOrderByWithAggregationInput[]
    by: Logs_actionsScalarFieldEnum[] | Logs_actionsScalarFieldEnum
    having?: logs_actionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Logs_actionsCountAggregateInputType | true
    _avg?: Logs_actionsAvgAggregateInputType
    _sum?: Logs_actionsSumAggregateInputType
    _min?: Logs_actionsMinAggregateInputType
    _max?: Logs_actionsMaxAggregateInputType
  }

  export type Logs_actionsGroupByOutputType = {
    id: number
    user_email: string | null
    user_name: string | null
    action: string | null
    methode_http: string | null
    endpoint: string | null
    requete_executee: string | null
    ip_address: string | null
    user_agent: string | null
    status_code: number | null
    horodatage: Date | null
    _count: Logs_actionsCountAggregateOutputType | null
    _avg: Logs_actionsAvgAggregateOutputType | null
    _sum: Logs_actionsSumAggregateOutputType | null
    _min: Logs_actionsMinAggregateOutputType | null
    _max: Logs_actionsMaxAggregateOutputType | null
  }

  type GetLogs_actionsGroupByPayload<T extends logs_actionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Logs_actionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Logs_actionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Logs_actionsGroupByOutputType[P]>
            : GetScalarType<T[P], Logs_actionsGroupByOutputType[P]>
        }
      >
    >


  export type logs_actionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_email?: boolean
    user_name?: boolean
    action?: boolean
    methode_http?: boolean
    endpoint?: boolean
    requete_executee?: boolean
    ip_address?: boolean
    user_agent?: boolean
    status_code?: boolean
    horodatage?: boolean
  }, ExtArgs["result"]["logs_actions"]>


  export type logs_actionsSelectScalar = {
    id?: boolean
    user_email?: boolean
    user_name?: boolean
    action?: boolean
    methode_http?: boolean
    endpoint?: boolean
    requete_executee?: boolean
    ip_address?: boolean
    user_agent?: boolean
    status_code?: boolean
    horodatage?: boolean
  }


  export type $logs_actionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "logs_actions"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      user_email: string | null
      user_name: string | null
      action: string | null
      methode_http: string | null
      endpoint: string | null
      requete_executee: string | null
      ip_address: string | null
      user_agent: string | null
      status_code: number | null
      horodatage: Date | null
    }, ExtArgs["result"]["logs_actions"]>
    composites: {}
  }

  type logs_actionsGetPayload<S extends boolean | null | undefined | logs_actionsDefaultArgs> = $Result.GetResult<Prisma.$logs_actionsPayload, S>

  type logs_actionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<logs_actionsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Logs_actionsCountAggregateInputType | true
    }

  export interface logs_actionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['logs_actions'], meta: { name: 'logs_actions' } }
    /**
     * Find zero or one Logs_actions that matches the filter.
     * @param {logs_actionsFindUniqueArgs} args - Arguments to find a Logs_actions
     * @example
     * // Get one Logs_actions
     * const logs_actions = await prisma.logs_actions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends logs_actionsFindUniqueArgs>(args: SelectSubset<T, logs_actionsFindUniqueArgs<ExtArgs>>): Prisma__logs_actionsClient<$Result.GetResult<Prisma.$logs_actionsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Logs_actions that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {logs_actionsFindUniqueOrThrowArgs} args - Arguments to find a Logs_actions
     * @example
     * // Get one Logs_actions
     * const logs_actions = await prisma.logs_actions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends logs_actionsFindUniqueOrThrowArgs>(args: SelectSubset<T, logs_actionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__logs_actionsClient<$Result.GetResult<Prisma.$logs_actionsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Logs_actions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {logs_actionsFindFirstArgs} args - Arguments to find a Logs_actions
     * @example
     * // Get one Logs_actions
     * const logs_actions = await prisma.logs_actions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends logs_actionsFindFirstArgs>(args?: SelectSubset<T, logs_actionsFindFirstArgs<ExtArgs>>): Prisma__logs_actionsClient<$Result.GetResult<Prisma.$logs_actionsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Logs_actions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {logs_actionsFindFirstOrThrowArgs} args - Arguments to find a Logs_actions
     * @example
     * // Get one Logs_actions
     * const logs_actions = await prisma.logs_actions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends logs_actionsFindFirstOrThrowArgs>(args?: SelectSubset<T, logs_actionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__logs_actionsClient<$Result.GetResult<Prisma.$logs_actionsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Logs_actions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {logs_actionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Logs_actions
     * const logs_actions = await prisma.logs_actions.findMany()
     * 
     * // Get first 10 Logs_actions
     * const logs_actions = await prisma.logs_actions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const logs_actionsWithIdOnly = await prisma.logs_actions.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends logs_actionsFindManyArgs>(args?: SelectSubset<T, logs_actionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$logs_actionsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Logs_actions.
     * @param {logs_actionsCreateArgs} args - Arguments to create a Logs_actions.
     * @example
     * // Create one Logs_actions
     * const Logs_actions = await prisma.logs_actions.create({
     *   data: {
     *     // ... data to create a Logs_actions
     *   }
     * })
     * 
     */
    create<T extends logs_actionsCreateArgs>(args: SelectSubset<T, logs_actionsCreateArgs<ExtArgs>>): Prisma__logs_actionsClient<$Result.GetResult<Prisma.$logs_actionsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Logs_actions.
     * @param {logs_actionsCreateManyArgs} args - Arguments to create many Logs_actions.
     * @example
     * // Create many Logs_actions
     * const logs_actions = await prisma.logs_actions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends logs_actionsCreateManyArgs>(args?: SelectSubset<T, logs_actionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Logs_actions.
     * @param {logs_actionsDeleteArgs} args - Arguments to delete one Logs_actions.
     * @example
     * // Delete one Logs_actions
     * const Logs_actions = await prisma.logs_actions.delete({
     *   where: {
     *     // ... filter to delete one Logs_actions
     *   }
     * })
     * 
     */
    delete<T extends logs_actionsDeleteArgs>(args: SelectSubset<T, logs_actionsDeleteArgs<ExtArgs>>): Prisma__logs_actionsClient<$Result.GetResult<Prisma.$logs_actionsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Logs_actions.
     * @param {logs_actionsUpdateArgs} args - Arguments to update one Logs_actions.
     * @example
     * // Update one Logs_actions
     * const logs_actions = await prisma.logs_actions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends logs_actionsUpdateArgs>(args: SelectSubset<T, logs_actionsUpdateArgs<ExtArgs>>): Prisma__logs_actionsClient<$Result.GetResult<Prisma.$logs_actionsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Logs_actions.
     * @param {logs_actionsDeleteManyArgs} args - Arguments to filter Logs_actions to delete.
     * @example
     * // Delete a few Logs_actions
     * const { count } = await prisma.logs_actions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends logs_actionsDeleteManyArgs>(args?: SelectSubset<T, logs_actionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Logs_actions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {logs_actionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Logs_actions
     * const logs_actions = await prisma.logs_actions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends logs_actionsUpdateManyArgs>(args: SelectSubset<T, logs_actionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Logs_actions.
     * @param {logs_actionsUpsertArgs} args - Arguments to update or create a Logs_actions.
     * @example
     * // Update or create a Logs_actions
     * const logs_actions = await prisma.logs_actions.upsert({
     *   create: {
     *     // ... data to create a Logs_actions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Logs_actions we want to update
     *   }
     * })
     */
    upsert<T extends logs_actionsUpsertArgs>(args: SelectSubset<T, logs_actionsUpsertArgs<ExtArgs>>): Prisma__logs_actionsClient<$Result.GetResult<Prisma.$logs_actionsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Logs_actions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {logs_actionsCountArgs} args - Arguments to filter Logs_actions to count.
     * @example
     * // Count the number of Logs_actions
     * const count = await prisma.logs_actions.count({
     *   where: {
     *     // ... the filter for the Logs_actions we want to count
     *   }
     * })
    **/
    count<T extends logs_actionsCountArgs>(
      args?: Subset<T, logs_actionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Logs_actionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Logs_actions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Logs_actionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Logs_actionsAggregateArgs>(args: Subset<T, Logs_actionsAggregateArgs>): Prisma.PrismaPromise<GetLogs_actionsAggregateType<T>>

    /**
     * Group by Logs_actions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {logs_actionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends logs_actionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: logs_actionsGroupByArgs['orderBy'] }
        : { orderBy?: logs_actionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, logs_actionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLogs_actionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the logs_actions model
   */
  readonly fields: logs_actionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for logs_actions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__logs_actionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the logs_actions model
   */ 
  interface logs_actionsFieldRefs {
    readonly id: FieldRef<"logs_actions", 'Int'>
    readonly user_email: FieldRef<"logs_actions", 'String'>
    readonly user_name: FieldRef<"logs_actions", 'String'>
    readonly action: FieldRef<"logs_actions", 'String'>
    readonly methode_http: FieldRef<"logs_actions", 'String'>
    readonly endpoint: FieldRef<"logs_actions", 'String'>
    readonly requete_executee: FieldRef<"logs_actions", 'String'>
    readonly ip_address: FieldRef<"logs_actions", 'String'>
    readonly user_agent: FieldRef<"logs_actions", 'String'>
    readonly status_code: FieldRef<"logs_actions", 'Int'>
    readonly horodatage: FieldRef<"logs_actions", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * logs_actions findUnique
   */
  export type logs_actionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the logs_actions
     */
    select?: logs_actionsSelect<ExtArgs> | null
    /**
     * Filter, which logs_actions to fetch.
     */
    where: logs_actionsWhereUniqueInput
  }

  /**
   * logs_actions findUniqueOrThrow
   */
  export type logs_actionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the logs_actions
     */
    select?: logs_actionsSelect<ExtArgs> | null
    /**
     * Filter, which logs_actions to fetch.
     */
    where: logs_actionsWhereUniqueInput
  }

  /**
   * logs_actions findFirst
   */
  export type logs_actionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the logs_actions
     */
    select?: logs_actionsSelect<ExtArgs> | null
    /**
     * Filter, which logs_actions to fetch.
     */
    where?: logs_actionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of logs_actions to fetch.
     */
    orderBy?: logs_actionsOrderByWithRelationInput | logs_actionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for logs_actions.
     */
    cursor?: logs_actionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` logs_actions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` logs_actions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of logs_actions.
     */
    distinct?: Logs_actionsScalarFieldEnum | Logs_actionsScalarFieldEnum[]
  }

  /**
   * logs_actions findFirstOrThrow
   */
  export type logs_actionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the logs_actions
     */
    select?: logs_actionsSelect<ExtArgs> | null
    /**
     * Filter, which logs_actions to fetch.
     */
    where?: logs_actionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of logs_actions to fetch.
     */
    orderBy?: logs_actionsOrderByWithRelationInput | logs_actionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for logs_actions.
     */
    cursor?: logs_actionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` logs_actions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` logs_actions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of logs_actions.
     */
    distinct?: Logs_actionsScalarFieldEnum | Logs_actionsScalarFieldEnum[]
  }

  /**
   * logs_actions findMany
   */
  export type logs_actionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the logs_actions
     */
    select?: logs_actionsSelect<ExtArgs> | null
    /**
     * Filter, which logs_actions to fetch.
     */
    where?: logs_actionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of logs_actions to fetch.
     */
    orderBy?: logs_actionsOrderByWithRelationInput | logs_actionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing logs_actions.
     */
    cursor?: logs_actionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` logs_actions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` logs_actions.
     */
    skip?: number
    distinct?: Logs_actionsScalarFieldEnum | Logs_actionsScalarFieldEnum[]
  }

  /**
   * logs_actions create
   */
  export type logs_actionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the logs_actions
     */
    select?: logs_actionsSelect<ExtArgs> | null
    /**
     * The data needed to create a logs_actions.
     */
    data?: XOR<logs_actionsCreateInput, logs_actionsUncheckedCreateInput>
  }

  /**
   * logs_actions createMany
   */
  export type logs_actionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many logs_actions.
     */
    data: logs_actionsCreateManyInput | logs_actionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * logs_actions update
   */
  export type logs_actionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the logs_actions
     */
    select?: logs_actionsSelect<ExtArgs> | null
    /**
     * The data needed to update a logs_actions.
     */
    data: XOR<logs_actionsUpdateInput, logs_actionsUncheckedUpdateInput>
    /**
     * Choose, which logs_actions to update.
     */
    where: logs_actionsWhereUniqueInput
  }

  /**
   * logs_actions updateMany
   */
  export type logs_actionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update logs_actions.
     */
    data: XOR<logs_actionsUpdateManyMutationInput, logs_actionsUncheckedUpdateManyInput>
    /**
     * Filter which logs_actions to update
     */
    where?: logs_actionsWhereInput
  }

  /**
   * logs_actions upsert
   */
  export type logs_actionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the logs_actions
     */
    select?: logs_actionsSelect<ExtArgs> | null
    /**
     * The filter to search for the logs_actions to update in case it exists.
     */
    where: logs_actionsWhereUniqueInput
    /**
     * In case the logs_actions found by the `where` argument doesn't exist, create a new logs_actions with this data.
     */
    create: XOR<logs_actionsCreateInput, logs_actionsUncheckedCreateInput>
    /**
     * In case the logs_actions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<logs_actionsUpdateInput, logs_actionsUncheckedUpdateInput>
  }

  /**
   * logs_actions delete
   */
  export type logs_actionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the logs_actions
     */
    select?: logs_actionsSelect<ExtArgs> | null
    /**
     * Filter which logs_actions to delete.
     */
    where: logs_actionsWhereUniqueInput
  }

  /**
   * logs_actions deleteMany
   */
  export type logs_actionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which logs_actions to delete
     */
    where?: logs_actionsWhereInput
  }

  /**
   * logs_actions without action
   */
  export type logs_actionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the logs_actions
     */
    select?: logs_actionsSelect<ExtArgs> | null
  }


  /**
   * Model rapport
   */

  export type AggregateRapport = {
    _count: RapportCountAggregateOutputType | null
    _avg: RapportAvgAggregateOutputType | null
    _sum: RapportSumAggregateOutputType | null
    _min: RapportMinAggregateOutputType | null
    _max: RapportMaxAggregateOutputType | null
  }

  export type RapportAvgAggregateOutputType = {
    IDDOSSIER: number | null
  }

  export type RapportSumAggregateOutputType = {
    IDDOSSIER: number | null
  }

  export type RapportMinAggregateOutputType = {
    IDDOSSIER: number | null
    MATRICULE: string | null
    COMMENTAIRE: string | null
    THEME: string | null
    FICHIER: string | null
    DATE: Date | null
  }

  export type RapportMaxAggregateOutputType = {
    IDDOSSIER: number | null
    MATRICULE: string | null
    COMMENTAIRE: string | null
    THEME: string | null
    FICHIER: string | null
    DATE: Date | null
  }

  export type RapportCountAggregateOutputType = {
    IDDOSSIER: number
    MATRICULE: number
    COMMENTAIRE: number
    THEME: number
    FICHIER: number
    DATE: number
    _all: number
  }


  export type RapportAvgAggregateInputType = {
    IDDOSSIER?: true
  }

  export type RapportSumAggregateInputType = {
    IDDOSSIER?: true
  }

  export type RapportMinAggregateInputType = {
    IDDOSSIER?: true
    MATRICULE?: true
    COMMENTAIRE?: true
    THEME?: true
    FICHIER?: true
    DATE?: true
  }

  export type RapportMaxAggregateInputType = {
    IDDOSSIER?: true
    MATRICULE?: true
    COMMENTAIRE?: true
    THEME?: true
    FICHIER?: true
    DATE?: true
  }

  export type RapportCountAggregateInputType = {
    IDDOSSIER?: true
    MATRICULE?: true
    COMMENTAIRE?: true
    THEME?: true
    FICHIER?: true
    DATE?: true
    _all?: true
  }

  export type RapportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which rapport to aggregate.
     */
    where?: rapportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rapports to fetch.
     */
    orderBy?: rapportOrderByWithRelationInput | rapportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: rapportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rapports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rapports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned rapports
    **/
    _count?: true | RapportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RapportAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RapportSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RapportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RapportMaxAggregateInputType
  }

  export type GetRapportAggregateType<T extends RapportAggregateArgs> = {
        [P in keyof T & keyof AggregateRapport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRapport[P]>
      : GetScalarType<T[P], AggregateRapport[P]>
  }




  export type rapportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: rapportWhereInput
    orderBy?: rapportOrderByWithAggregationInput | rapportOrderByWithAggregationInput[]
    by: RapportScalarFieldEnum[] | RapportScalarFieldEnum
    having?: rapportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RapportCountAggregateInputType | true
    _avg?: RapportAvgAggregateInputType
    _sum?: RapportSumAggregateInputType
    _min?: RapportMinAggregateInputType
    _max?: RapportMaxAggregateInputType
  }

  export type RapportGroupByOutputType = {
    IDDOSSIER: number
    MATRICULE: string
    COMMENTAIRE: string
    THEME: string
    FICHIER: string
    DATE: Date
    _count: RapportCountAggregateOutputType | null
    _avg: RapportAvgAggregateOutputType | null
    _sum: RapportSumAggregateOutputType | null
    _min: RapportMinAggregateOutputType | null
    _max: RapportMaxAggregateOutputType | null
  }

  type GetRapportGroupByPayload<T extends rapportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RapportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RapportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RapportGroupByOutputType[P]>
            : GetScalarType<T[P], RapportGroupByOutputType[P]>
        }
      >
    >


  export type rapportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    IDDOSSIER?: boolean
    MATRICULE?: boolean
    COMMENTAIRE?: boolean
    THEME?: boolean
    FICHIER?: boolean
    DATE?: boolean
    etudiant?: boolean | etudiantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["rapport"]>


  export type rapportSelectScalar = {
    IDDOSSIER?: boolean
    MATRICULE?: boolean
    COMMENTAIRE?: boolean
    THEME?: boolean
    FICHIER?: boolean
    DATE?: boolean
  }

  export type rapportInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    etudiant?: boolean | etudiantDefaultArgs<ExtArgs>
  }

  export type $rapportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "rapport"
    objects: {
      etudiant: Prisma.$etudiantPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      IDDOSSIER: number
      MATRICULE: string
      COMMENTAIRE: string
      THEME: string
      FICHIER: string
      DATE: Date
    }, ExtArgs["result"]["rapport"]>
    composites: {}
  }

  type rapportGetPayload<S extends boolean | null | undefined | rapportDefaultArgs> = $Result.GetResult<Prisma.$rapportPayload, S>

  type rapportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<rapportFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RapportCountAggregateInputType | true
    }

  export interface rapportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['rapport'], meta: { name: 'rapport' } }
    /**
     * Find zero or one Rapport that matches the filter.
     * @param {rapportFindUniqueArgs} args - Arguments to find a Rapport
     * @example
     * // Get one Rapport
     * const rapport = await prisma.rapport.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends rapportFindUniqueArgs>(args: SelectSubset<T, rapportFindUniqueArgs<ExtArgs>>): Prisma__rapportClient<$Result.GetResult<Prisma.$rapportPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Rapport that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {rapportFindUniqueOrThrowArgs} args - Arguments to find a Rapport
     * @example
     * // Get one Rapport
     * const rapport = await prisma.rapport.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends rapportFindUniqueOrThrowArgs>(args: SelectSubset<T, rapportFindUniqueOrThrowArgs<ExtArgs>>): Prisma__rapportClient<$Result.GetResult<Prisma.$rapportPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Rapport that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rapportFindFirstArgs} args - Arguments to find a Rapport
     * @example
     * // Get one Rapport
     * const rapport = await prisma.rapport.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends rapportFindFirstArgs>(args?: SelectSubset<T, rapportFindFirstArgs<ExtArgs>>): Prisma__rapportClient<$Result.GetResult<Prisma.$rapportPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Rapport that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rapportFindFirstOrThrowArgs} args - Arguments to find a Rapport
     * @example
     * // Get one Rapport
     * const rapport = await prisma.rapport.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends rapportFindFirstOrThrowArgs>(args?: SelectSubset<T, rapportFindFirstOrThrowArgs<ExtArgs>>): Prisma__rapportClient<$Result.GetResult<Prisma.$rapportPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Rapports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rapportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Rapports
     * const rapports = await prisma.rapport.findMany()
     * 
     * // Get first 10 Rapports
     * const rapports = await prisma.rapport.findMany({ take: 10 })
     * 
     * // Only select the `IDDOSSIER`
     * const rapportWithIDDOSSIEROnly = await prisma.rapport.findMany({ select: { IDDOSSIER: true } })
     * 
     */
    findMany<T extends rapportFindManyArgs>(args?: SelectSubset<T, rapportFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$rapportPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Rapport.
     * @param {rapportCreateArgs} args - Arguments to create a Rapport.
     * @example
     * // Create one Rapport
     * const Rapport = await prisma.rapport.create({
     *   data: {
     *     // ... data to create a Rapport
     *   }
     * })
     * 
     */
    create<T extends rapportCreateArgs>(args: SelectSubset<T, rapportCreateArgs<ExtArgs>>): Prisma__rapportClient<$Result.GetResult<Prisma.$rapportPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Rapports.
     * @param {rapportCreateManyArgs} args - Arguments to create many Rapports.
     * @example
     * // Create many Rapports
     * const rapport = await prisma.rapport.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends rapportCreateManyArgs>(args?: SelectSubset<T, rapportCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Rapport.
     * @param {rapportDeleteArgs} args - Arguments to delete one Rapport.
     * @example
     * // Delete one Rapport
     * const Rapport = await prisma.rapport.delete({
     *   where: {
     *     // ... filter to delete one Rapport
     *   }
     * })
     * 
     */
    delete<T extends rapportDeleteArgs>(args: SelectSubset<T, rapportDeleteArgs<ExtArgs>>): Prisma__rapportClient<$Result.GetResult<Prisma.$rapportPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Rapport.
     * @param {rapportUpdateArgs} args - Arguments to update one Rapport.
     * @example
     * // Update one Rapport
     * const rapport = await prisma.rapport.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends rapportUpdateArgs>(args: SelectSubset<T, rapportUpdateArgs<ExtArgs>>): Prisma__rapportClient<$Result.GetResult<Prisma.$rapportPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Rapports.
     * @param {rapportDeleteManyArgs} args - Arguments to filter Rapports to delete.
     * @example
     * // Delete a few Rapports
     * const { count } = await prisma.rapport.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends rapportDeleteManyArgs>(args?: SelectSubset<T, rapportDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rapports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rapportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Rapports
     * const rapport = await prisma.rapport.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends rapportUpdateManyArgs>(args: SelectSubset<T, rapportUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Rapport.
     * @param {rapportUpsertArgs} args - Arguments to update or create a Rapport.
     * @example
     * // Update or create a Rapport
     * const rapport = await prisma.rapport.upsert({
     *   create: {
     *     // ... data to create a Rapport
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Rapport we want to update
     *   }
     * })
     */
    upsert<T extends rapportUpsertArgs>(args: SelectSubset<T, rapportUpsertArgs<ExtArgs>>): Prisma__rapportClient<$Result.GetResult<Prisma.$rapportPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Rapports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rapportCountArgs} args - Arguments to filter Rapports to count.
     * @example
     * // Count the number of Rapports
     * const count = await prisma.rapport.count({
     *   where: {
     *     // ... the filter for the Rapports we want to count
     *   }
     * })
    **/
    count<T extends rapportCountArgs>(
      args?: Subset<T, rapportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RapportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Rapport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RapportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RapportAggregateArgs>(args: Subset<T, RapportAggregateArgs>): Prisma.PrismaPromise<GetRapportAggregateType<T>>

    /**
     * Group by Rapport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rapportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends rapportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: rapportGroupByArgs['orderBy'] }
        : { orderBy?: rapportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, rapportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRapportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the rapport model
   */
  readonly fields: rapportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for rapport.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__rapportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    etudiant<T extends etudiantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, etudiantDefaultArgs<ExtArgs>>): Prisma__etudiantClient<$Result.GetResult<Prisma.$etudiantPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the rapport model
   */ 
  interface rapportFieldRefs {
    readonly IDDOSSIER: FieldRef<"rapport", 'Int'>
    readonly MATRICULE: FieldRef<"rapport", 'String'>
    readonly COMMENTAIRE: FieldRef<"rapport", 'String'>
    readonly THEME: FieldRef<"rapport", 'String'>
    readonly FICHIER: FieldRef<"rapport", 'String'>
    readonly DATE: FieldRef<"rapport", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * rapport findUnique
   */
  export type rapportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rapport
     */
    select?: rapportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rapportInclude<ExtArgs> | null
    /**
     * Filter, which rapport to fetch.
     */
    where: rapportWhereUniqueInput
  }

  /**
   * rapport findUniqueOrThrow
   */
  export type rapportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rapport
     */
    select?: rapportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rapportInclude<ExtArgs> | null
    /**
     * Filter, which rapport to fetch.
     */
    where: rapportWhereUniqueInput
  }

  /**
   * rapport findFirst
   */
  export type rapportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rapport
     */
    select?: rapportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rapportInclude<ExtArgs> | null
    /**
     * Filter, which rapport to fetch.
     */
    where?: rapportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rapports to fetch.
     */
    orderBy?: rapportOrderByWithRelationInput | rapportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for rapports.
     */
    cursor?: rapportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rapports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rapports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of rapports.
     */
    distinct?: RapportScalarFieldEnum | RapportScalarFieldEnum[]
  }

  /**
   * rapport findFirstOrThrow
   */
  export type rapportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rapport
     */
    select?: rapportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rapportInclude<ExtArgs> | null
    /**
     * Filter, which rapport to fetch.
     */
    where?: rapportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rapports to fetch.
     */
    orderBy?: rapportOrderByWithRelationInput | rapportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for rapports.
     */
    cursor?: rapportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rapports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rapports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of rapports.
     */
    distinct?: RapportScalarFieldEnum | RapportScalarFieldEnum[]
  }

  /**
   * rapport findMany
   */
  export type rapportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rapport
     */
    select?: rapportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rapportInclude<ExtArgs> | null
    /**
     * Filter, which rapports to fetch.
     */
    where?: rapportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of rapports to fetch.
     */
    orderBy?: rapportOrderByWithRelationInput | rapportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing rapports.
     */
    cursor?: rapportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` rapports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` rapports.
     */
    skip?: number
    distinct?: RapportScalarFieldEnum | RapportScalarFieldEnum[]
  }

  /**
   * rapport create
   */
  export type rapportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rapport
     */
    select?: rapportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rapportInclude<ExtArgs> | null
    /**
     * The data needed to create a rapport.
     */
    data: XOR<rapportCreateInput, rapportUncheckedCreateInput>
  }

  /**
   * rapport createMany
   */
  export type rapportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many rapports.
     */
    data: rapportCreateManyInput | rapportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * rapport update
   */
  export type rapportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rapport
     */
    select?: rapportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rapportInclude<ExtArgs> | null
    /**
     * The data needed to update a rapport.
     */
    data: XOR<rapportUpdateInput, rapportUncheckedUpdateInput>
    /**
     * Choose, which rapport to update.
     */
    where: rapportWhereUniqueInput
  }

  /**
   * rapport updateMany
   */
  export type rapportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update rapports.
     */
    data: XOR<rapportUpdateManyMutationInput, rapportUncheckedUpdateManyInput>
    /**
     * Filter which rapports to update
     */
    where?: rapportWhereInput
  }

  /**
   * rapport upsert
   */
  export type rapportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rapport
     */
    select?: rapportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rapportInclude<ExtArgs> | null
    /**
     * The filter to search for the rapport to update in case it exists.
     */
    where: rapportWhereUniqueInput
    /**
     * In case the rapport found by the `where` argument doesn't exist, create a new rapport with this data.
     */
    create: XOR<rapportCreateInput, rapportUncheckedCreateInput>
    /**
     * In case the rapport was found with the provided `where` argument, update it with this data.
     */
    update: XOR<rapportUpdateInput, rapportUncheckedUpdateInput>
  }

  /**
   * rapport delete
   */
  export type rapportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rapport
     */
    select?: rapportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rapportInclude<ExtArgs> | null
    /**
     * Filter which rapport to delete.
     */
    where: rapportWhereUniqueInput
  }

  /**
   * rapport deleteMany
   */
  export type rapportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which rapports to delete
     */
    where?: rapportWhereInput
  }

  /**
   * rapport without action
   */
  export type rapportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the rapport
     */
    select?: rapportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rapportInclude<ExtArgs> | null
  }


  /**
   * Model lettreAcceptation
   */

  export type AggregateLettreAcceptation = {
    _count: LettreAcceptationCountAggregateOutputType | null
    _avg: LettreAcceptationAvgAggregateOutputType | null
    _sum: LettreAcceptationSumAggregateOutputType | null
    _min: LettreAcceptationMinAggregateOutputType | null
    _max: LettreAcceptationMaxAggregateOutputType | null
  }

  export type LettreAcceptationAvgAggregateOutputType = {
    IDLETTRE: number | null
    IDDOSSIER: number | null
  }

  export type LettreAcceptationSumAggregateOutputType = {
    IDLETTRE: number | null
    IDDOSSIER: number | null
  }

  export type LettreAcceptationMinAggregateOutputType = {
    IDLETTRE: number | null
    IDDOSSIER: number | null
    COMMENTAIRE: string | null
    FICHIER: string | null
    DATEUPLOAD: Date | null
    EMAILSENT: boolean | null
  }

  export type LettreAcceptationMaxAggregateOutputType = {
    IDLETTRE: number | null
    IDDOSSIER: number | null
    COMMENTAIRE: string | null
    FICHIER: string | null
    DATEUPLOAD: Date | null
    EMAILSENT: boolean | null
  }

  export type LettreAcceptationCountAggregateOutputType = {
    IDLETTRE: number
    IDDOSSIER: number
    COMMENTAIRE: number
    FICHIER: number
    DATEUPLOAD: number
    EMAILSENT: number
    _all: number
  }


  export type LettreAcceptationAvgAggregateInputType = {
    IDLETTRE?: true
    IDDOSSIER?: true
  }

  export type LettreAcceptationSumAggregateInputType = {
    IDLETTRE?: true
    IDDOSSIER?: true
  }

  export type LettreAcceptationMinAggregateInputType = {
    IDLETTRE?: true
    IDDOSSIER?: true
    COMMENTAIRE?: true
    FICHIER?: true
    DATEUPLOAD?: true
    EMAILSENT?: true
  }

  export type LettreAcceptationMaxAggregateInputType = {
    IDLETTRE?: true
    IDDOSSIER?: true
    COMMENTAIRE?: true
    FICHIER?: true
    DATEUPLOAD?: true
    EMAILSENT?: true
  }

  export type LettreAcceptationCountAggregateInputType = {
    IDLETTRE?: true
    IDDOSSIER?: true
    COMMENTAIRE?: true
    FICHIER?: true
    DATEUPLOAD?: true
    EMAILSENT?: true
    _all?: true
  }

  export type LettreAcceptationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which lettreAcceptation to aggregate.
     */
    where?: lettreAcceptationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of lettreAcceptations to fetch.
     */
    orderBy?: lettreAcceptationOrderByWithRelationInput | lettreAcceptationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: lettreAcceptationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` lettreAcceptations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` lettreAcceptations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned lettreAcceptations
    **/
    _count?: true | LettreAcceptationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LettreAcceptationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LettreAcceptationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LettreAcceptationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LettreAcceptationMaxAggregateInputType
  }

  export type GetLettreAcceptationAggregateType<T extends LettreAcceptationAggregateArgs> = {
        [P in keyof T & keyof AggregateLettreAcceptation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLettreAcceptation[P]>
      : GetScalarType<T[P], AggregateLettreAcceptation[P]>
  }




  export type lettreAcceptationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: lettreAcceptationWhereInput
    orderBy?: lettreAcceptationOrderByWithAggregationInput | lettreAcceptationOrderByWithAggregationInput[]
    by: LettreAcceptationScalarFieldEnum[] | LettreAcceptationScalarFieldEnum
    having?: lettreAcceptationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LettreAcceptationCountAggregateInputType | true
    _avg?: LettreAcceptationAvgAggregateInputType
    _sum?: LettreAcceptationSumAggregateInputType
    _min?: LettreAcceptationMinAggregateInputType
    _max?: LettreAcceptationMaxAggregateInputType
  }

  export type LettreAcceptationGroupByOutputType = {
    IDLETTRE: number
    IDDOSSIER: number
    COMMENTAIRE: string
    FICHIER: string
    DATEUPLOAD: Date
    EMAILSENT: boolean
    _count: LettreAcceptationCountAggregateOutputType | null
    _avg: LettreAcceptationAvgAggregateOutputType | null
    _sum: LettreAcceptationSumAggregateOutputType | null
    _min: LettreAcceptationMinAggregateOutputType | null
    _max: LettreAcceptationMaxAggregateOutputType | null
  }

  type GetLettreAcceptationGroupByPayload<T extends lettreAcceptationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LettreAcceptationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LettreAcceptationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LettreAcceptationGroupByOutputType[P]>
            : GetScalarType<T[P], LettreAcceptationGroupByOutputType[P]>
        }
      >
    >


  export type lettreAcceptationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    IDLETTRE?: boolean
    IDDOSSIER?: boolean
    COMMENTAIRE?: boolean
    FICHIER?: boolean
    DATEUPLOAD?: boolean
    EMAILSENT?: boolean
    dossier?: boolean | dossierDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lettreAcceptation"]>


  export type lettreAcceptationSelectScalar = {
    IDLETTRE?: boolean
    IDDOSSIER?: boolean
    COMMENTAIRE?: boolean
    FICHIER?: boolean
    DATEUPLOAD?: boolean
    EMAILSENT?: boolean
  }

  export type lettreAcceptationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    dossier?: boolean | dossierDefaultArgs<ExtArgs>
  }

  export type $lettreAcceptationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "lettreAcceptation"
    objects: {
      dossier: Prisma.$dossierPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      IDLETTRE: number
      IDDOSSIER: number
      COMMENTAIRE: string
      FICHIER: string
      DATEUPLOAD: Date
      EMAILSENT: boolean
    }, ExtArgs["result"]["lettreAcceptation"]>
    composites: {}
  }

  type lettreAcceptationGetPayload<S extends boolean | null | undefined | lettreAcceptationDefaultArgs> = $Result.GetResult<Prisma.$lettreAcceptationPayload, S>

  type lettreAcceptationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<lettreAcceptationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LettreAcceptationCountAggregateInputType | true
    }

  export interface lettreAcceptationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['lettreAcceptation'], meta: { name: 'lettreAcceptation' } }
    /**
     * Find zero or one LettreAcceptation that matches the filter.
     * @param {lettreAcceptationFindUniqueArgs} args - Arguments to find a LettreAcceptation
     * @example
     * // Get one LettreAcceptation
     * const lettreAcceptation = await prisma.lettreAcceptation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends lettreAcceptationFindUniqueArgs>(args: SelectSubset<T, lettreAcceptationFindUniqueArgs<ExtArgs>>): Prisma__lettreAcceptationClient<$Result.GetResult<Prisma.$lettreAcceptationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one LettreAcceptation that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {lettreAcceptationFindUniqueOrThrowArgs} args - Arguments to find a LettreAcceptation
     * @example
     * // Get one LettreAcceptation
     * const lettreAcceptation = await prisma.lettreAcceptation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends lettreAcceptationFindUniqueOrThrowArgs>(args: SelectSubset<T, lettreAcceptationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__lettreAcceptationClient<$Result.GetResult<Prisma.$lettreAcceptationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first LettreAcceptation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lettreAcceptationFindFirstArgs} args - Arguments to find a LettreAcceptation
     * @example
     * // Get one LettreAcceptation
     * const lettreAcceptation = await prisma.lettreAcceptation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends lettreAcceptationFindFirstArgs>(args?: SelectSubset<T, lettreAcceptationFindFirstArgs<ExtArgs>>): Prisma__lettreAcceptationClient<$Result.GetResult<Prisma.$lettreAcceptationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first LettreAcceptation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lettreAcceptationFindFirstOrThrowArgs} args - Arguments to find a LettreAcceptation
     * @example
     * // Get one LettreAcceptation
     * const lettreAcceptation = await prisma.lettreAcceptation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends lettreAcceptationFindFirstOrThrowArgs>(args?: SelectSubset<T, lettreAcceptationFindFirstOrThrowArgs<ExtArgs>>): Prisma__lettreAcceptationClient<$Result.GetResult<Prisma.$lettreAcceptationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more LettreAcceptations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lettreAcceptationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LettreAcceptations
     * const lettreAcceptations = await prisma.lettreAcceptation.findMany()
     * 
     * // Get first 10 LettreAcceptations
     * const lettreAcceptations = await prisma.lettreAcceptation.findMany({ take: 10 })
     * 
     * // Only select the `IDLETTRE`
     * const lettreAcceptationWithIDLETTREOnly = await prisma.lettreAcceptation.findMany({ select: { IDLETTRE: true } })
     * 
     */
    findMany<T extends lettreAcceptationFindManyArgs>(args?: SelectSubset<T, lettreAcceptationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$lettreAcceptationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a LettreAcceptation.
     * @param {lettreAcceptationCreateArgs} args - Arguments to create a LettreAcceptation.
     * @example
     * // Create one LettreAcceptation
     * const LettreAcceptation = await prisma.lettreAcceptation.create({
     *   data: {
     *     // ... data to create a LettreAcceptation
     *   }
     * })
     * 
     */
    create<T extends lettreAcceptationCreateArgs>(args: SelectSubset<T, lettreAcceptationCreateArgs<ExtArgs>>): Prisma__lettreAcceptationClient<$Result.GetResult<Prisma.$lettreAcceptationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many LettreAcceptations.
     * @param {lettreAcceptationCreateManyArgs} args - Arguments to create many LettreAcceptations.
     * @example
     * // Create many LettreAcceptations
     * const lettreAcceptation = await prisma.lettreAcceptation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends lettreAcceptationCreateManyArgs>(args?: SelectSubset<T, lettreAcceptationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a LettreAcceptation.
     * @param {lettreAcceptationDeleteArgs} args - Arguments to delete one LettreAcceptation.
     * @example
     * // Delete one LettreAcceptation
     * const LettreAcceptation = await prisma.lettreAcceptation.delete({
     *   where: {
     *     // ... filter to delete one LettreAcceptation
     *   }
     * })
     * 
     */
    delete<T extends lettreAcceptationDeleteArgs>(args: SelectSubset<T, lettreAcceptationDeleteArgs<ExtArgs>>): Prisma__lettreAcceptationClient<$Result.GetResult<Prisma.$lettreAcceptationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one LettreAcceptation.
     * @param {lettreAcceptationUpdateArgs} args - Arguments to update one LettreAcceptation.
     * @example
     * // Update one LettreAcceptation
     * const lettreAcceptation = await prisma.lettreAcceptation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends lettreAcceptationUpdateArgs>(args: SelectSubset<T, lettreAcceptationUpdateArgs<ExtArgs>>): Prisma__lettreAcceptationClient<$Result.GetResult<Prisma.$lettreAcceptationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more LettreAcceptations.
     * @param {lettreAcceptationDeleteManyArgs} args - Arguments to filter LettreAcceptations to delete.
     * @example
     * // Delete a few LettreAcceptations
     * const { count } = await prisma.lettreAcceptation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends lettreAcceptationDeleteManyArgs>(args?: SelectSubset<T, lettreAcceptationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LettreAcceptations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lettreAcceptationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LettreAcceptations
     * const lettreAcceptation = await prisma.lettreAcceptation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends lettreAcceptationUpdateManyArgs>(args: SelectSubset<T, lettreAcceptationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LettreAcceptation.
     * @param {lettreAcceptationUpsertArgs} args - Arguments to update or create a LettreAcceptation.
     * @example
     * // Update or create a LettreAcceptation
     * const lettreAcceptation = await prisma.lettreAcceptation.upsert({
     *   create: {
     *     // ... data to create a LettreAcceptation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LettreAcceptation we want to update
     *   }
     * })
     */
    upsert<T extends lettreAcceptationUpsertArgs>(args: SelectSubset<T, lettreAcceptationUpsertArgs<ExtArgs>>): Prisma__lettreAcceptationClient<$Result.GetResult<Prisma.$lettreAcceptationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of LettreAcceptations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lettreAcceptationCountArgs} args - Arguments to filter LettreAcceptations to count.
     * @example
     * // Count the number of LettreAcceptations
     * const count = await prisma.lettreAcceptation.count({
     *   where: {
     *     // ... the filter for the LettreAcceptations we want to count
     *   }
     * })
    **/
    count<T extends lettreAcceptationCountArgs>(
      args?: Subset<T, lettreAcceptationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LettreAcceptationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LettreAcceptation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LettreAcceptationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LettreAcceptationAggregateArgs>(args: Subset<T, LettreAcceptationAggregateArgs>): Prisma.PrismaPromise<GetLettreAcceptationAggregateType<T>>

    /**
     * Group by LettreAcceptation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {lettreAcceptationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends lettreAcceptationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: lettreAcceptationGroupByArgs['orderBy'] }
        : { orderBy?: lettreAcceptationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, lettreAcceptationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLettreAcceptationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the lettreAcceptation model
   */
  readonly fields: lettreAcceptationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for lettreAcceptation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__lettreAcceptationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    dossier<T extends dossierDefaultArgs<ExtArgs> = {}>(args?: Subset<T, dossierDefaultArgs<ExtArgs>>): Prisma__dossierClient<$Result.GetResult<Prisma.$dossierPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the lettreAcceptation model
   */ 
  interface lettreAcceptationFieldRefs {
    readonly IDLETTRE: FieldRef<"lettreAcceptation", 'Int'>
    readonly IDDOSSIER: FieldRef<"lettreAcceptation", 'Int'>
    readonly COMMENTAIRE: FieldRef<"lettreAcceptation", 'String'>
    readonly FICHIER: FieldRef<"lettreAcceptation", 'String'>
    readonly DATEUPLOAD: FieldRef<"lettreAcceptation", 'DateTime'>
    readonly EMAILSENT: FieldRef<"lettreAcceptation", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * lettreAcceptation findUnique
   */
  export type lettreAcceptationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lettreAcceptation
     */
    select?: lettreAcceptationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: lettreAcceptationInclude<ExtArgs> | null
    /**
     * Filter, which lettreAcceptation to fetch.
     */
    where: lettreAcceptationWhereUniqueInput
  }

  /**
   * lettreAcceptation findUniqueOrThrow
   */
  export type lettreAcceptationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lettreAcceptation
     */
    select?: lettreAcceptationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: lettreAcceptationInclude<ExtArgs> | null
    /**
     * Filter, which lettreAcceptation to fetch.
     */
    where: lettreAcceptationWhereUniqueInput
  }

  /**
   * lettreAcceptation findFirst
   */
  export type lettreAcceptationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lettreAcceptation
     */
    select?: lettreAcceptationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: lettreAcceptationInclude<ExtArgs> | null
    /**
     * Filter, which lettreAcceptation to fetch.
     */
    where?: lettreAcceptationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of lettreAcceptations to fetch.
     */
    orderBy?: lettreAcceptationOrderByWithRelationInput | lettreAcceptationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for lettreAcceptations.
     */
    cursor?: lettreAcceptationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` lettreAcceptations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` lettreAcceptations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of lettreAcceptations.
     */
    distinct?: LettreAcceptationScalarFieldEnum | LettreAcceptationScalarFieldEnum[]
  }

  /**
   * lettreAcceptation findFirstOrThrow
   */
  export type lettreAcceptationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lettreAcceptation
     */
    select?: lettreAcceptationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: lettreAcceptationInclude<ExtArgs> | null
    /**
     * Filter, which lettreAcceptation to fetch.
     */
    where?: lettreAcceptationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of lettreAcceptations to fetch.
     */
    orderBy?: lettreAcceptationOrderByWithRelationInput | lettreAcceptationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for lettreAcceptations.
     */
    cursor?: lettreAcceptationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` lettreAcceptations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` lettreAcceptations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of lettreAcceptations.
     */
    distinct?: LettreAcceptationScalarFieldEnum | LettreAcceptationScalarFieldEnum[]
  }

  /**
   * lettreAcceptation findMany
   */
  export type lettreAcceptationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lettreAcceptation
     */
    select?: lettreAcceptationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: lettreAcceptationInclude<ExtArgs> | null
    /**
     * Filter, which lettreAcceptations to fetch.
     */
    where?: lettreAcceptationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of lettreAcceptations to fetch.
     */
    orderBy?: lettreAcceptationOrderByWithRelationInput | lettreAcceptationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing lettreAcceptations.
     */
    cursor?: lettreAcceptationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` lettreAcceptations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` lettreAcceptations.
     */
    skip?: number
    distinct?: LettreAcceptationScalarFieldEnum | LettreAcceptationScalarFieldEnum[]
  }

  /**
   * lettreAcceptation create
   */
  export type lettreAcceptationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lettreAcceptation
     */
    select?: lettreAcceptationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: lettreAcceptationInclude<ExtArgs> | null
    /**
     * The data needed to create a lettreAcceptation.
     */
    data: XOR<lettreAcceptationCreateInput, lettreAcceptationUncheckedCreateInput>
  }

  /**
   * lettreAcceptation createMany
   */
  export type lettreAcceptationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many lettreAcceptations.
     */
    data: lettreAcceptationCreateManyInput | lettreAcceptationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * lettreAcceptation update
   */
  export type lettreAcceptationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lettreAcceptation
     */
    select?: lettreAcceptationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: lettreAcceptationInclude<ExtArgs> | null
    /**
     * The data needed to update a lettreAcceptation.
     */
    data: XOR<lettreAcceptationUpdateInput, lettreAcceptationUncheckedUpdateInput>
    /**
     * Choose, which lettreAcceptation to update.
     */
    where: lettreAcceptationWhereUniqueInput
  }

  /**
   * lettreAcceptation updateMany
   */
  export type lettreAcceptationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update lettreAcceptations.
     */
    data: XOR<lettreAcceptationUpdateManyMutationInput, lettreAcceptationUncheckedUpdateManyInput>
    /**
     * Filter which lettreAcceptations to update
     */
    where?: lettreAcceptationWhereInput
  }

  /**
   * lettreAcceptation upsert
   */
  export type lettreAcceptationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lettreAcceptation
     */
    select?: lettreAcceptationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: lettreAcceptationInclude<ExtArgs> | null
    /**
     * The filter to search for the lettreAcceptation to update in case it exists.
     */
    where: lettreAcceptationWhereUniqueInput
    /**
     * In case the lettreAcceptation found by the `where` argument doesn't exist, create a new lettreAcceptation with this data.
     */
    create: XOR<lettreAcceptationCreateInput, lettreAcceptationUncheckedCreateInput>
    /**
     * In case the lettreAcceptation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<lettreAcceptationUpdateInput, lettreAcceptationUncheckedUpdateInput>
  }

  /**
   * lettreAcceptation delete
   */
  export type lettreAcceptationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lettreAcceptation
     */
    select?: lettreAcceptationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: lettreAcceptationInclude<ExtArgs> | null
    /**
     * Filter which lettreAcceptation to delete.
     */
    where: lettreAcceptationWhereUniqueInput
  }

  /**
   * lettreAcceptation deleteMany
   */
  export type lettreAcceptationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which lettreAcceptations to delete
     */
    where?: lettreAcceptationWhereInput
  }

  /**
   * lettreAcceptation without action
   */
  export type lettreAcceptationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the lettreAcceptation
     */
    select?: lettreAcceptationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: lettreAcceptationInclude<ExtArgs> | null
  }


  /**
   * Model structures
   */

  export type AggregateStructures = {
    _count: StructuresCountAggregateOutputType | null
    _avg: StructuresAvgAggregateOutputType | null
    _sum: StructuresSumAggregateOutputType | null
    _min: StructuresMinAggregateOutputType | null
    _max: StructuresMaxAggregateOutputType | null
  }

  export type StructuresAvgAggregateOutputType = {
    IDSTRUCTURE: number | null
    IDPARENT: number | null
  }

  export type StructuresSumAggregateOutputType = {
    IDSTRUCTURE: number | null
    IDPARENT: number | null
  }

  export type StructuresMinAggregateOutputType = {
    IDSTRUCTURE: number | null
    NOMSTRUCTURE: string | null
    ABBREVIATION: string | null
    IDPARENT: number | null
  }

  export type StructuresMaxAggregateOutputType = {
    IDSTRUCTURE: number | null
    NOMSTRUCTURE: string | null
    ABBREVIATION: string | null
    IDPARENT: number | null
  }

  export type StructuresCountAggregateOutputType = {
    IDSTRUCTURE: number
    NOMSTRUCTURE: number
    ABBREVIATION: number
    IDPARENT: number
    _all: number
  }


  export type StructuresAvgAggregateInputType = {
    IDSTRUCTURE?: true
    IDPARENT?: true
  }

  export type StructuresSumAggregateInputType = {
    IDSTRUCTURE?: true
    IDPARENT?: true
  }

  export type StructuresMinAggregateInputType = {
    IDSTRUCTURE?: true
    NOMSTRUCTURE?: true
    ABBREVIATION?: true
    IDPARENT?: true
  }

  export type StructuresMaxAggregateInputType = {
    IDSTRUCTURE?: true
    NOMSTRUCTURE?: true
    ABBREVIATION?: true
    IDPARENT?: true
  }

  export type StructuresCountAggregateInputType = {
    IDSTRUCTURE?: true
    NOMSTRUCTURE?: true
    ABBREVIATION?: true
    IDPARENT?: true
    _all?: true
  }

  export type StructuresAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which structures to aggregate.
     */
    where?: structuresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of structures to fetch.
     */
    orderBy?: structuresOrderByWithRelationInput | structuresOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: structuresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` structures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` structures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned structures
    **/
    _count?: true | StructuresCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StructuresAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StructuresSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StructuresMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StructuresMaxAggregateInputType
  }

  export type GetStructuresAggregateType<T extends StructuresAggregateArgs> = {
        [P in keyof T & keyof AggregateStructures]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStructures[P]>
      : GetScalarType<T[P], AggregateStructures[P]>
  }




  export type structuresGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: structuresWhereInput
    orderBy?: structuresOrderByWithAggregationInput | structuresOrderByWithAggregationInput[]
    by: StructuresScalarFieldEnum[] | StructuresScalarFieldEnum
    having?: structuresScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StructuresCountAggregateInputType | true
    _avg?: StructuresAvgAggregateInputType
    _sum?: StructuresSumAggregateInputType
    _min?: StructuresMinAggregateInputType
    _max?: StructuresMaxAggregateInputType
  }

  export type StructuresGroupByOutputType = {
    IDSTRUCTURE: number
    NOMSTRUCTURE: string
    ABBREVIATION: string
    IDPARENT: number | null
    _count: StructuresCountAggregateOutputType | null
    _avg: StructuresAvgAggregateOutputType | null
    _sum: StructuresSumAggregateOutputType | null
    _min: StructuresMinAggregateOutputType | null
    _max: StructuresMaxAggregateOutputType | null
  }

  type GetStructuresGroupByPayload<T extends structuresGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StructuresGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StructuresGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StructuresGroupByOutputType[P]>
            : GetScalarType<T[P], StructuresGroupByOutputType[P]>
        }
      >
    >


  export type structuresSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    IDSTRUCTURE?: boolean
    NOMSTRUCTURE?: boolean
    ABBREVIATION?: boolean
    IDPARENT?: boolean
    affectation?: boolean | structures$affectationArgs<ExtArgs>
    encadreur?: boolean | structures$encadreurArgs<ExtArgs>
    structures?: boolean | structures$structuresArgs<ExtArgs>
    other_structures?: boolean | structures$other_structuresArgs<ExtArgs>
    _count?: boolean | StructuresCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["structures"]>


  export type structuresSelectScalar = {
    IDSTRUCTURE?: boolean
    NOMSTRUCTURE?: boolean
    ABBREVIATION?: boolean
    IDPARENT?: boolean
  }

  export type structuresInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    affectation?: boolean | structures$affectationArgs<ExtArgs>
    encadreur?: boolean | structures$encadreurArgs<ExtArgs>
    structures?: boolean | structures$structuresArgs<ExtArgs>
    other_structures?: boolean | structures$other_structuresArgs<ExtArgs>
    _count?: boolean | StructuresCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $structuresPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "structures"
    objects: {
      affectation: Prisma.$affectationPayload<ExtArgs>[]
      encadreur: Prisma.$encadreurPayload<ExtArgs>[]
      structures: Prisma.$structuresPayload<ExtArgs> | null
      other_structures: Prisma.$structuresPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      IDSTRUCTURE: number
      NOMSTRUCTURE: string
      ABBREVIATION: string
      IDPARENT: number | null
    }, ExtArgs["result"]["structures"]>
    composites: {}
  }

  type structuresGetPayload<S extends boolean | null | undefined | structuresDefaultArgs> = $Result.GetResult<Prisma.$structuresPayload, S>

  type structuresCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<structuresFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StructuresCountAggregateInputType | true
    }

  export interface structuresDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['structures'], meta: { name: 'structures' } }
    /**
     * Find zero or one Structures that matches the filter.
     * @param {structuresFindUniqueArgs} args - Arguments to find a Structures
     * @example
     * // Get one Structures
     * const structures = await prisma.structures.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends structuresFindUniqueArgs>(args: SelectSubset<T, structuresFindUniqueArgs<ExtArgs>>): Prisma__structuresClient<$Result.GetResult<Prisma.$structuresPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Structures that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {structuresFindUniqueOrThrowArgs} args - Arguments to find a Structures
     * @example
     * // Get one Structures
     * const structures = await prisma.structures.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends structuresFindUniqueOrThrowArgs>(args: SelectSubset<T, structuresFindUniqueOrThrowArgs<ExtArgs>>): Prisma__structuresClient<$Result.GetResult<Prisma.$structuresPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Structures that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {structuresFindFirstArgs} args - Arguments to find a Structures
     * @example
     * // Get one Structures
     * const structures = await prisma.structures.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends structuresFindFirstArgs>(args?: SelectSubset<T, structuresFindFirstArgs<ExtArgs>>): Prisma__structuresClient<$Result.GetResult<Prisma.$structuresPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Structures that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {structuresFindFirstOrThrowArgs} args - Arguments to find a Structures
     * @example
     * // Get one Structures
     * const structures = await prisma.structures.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends structuresFindFirstOrThrowArgs>(args?: SelectSubset<T, structuresFindFirstOrThrowArgs<ExtArgs>>): Prisma__structuresClient<$Result.GetResult<Prisma.$structuresPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Structures that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {structuresFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Structures
     * const structures = await prisma.structures.findMany()
     * 
     * // Get first 10 Structures
     * const structures = await prisma.structures.findMany({ take: 10 })
     * 
     * // Only select the `IDSTRUCTURE`
     * const structuresWithIDSTRUCTUREOnly = await prisma.structures.findMany({ select: { IDSTRUCTURE: true } })
     * 
     */
    findMany<T extends structuresFindManyArgs>(args?: SelectSubset<T, structuresFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$structuresPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Structures.
     * @param {structuresCreateArgs} args - Arguments to create a Structures.
     * @example
     * // Create one Structures
     * const Structures = await prisma.structures.create({
     *   data: {
     *     // ... data to create a Structures
     *   }
     * })
     * 
     */
    create<T extends structuresCreateArgs>(args: SelectSubset<T, structuresCreateArgs<ExtArgs>>): Prisma__structuresClient<$Result.GetResult<Prisma.$structuresPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Structures.
     * @param {structuresCreateManyArgs} args - Arguments to create many Structures.
     * @example
     * // Create many Structures
     * const structures = await prisma.structures.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends structuresCreateManyArgs>(args?: SelectSubset<T, structuresCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Structures.
     * @param {structuresDeleteArgs} args - Arguments to delete one Structures.
     * @example
     * // Delete one Structures
     * const Structures = await prisma.structures.delete({
     *   where: {
     *     // ... filter to delete one Structures
     *   }
     * })
     * 
     */
    delete<T extends structuresDeleteArgs>(args: SelectSubset<T, structuresDeleteArgs<ExtArgs>>): Prisma__structuresClient<$Result.GetResult<Prisma.$structuresPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Structures.
     * @param {structuresUpdateArgs} args - Arguments to update one Structures.
     * @example
     * // Update one Structures
     * const structures = await prisma.structures.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends structuresUpdateArgs>(args: SelectSubset<T, structuresUpdateArgs<ExtArgs>>): Prisma__structuresClient<$Result.GetResult<Prisma.$structuresPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Structures.
     * @param {structuresDeleteManyArgs} args - Arguments to filter Structures to delete.
     * @example
     * // Delete a few Structures
     * const { count } = await prisma.structures.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends structuresDeleteManyArgs>(args?: SelectSubset<T, structuresDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Structures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {structuresUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Structures
     * const structures = await prisma.structures.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends structuresUpdateManyArgs>(args: SelectSubset<T, structuresUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Structures.
     * @param {structuresUpsertArgs} args - Arguments to update or create a Structures.
     * @example
     * // Update or create a Structures
     * const structures = await prisma.structures.upsert({
     *   create: {
     *     // ... data to create a Structures
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Structures we want to update
     *   }
     * })
     */
    upsert<T extends structuresUpsertArgs>(args: SelectSubset<T, structuresUpsertArgs<ExtArgs>>): Prisma__structuresClient<$Result.GetResult<Prisma.$structuresPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Structures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {structuresCountArgs} args - Arguments to filter Structures to count.
     * @example
     * // Count the number of Structures
     * const count = await prisma.structures.count({
     *   where: {
     *     // ... the filter for the Structures we want to count
     *   }
     * })
    **/
    count<T extends structuresCountArgs>(
      args?: Subset<T, structuresCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StructuresCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Structures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StructuresAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StructuresAggregateArgs>(args: Subset<T, StructuresAggregateArgs>): Prisma.PrismaPromise<GetStructuresAggregateType<T>>

    /**
     * Group by Structures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {structuresGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends structuresGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: structuresGroupByArgs['orderBy'] }
        : { orderBy?: structuresGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, structuresGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStructuresGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the structures model
   */
  readonly fields: structuresFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for structures.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__structuresClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    affectation<T extends structures$affectationArgs<ExtArgs> = {}>(args?: Subset<T, structures$affectationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$affectationPayload<ExtArgs>, T, "findMany"> | Null>
    encadreur<T extends structures$encadreurArgs<ExtArgs> = {}>(args?: Subset<T, structures$encadreurArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$encadreurPayload<ExtArgs>, T, "findMany"> | Null>
    structures<T extends structures$structuresArgs<ExtArgs> = {}>(args?: Subset<T, structures$structuresArgs<ExtArgs>>): Prisma__structuresClient<$Result.GetResult<Prisma.$structuresPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    other_structures<T extends structures$other_structuresArgs<ExtArgs> = {}>(args?: Subset<T, structures$other_structuresArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$structuresPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the structures model
   */ 
  interface structuresFieldRefs {
    readonly IDSTRUCTURE: FieldRef<"structures", 'Int'>
    readonly NOMSTRUCTURE: FieldRef<"structures", 'String'>
    readonly ABBREVIATION: FieldRef<"structures", 'String'>
    readonly IDPARENT: FieldRef<"structures", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * structures findUnique
   */
  export type structuresFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the structures
     */
    select?: structuresSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: structuresInclude<ExtArgs> | null
    /**
     * Filter, which structures to fetch.
     */
    where: structuresWhereUniqueInput
  }

  /**
   * structures findUniqueOrThrow
   */
  export type structuresFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the structures
     */
    select?: structuresSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: structuresInclude<ExtArgs> | null
    /**
     * Filter, which structures to fetch.
     */
    where: structuresWhereUniqueInput
  }

  /**
   * structures findFirst
   */
  export type structuresFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the structures
     */
    select?: structuresSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: structuresInclude<ExtArgs> | null
    /**
     * Filter, which structures to fetch.
     */
    where?: structuresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of structures to fetch.
     */
    orderBy?: structuresOrderByWithRelationInput | structuresOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for structures.
     */
    cursor?: structuresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` structures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` structures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of structures.
     */
    distinct?: StructuresScalarFieldEnum | StructuresScalarFieldEnum[]
  }

  /**
   * structures findFirstOrThrow
   */
  export type structuresFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the structures
     */
    select?: structuresSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: structuresInclude<ExtArgs> | null
    /**
     * Filter, which structures to fetch.
     */
    where?: structuresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of structures to fetch.
     */
    orderBy?: structuresOrderByWithRelationInput | structuresOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for structures.
     */
    cursor?: structuresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` structures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` structures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of structures.
     */
    distinct?: StructuresScalarFieldEnum | StructuresScalarFieldEnum[]
  }

  /**
   * structures findMany
   */
  export type structuresFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the structures
     */
    select?: structuresSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: structuresInclude<ExtArgs> | null
    /**
     * Filter, which structures to fetch.
     */
    where?: structuresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of structures to fetch.
     */
    orderBy?: structuresOrderByWithRelationInput | structuresOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing structures.
     */
    cursor?: structuresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` structures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` structures.
     */
    skip?: number
    distinct?: StructuresScalarFieldEnum | StructuresScalarFieldEnum[]
  }

  /**
   * structures create
   */
  export type structuresCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the structures
     */
    select?: structuresSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: structuresInclude<ExtArgs> | null
    /**
     * The data needed to create a structures.
     */
    data: XOR<structuresCreateInput, structuresUncheckedCreateInput>
  }

  /**
   * structures createMany
   */
  export type structuresCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many structures.
     */
    data: structuresCreateManyInput | structuresCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * structures update
   */
  export type structuresUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the structures
     */
    select?: structuresSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: structuresInclude<ExtArgs> | null
    /**
     * The data needed to update a structures.
     */
    data: XOR<structuresUpdateInput, structuresUncheckedUpdateInput>
    /**
     * Choose, which structures to update.
     */
    where: structuresWhereUniqueInput
  }

  /**
   * structures updateMany
   */
  export type structuresUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update structures.
     */
    data: XOR<structuresUpdateManyMutationInput, structuresUncheckedUpdateManyInput>
    /**
     * Filter which structures to update
     */
    where?: structuresWhereInput
  }

  /**
   * structures upsert
   */
  export type structuresUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the structures
     */
    select?: structuresSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: structuresInclude<ExtArgs> | null
    /**
     * The filter to search for the structures to update in case it exists.
     */
    where: structuresWhereUniqueInput
    /**
     * In case the structures found by the `where` argument doesn't exist, create a new structures with this data.
     */
    create: XOR<structuresCreateInput, structuresUncheckedCreateInput>
    /**
     * In case the structures was found with the provided `where` argument, update it with this data.
     */
    update: XOR<structuresUpdateInput, structuresUncheckedUpdateInput>
  }

  /**
   * structures delete
   */
  export type structuresDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the structures
     */
    select?: structuresSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: structuresInclude<ExtArgs> | null
    /**
     * Filter which structures to delete.
     */
    where: structuresWhereUniqueInput
  }

  /**
   * structures deleteMany
   */
  export type structuresDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which structures to delete
     */
    where?: structuresWhereInput
  }

  /**
   * structures.affectation
   */
  export type structures$affectationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the affectation
     */
    select?: affectationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: affectationInclude<ExtArgs> | null
    where?: affectationWhereInput
    orderBy?: affectationOrderByWithRelationInput | affectationOrderByWithRelationInput[]
    cursor?: affectationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AffectationScalarFieldEnum | AffectationScalarFieldEnum[]
  }

  /**
   * structures.encadreur
   */
  export type structures$encadreurArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the encadreur
     */
    select?: encadreurSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: encadreurInclude<ExtArgs> | null
    where?: encadreurWhereInput
    orderBy?: encadreurOrderByWithRelationInput | encadreurOrderByWithRelationInput[]
    cursor?: encadreurWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EncadreurScalarFieldEnum | EncadreurScalarFieldEnum[]
  }

  /**
   * structures.structures
   */
  export type structures$structuresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the structures
     */
    select?: structuresSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: structuresInclude<ExtArgs> | null
    where?: structuresWhereInput
  }

  /**
   * structures.other_structures
   */
  export type structures$other_structuresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the structures
     */
    select?: structuresSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: structuresInclude<ExtArgs> | null
    where?: structuresWhereInput
    orderBy?: structuresOrderByWithRelationInput | structuresOrderByWithRelationInput[]
    cursor?: structuresWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StructuresScalarFieldEnum | StructuresScalarFieldEnum[]
  }

  /**
   * structures without action
   */
  export type structuresDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the structures
     */
    select?: structuresSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: structuresInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const AdministrateurScalarFieldEnum: {
    IDADMIN: 'IDADMIN',
    MATRICULEADMIN: 'MATRICULEADMIN',
    NOMADMIN: 'NOMADMIN',
    PRENOMADMIN: 'PRENOMADMIN',
    EMAILADMIN: 'EMAILADMIN',
    PASSWARDADMIN: 'PASSWARDADMIN',
    PHOTOADMIN: 'PHOTOADMIN'
  };

  export type AdministrateurScalarFieldEnum = (typeof AdministrateurScalarFieldEnum)[keyof typeof AdministrateurScalarFieldEnum]


  export const AffectationScalarFieldEnum: {
    IDADMIN: 'IDADMIN',
    IDENCADREUR: 'IDENCADREUR',
    IDDOSSIER: 'IDDOSSIER',
    IDSTRUCTURE: 'IDSTRUCTURE'
  };

  export type AffectationScalarFieldEnum = (typeof AffectationScalarFieldEnum)[keyof typeof AffectationScalarFieldEnum]


  export const DossierScalarFieldEnum: {
    IDDOSSIER: 'IDDOSSIER',
    MATRICULEETUDIANT: 'MATRICULEETUDIANT',
    DATEDEBUTDESEANCE: 'DATEDEBUTDESEANCE',
    DATEFINDESEANCE: 'DATEFINDESEANCE',
    ETAT: 'ETAT',
    THEME: 'THEME',
    CNI: 'CNI',
    CERTIFICAT: 'CERTIFICAT',
    LETTREMOTIVATION: 'LETTREMOTIVATION',
    LETTRERECOMMENDATION: 'LETTRERECOMMENDATION',
    PHOTOPROFIL: 'PHOTOPROFIL',
    CV: 'CV',
    CAHIERDECHARGE: 'CAHIERDECHARGE',
    DATEDEPOT: 'DATEDEPOT',
    EMAILSENT: 'EMAILSENT'
  };

  export type DossierScalarFieldEnum = (typeof DossierScalarFieldEnum)[keyof typeof DossierScalarFieldEnum]


  export const EncadreurScalarFieldEnum: {
    IDENCADREUR: 'IDENCADREUR',
    MATRICULEENCADREUR: 'MATRICULEENCADREUR',
    NOMENCADREUR: 'NOMENCADREUR',
    PRENOMENCADREUR: 'PRENOMENCADREUR',
    IDSTRUCTURE: 'IDSTRUCTURE',
    POSTE: 'POSTE'
  };

  export type EncadreurScalarFieldEnum = (typeof EncadreurScalarFieldEnum)[keyof typeof EncadreurScalarFieldEnum]


  export const EtudiantScalarFieldEnum: {
    MATRICULEETUDIANT: 'MATRICULEETUDIANT',
    NOMETUDIANT: 'NOMETUDIANT',
    PRENOMETUDIANT: 'PRENOMETUDIANT',
    ETABLISSEMENT: 'ETABLISSEMENT',
    VILLERESIDENCE: 'VILLERESIDENCE',
    PARCOURS: 'PARCOURS',
    NIVEAU: 'NIVEAU',
    EMAIL: 'EMAIL',
    TEL: 'TEL',
    FILIERE: 'FILIERE',
    SEXE: 'SEXE',
    DATE: 'DATE'
  };

  export type EtudiantScalarFieldEnum = (typeof EtudiantScalarFieldEnum)[keyof typeof EtudiantScalarFieldEnum]


  export const Logs_actionsScalarFieldEnum: {
    id: 'id',
    user_email: 'user_email',
    user_name: 'user_name',
    action: 'action',
    methode_http: 'methode_http',
    endpoint: 'endpoint',
    requete_executee: 'requete_executee',
    ip_address: 'ip_address',
    user_agent: 'user_agent',
    status_code: 'status_code',
    horodatage: 'horodatage'
  };

  export type Logs_actionsScalarFieldEnum = (typeof Logs_actionsScalarFieldEnum)[keyof typeof Logs_actionsScalarFieldEnum]


  export const RapportScalarFieldEnum: {
    IDDOSSIER: 'IDDOSSIER',
    MATRICULE: 'MATRICULE',
    COMMENTAIRE: 'COMMENTAIRE',
    THEME: 'THEME',
    FICHIER: 'FICHIER',
    DATE: 'DATE'
  };

  export type RapportScalarFieldEnum = (typeof RapportScalarFieldEnum)[keyof typeof RapportScalarFieldEnum]


  export const LettreAcceptationScalarFieldEnum: {
    IDLETTRE: 'IDLETTRE',
    IDDOSSIER: 'IDDOSSIER',
    COMMENTAIRE: 'COMMENTAIRE',
    FICHIER: 'FICHIER',
    DATEUPLOAD: 'DATEUPLOAD',
    EMAILSENT: 'EMAILSENT'
  };

  export type LettreAcceptationScalarFieldEnum = (typeof LettreAcceptationScalarFieldEnum)[keyof typeof LettreAcceptationScalarFieldEnum]


  export const StructuresScalarFieldEnum: {
    IDSTRUCTURE: 'IDSTRUCTURE',
    NOMSTRUCTURE: 'NOMSTRUCTURE',
    ABBREVIATION: 'ABBREVIATION',
    IDPARENT: 'IDPARENT'
  };

  export type StructuresScalarFieldEnum = (typeof StructuresScalarFieldEnum)[keyof typeof StructuresScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const administrateurOrderByRelevanceFieldEnum: {
    MATRICULEADMIN: 'MATRICULEADMIN',
    NOMADMIN: 'NOMADMIN',
    PRENOMADMIN: 'PRENOMADMIN',
    EMAILADMIN: 'EMAILADMIN',
    PASSWARDADMIN: 'PASSWARDADMIN',
    PHOTOADMIN: 'PHOTOADMIN'
  };

  export type administrateurOrderByRelevanceFieldEnum = (typeof administrateurOrderByRelevanceFieldEnum)[keyof typeof administrateurOrderByRelevanceFieldEnum]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const dossierOrderByRelevanceFieldEnum: {
    MATRICULEETUDIANT: 'MATRICULEETUDIANT',
    ETAT: 'ETAT',
    THEME: 'THEME',
    CNI: 'CNI',
    CERTIFICAT: 'CERTIFICAT',
    LETTREMOTIVATION: 'LETTREMOTIVATION',
    LETTRERECOMMENDATION: 'LETTRERECOMMENDATION',
    PHOTOPROFIL: 'PHOTOPROFIL',
    CV: 'CV',
    CAHIERDECHARGE: 'CAHIERDECHARGE'
  };

  export type dossierOrderByRelevanceFieldEnum = (typeof dossierOrderByRelevanceFieldEnum)[keyof typeof dossierOrderByRelevanceFieldEnum]


  export const encadreurOrderByRelevanceFieldEnum: {
    MATRICULEENCADREUR: 'MATRICULEENCADREUR',
    NOMENCADREUR: 'NOMENCADREUR',
    PRENOMENCADREUR: 'PRENOMENCADREUR',
    POSTE: 'POSTE'
  };

  export type encadreurOrderByRelevanceFieldEnum = (typeof encadreurOrderByRelevanceFieldEnum)[keyof typeof encadreurOrderByRelevanceFieldEnum]


  export const etudiantOrderByRelevanceFieldEnum: {
    MATRICULEETUDIANT: 'MATRICULEETUDIANT',
    NOMETUDIANT: 'NOMETUDIANT',
    PRENOMETUDIANT: 'PRENOMETUDIANT',
    ETABLISSEMENT: 'ETABLISSEMENT',
    VILLERESIDENCE: 'VILLERESIDENCE',
    PARCOURS: 'PARCOURS',
    NIVEAU: 'NIVEAU',
    EMAIL: 'EMAIL',
    TEL: 'TEL',
    FILIERE: 'FILIERE',
    SEXE: 'SEXE'
  };

  export type etudiantOrderByRelevanceFieldEnum = (typeof etudiantOrderByRelevanceFieldEnum)[keyof typeof etudiantOrderByRelevanceFieldEnum]


  export const logs_actionsOrderByRelevanceFieldEnum: {
    user_email: 'user_email',
    user_name: 'user_name',
    action: 'action',
    methode_http: 'methode_http',
    endpoint: 'endpoint',
    requete_executee: 'requete_executee',
    ip_address: 'ip_address',
    user_agent: 'user_agent'
  };

  export type logs_actionsOrderByRelevanceFieldEnum = (typeof logs_actionsOrderByRelevanceFieldEnum)[keyof typeof logs_actionsOrderByRelevanceFieldEnum]


  export const rapportOrderByRelevanceFieldEnum: {
    MATRICULE: 'MATRICULE',
    COMMENTAIRE: 'COMMENTAIRE',
    THEME: 'THEME',
    FICHIER: 'FICHIER'
  };

  export type rapportOrderByRelevanceFieldEnum = (typeof rapportOrderByRelevanceFieldEnum)[keyof typeof rapportOrderByRelevanceFieldEnum]


  export const lettreAcceptationOrderByRelevanceFieldEnum: {
    COMMENTAIRE: 'COMMENTAIRE',
    FICHIER: 'FICHIER'
  };

  export type lettreAcceptationOrderByRelevanceFieldEnum = (typeof lettreAcceptationOrderByRelevanceFieldEnum)[keyof typeof lettreAcceptationOrderByRelevanceFieldEnum]


  export const structuresOrderByRelevanceFieldEnum: {
    NOMSTRUCTURE: 'NOMSTRUCTURE',
    ABBREVIATION: 'ABBREVIATION'
  };

  export type structuresOrderByRelevanceFieldEnum = (typeof structuresOrderByRelevanceFieldEnum)[keyof typeof structuresOrderByRelevanceFieldEnum]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type administrateurWhereInput = {
    AND?: administrateurWhereInput | administrateurWhereInput[]
    OR?: administrateurWhereInput[]
    NOT?: administrateurWhereInput | administrateurWhereInput[]
    IDADMIN?: IntFilter<"administrateur"> | number
    MATRICULEADMIN?: StringFilter<"administrateur"> | string
    NOMADMIN?: StringFilter<"administrateur"> | string
    PRENOMADMIN?: StringFilter<"administrateur"> | string
    EMAILADMIN?: StringFilter<"administrateur"> | string
    PASSWARDADMIN?: StringFilter<"administrateur"> | string
    PHOTOADMIN?: StringFilter<"administrateur"> | string
    affectation?: AffectationListRelationFilter
  }

  export type administrateurOrderByWithRelationInput = {
    IDADMIN?: SortOrder
    MATRICULEADMIN?: SortOrder
    NOMADMIN?: SortOrder
    PRENOMADMIN?: SortOrder
    EMAILADMIN?: SortOrder
    PASSWARDADMIN?: SortOrder
    PHOTOADMIN?: SortOrder
    affectation?: affectationOrderByRelationAggregateInput
    _relevance?: administrateurOrderByRelevanceInput
  }

  export type administrateurWhereUniqueInput = Prisma.AtLeast<{
    IDADMIN?: number
    MATRICULEADMIN?: string
    AND?: administrateurWhereInput | administrateurWhereInput[]
    OR?: administrateurWhereInput[]
    NOT?: administrateurWhereInput | administrateurWhereInput[]
    NOMADMIN?: StringFilter<"administrateur"> | string
    PRENOMADMIN?: StringFilter<"administrateur"> | string
    EMAILADMIN?: StringFilter<"administrateur"> | string
    PASSWARDADMIN?: StringFilter<"administrateur"> | string
    PHOTOADMIN?: StringFilter<"administrateur"> | string
    affectation?: AffectationListRelationFilter
  }, "IDADMIN" | "MATRICULEADMIN">

  export type administrateurOrderByWithAggregationInput = {
    IDADMIN?: SortOrder
    MATRICULEADMIN?: SortOrder
    NOMADMIN?: SortOrder
    PRENOMADMIN?: SortOrder
    EMAILADMIN?: SortOrder
    PASSWARDADMIN?: SortOrder
    PHOTOADMIN?: SortOrder
    _count?: administrateurCountOrderByAggregateInput
    _avg?: administrateurAvgOrderByAggregateInput
    _max?: administrateurMaxOrderByAggregateInput
    _min?: administrateurMinOrderByAggregateInput
    _sum?: administrateurSumOrderByAggregateInput
  }

  export type administrateurScalarWhereWithAggregatesInput = {
    AND?: administrateurScalarWhereWithAggregatesInput | administrateurScalarWhereWithAggregatesInput[]
    OR?: administrateurScalarWhereWithAggregatesInput[]
    NOT?: administrateurScalarWhereWithAggregatesInput | administrateurScalarWhereWithAggregatesInput[]
    IDADMIN?: IntWithAggregatesFilter<"administrateur"> | number
    MATRICULEADMIN?: StringWithAggregatesFilter<"administrateur"> | string
    NOMADMIN?: StringWithAggregatesFilter<"administrateur"> | string
    PRENOMADMIN?: StringWithAggregatesFilter<"administrateur"> | string
    EMAILADMIN?: StringWithAggregatesFilter<"administrateur"> | string
    PASSWARDADMIN?: StringWithAggregatesFilter<"administrateur"> | string
    PHOTOADMIN?: StringWithAggregatesFilter<"administrateur"> | string
  }

  export type affectationWhereInput = {
    AND?: affectationWhereInput | affectationWhereInput[]
    OR?: affectationWhereInput[]
    NOT?: affectationWhereInput | affectationWhereInput[]
    IDADMIN?: IntFilter<"affectation"> | number
    IDENCADREUR?: IntFilter<"affectation"> | number
    IDDOSSIER?: IntFilter<"affectation"> | number
    IDSTRUCTURE?: IntFilter<"affectation"> | number
    administrateur?: XOR<AdministrateurScalarRelationFilter, administrateurWhereInput>
    encadreur?: XOR<EncadreurScalarRelationFilter, encadreurWhereInput>
    dossier?: XOR<DossierScalarRelationFilter, dossierWhereInput>
    structures?: XOR<StructuresScalarRelationFilter, structuresWhereInput>
  }

  export type affectationOrderByWithRelationInput = {
    IDADMIN?: SortOrder
    IDENCADREUR?: SortOrder
    IDDOSSIER?: SortOrder
    IDSTRUCTURE?: SortOrder
    administrateur?: administrateurOrderByWithRelationInput
    encadreur?: encadreurOrderByWithRelationInput
    dossier?: dossierOrderByWithRelationInput
    structures?: structuresOrderByWithRelationInput
  }

  export type affectationWhereUniqueInput = Prisma.AtLeast<{
    IDADMIN_IDENCADREUR_IDDOSSIER_IDSTRUCTURE?: affectationIDADMINIDENCADREURIDDOSSIERIDSTRUCTURECompoundUniqueInput
    AND?: affectationWhereInput | affectationWhereInput[]
    OR?: affectationWhereInput[]
    NOT?: affectationWhereInput | affectationWhereInput[]
    IDADMIN?: IntFilter<"affectation"> | number
    IDENCADREUR?: IntFilter<"affectation"> | number
    IDDOSSIER?: IntFilter<"affectation"> | number
    IDSTRUCTURE?: IntFilter<"affectation"> | number
    administrateur?: XOR<AdministrateurScalarRelationFilter, administrateurWhereInput>
    encadreur?: XOR<EncadreurScalarRelationFilter, encadreurWhereInput>
    dossier?: XOR<DossierScalarRelationFilter, dossierWhereInput>
    structures?: XOR<StructuresScalarRelationFilter, structuresWhereInput>
  }, "IDADMIN_IDENCADREUR_IDDOSSIER_IDSTRUCTURE">

  export type affectationOrderByWithAggregationInput = {
    IDADMIN?: SortOrder
    IDENCADREUR?: SortOrder
    IDDOSSIER?: SortOrder
    IDSTRUCTURE?: SortOrder
    _count?: affectationCountOrderByAggregateInput
    _avg?: affectationAvgOrderByAggregateInput
    _max?: affectationMaxOrderByAggregateInput
    _min?: affectationMinOrderByAggregateInput
    _sum?: affectationSumOrderByAggregateInput
  }

  export type affectationScalarWhereWithAggregatesInput = {
    AND?: affectationScalarWhereWithAggregatesInput | affectationScalarWhereWithAggregatesInput[]
    OR?: affectationScalarWhereWithAggregatesInput[]
    NOT?: affectationScalarWhereWithAggregatesInput | affectationScalarWhereWithAggregatesInput[]
    IDADMIN?: IntWithAggregatesFilter<"affectation"> | number
    IDENCADREUR?: IntWithAggregatesFilter<"affectation"> | number
    IDDOSSIER?: IntWithAggregatesFilter<"affectation"> | number
    IDSTRUCTURE?: IntWithAggregatesFilter<"affectation"> | number
  }

  export type dossierWhereInput = {
    AND?: dossierWhereInput | dossierWhereInput[]
    OR?: dossierWhereInput[]
    NOT?: dossierWhereInput | dossierWhereInput[]
    IDDOSSIER?: IntFilter<"dossier"> | number
    MATRICULEETUDIANT?: StringNullableFilter<"dossier"> | string | null
    DATEDEBUTDESEANCE?: DateTimeNullableFilter<"dossier"> | Date | string | null
    DATEFINDESEANCE?: DateTimeNullableFilter<"dossier"> | Date | string | null
    ETAT?: StringNullableFilter<"dossier"> | string | null
    THEME?: StringNullableFilter<"dossier"> | string | null
    CNI?: StringFilter<"dossier"> | string
    CERTIFICAT?: StringFilter<"dossier"> | string
    LETTREMOTIVATION?: StringFilter<"dossier"> | string
    LETTRERECOMMENDATION?: StringFilter<"dossier"> | string
    PHOTOPROFIL?: StringFilter<"dossier"> | string
    CV?: StringNullableFilter<"dossier"> | string | null
    CAHIERDECHARGE?: StringNullableFilter<"dossier"> | string | null
    DATEDEPOT?: DateTimeFilter<"dossier"> | Date | string
    EMAILSENT?: BoolNullableFilter<"dossier"> | boolean | null
    affectation?: AffectationListRelationFilter
    etudiant?: XOR<EtudiantNullableScalarRelationFilter, etudiantWhereInput> | null
    lettreAcceptation?: LettreAcceptationListRelationFilter
  }

  export type dossierOrderByWithRelationInput = {
    IDDOSSIER?: SortOrder
    MATRICULEETUDIANT?: SortOrderInput | SortOrder
    DATEDEBUTDESEANCE?: SortOrderInput | SortOrder
    DATEFINDESEANCE?: SortOrderInput | SortOrder
    ETAT?: SortOrderInput | SortOrder
    THEME?: SortOrderInput | SortOrder
    CNI?: SortOrder
    CERTIFICAT?: SortOrder
    LETTREMOTIVATION?: SortOrder
    LETTRERECOMMENDATION?: SortOrder
    PHOTOPROFIL?: SortOrder
    CV?: SortOrderInput | SortOrder
    CAHIERDECHARGE?: SortOrderInput | SortOrder
    DATEDEPOT?: SortOrder
    EMAILSENT?: SortOrderInput | SortOrder
    affectation?: affectationOrderByRelationAggregateInput
    etudiant?: etudiantOrderByWithRelationInput
    lettreAcceptation?: lettreAcceptationOrderByRelationAggregateInput
    _relevance?: dossierOrderByRelevanceInput
  }

  export type dossierWhereUniqueInput = Prisma.AtLeast<{
    IDDOSSIER?: number
    AND?: dossierWhereInput | dossierWhereInput[]
    OR?: dossierWhereInput[]
    NOT?: dossierWhereInput | dossierWhereInput[]
    MATRICULEETUDIANT?: StringNullableFilter<"dossier"> | string | null
    DATEDEBUTDESEANCE?: DateTimeNullableFilter<"dossier"> | Date | string | null
    DATEFINDESEANCE?: DateTimeNullableFilter<"dossier"> | Date | string | null
    ETAT?: StringNullableFilter<"dossier"> | string | null
    THEME?: StringNullableFilter<"dossier"> | string | null
    CNI?: StringFilter<"dossier"> | string
    CERTIFICAT?: StringFilter<"dossier"> | string
    LETTREMOTIVATION?: StringFilter<"dossier"> | string
    LETTRERECOMMENDATION?: StringFilter<"dossier"> | string
    PHOTOPROFIL?: StringFilter<"dossier"> | string
    CV?: StringNullableFilter<"dossier"> | string | null
    CAHIERDECHARGE?: StringNullableFilter<"dossier"> | string | null
    DATEDEPOT?: DateTimeFilter<"dossier"> | Date | string
    EMAILSENT?: BoolNullableFilter<"dossier"> | boolean | null
    affectation?: AffectationListRelationFilter
    etudiant?: XOR<EtudiantNullableScalarRelationFilter, etudiantWhereInput> | null
    lettreAcceptation?: LettreAcceptationListRelationFilter
  }, "IDDOSSIER">

  export type dossierOrderByWithAggregationInput = {
    IDDOSSIER?: SortOrder
    MATRICULEETUDIANT?: SortOrderInput | SortOrder
    DATEDEBUTDESEANCE?: SortOrderInput | SortOrder
    DATEFINDESEANCE?: SortOrderInput | SortOrder
    ETAT?: SortOrderInput | SortOrder
    THEME?: SortOrderInput | SortOrder
    CNI?: SortOrder
    CERTIFICAT?: SortOrder
    LETTREMOTIVATION?: SortOrder
    LETTRERECOMMENDATION?: SortOrder
    PHOTOPROFIL?: SortOrder
    CV?: SortOrderInput | SortOrder
    CAHIERDECHARGE?: SortOrderInput | SortOrder
    DATEDEPOT?: SortOrder
    EMAILSENT?: SortOrderInput | SortOrder
    _count?: dossierCountOrderByAggregateInput
    _avg?: dossierAvgOrderByAggregateInput
    _max?: dossierMaxOrderByAggregateInput
    _min?: dossierMinOrderByAggregateInput
    _sum?: dossierSumOrderByAggregateInput
  }

  export type dossierScalarWhereWithAggregatesInput = {
    AND?: dossierScalarWhereWithAggregatesInput | dossierScalarWhereWithAggregatesInput[]
    OR?: dossierScalarWhereWithAggregatesInput[]
    NOT?: dossierScalarWhereWithAggregatesInput | dossierScalarWhereWithAggregatesInput[]
    IDDOSSIER?: IntWithAggregatesFilter<"dossier"> | number
    MATRICULEETUDIANT?: StringNullableWithAggregatesFilter<"dossier"> | string | null
    DATEDEBUTDESEANCE?: DateTimeNullableWithAggregatesFilter<"dossier"> | Date | string | null
    DATEFINDESEANCE?: DateTimeNullableWithAggregatesFilter<"dossier"> | Date | string | null
    ETAT?: StringNullableWithAggregatesFilter<"dossier"> | string | null
    THEME?: StringNullableWithAggregatesFilter<"dossier"> | string | null
    CNI?: StringWithAggregatesFilter<"dossier"> | string
    CERTIFICAT?: StringWithAggregatesFilter<"dossier"> | string
    LETTREMOTIVATION?: StringWithAggregatesFilter<"dossier"> | string
    LETTRERECOMMENDATION?: StringWithAggregatesFilter<"dossier"> | string
    PHOTOPROFIL?: StringWithAggregatesFilter<"dossier"> | string
    CV?: StringNullableWithAggregatesFilter<"dossier"> | string | null
    CAHIERDECHARGE?: StringNullableWithAggregatesFilter<"dossier"> | string | null
    DATEDEPOT?: DateTimeWithAggregatesFilter<"dossier"> | Date | string
    EMAILSENT?: BoolNullableWithAggregatesFilter<"dossier"> | boolean | null
  }

  export type encadreurWhereInput = {
    AND?: encadreurWhereInput | encadreurWhereInput[]
    OR?: encadreurWhereInput[]
    NOT?: encadreurWhereInput | encadreurWhereInput[]
    IDENCADREUR?: IntFilter<"encadreur"> | number
    MATRICULEENCADREUR?: StringFilter<"encadreur"> | string
    NOMENCADREUR?: StringNullableFilter<"encadreur"> | string | null
    PRENOMENCADREUR?: StringNullableFilter<"encadreur"> | string | null
    IDSTRUCTURE?: IntNullableFilter<"encadreur"> | number | null
    POSTE?: StringNullableFilter<"encadreur"> | string | null
    affectation?: AffectationListRelationFilter
    structures?: XOR<StructuresNullableScalarRelationFilter, structuresWhereInput> | null
  }

  export type encadreurOrderByWithRelationInput = {
    IDENCADREUR?: SortOrder
    MATRICULEENCADREUR?: SortOrder
    NOMENCADREUR?: SortOrderInput | SortOrder
    PRENOMENCADREUR?: SortOrderInput | SortOrder
    IDSTRUCTURE?: SortOrderInput | SortOrder
    POSTE?: SortOrderInput | SortOrder
    affectation?: affectationOrderByRelationAggregateInput
    structures?: structuresOrderByWithRelationInput
    _relevance?: encadreurOrderByRelevanceInput
  }

  export type encadreurWhereUniqueInput = Prisma.AtLeast<{
    IDENCADREUR?: number
    MATRICULEENCADREUR?: string
    AND?: encadreurWhereInput | encadreurWhereInput[]
    OR?: encadreurWhereInput[]
    NOT?: encadreurWhereInput | encadreurWhereInput[]
    NOMENCADREUR?: StringNullableFilter<"encadreur"> | string | null
    PRENOMENCADREUR?: StringNullableFilter<"encadreur"> | string | null
    IDSTRUCTURE?: IntNullableFilter<"encadreur"> | number | null
    POSTE?: StringNullableFilter<"encadreur"> | string | null
    affectation?: AffectationListRelationFilter
    structures?: XOR<StructuresNullableScalarRelationFilter, structuresWhereInput> | null
  }, "IDENCADREUR" | "MATRICULEENCADREUR">

  export type encadreurOrderByWithAggregationInput = {
    IDENCADREUR?: SortOrder
    MATRICULEENCADREUR?: SortOrder
    NOMENCADREUR?: SortOrderInput | SortOrder
    PRENOMENCADREUR?: SortOrderInput | SortOrder
    IDSTRUCTURE?: SortOrderInput | SortOrder
    POSTE?: SortOrderInput | SortOrder
    _count?: encadreurCountOrderByAggregateInput
    _avg?: encadreurAvgOrderByAggregateInput
    _max?: encadreurMaxOrderByAggregateInput
    _min?: encadreurMinOrderByAggregateInput
    _sum?: encadreurSumOrderByAggregateInput
  }

  export type encadreurScalarWhereWithAggregatesInput = {
    AND?: encadreurScalarWhereWithAggregatesInput | encadreurScalarWhereWithAggregatesInput[]
    OR?: encadreurScalarWhereWithAggregatesInput[]
    NOT?: encadreurScalarWhereWithAggregatesInput | encadreurScalarWhereWithAggregatesInput[]
    IDENCADREUR?: IntWithAggregatesFilter<"encadreur"> | number
    MATRICULEENCADREUR?: StringWithAggregatesFilter<"encadreur"> | string
    NOMENCADREUR?: StringNullableWithAggregatesFilter<"encadreur"> | string | null
    PRENOMENCADREUR?: StringNullableWithAggregatesFilter<"encadreur"> | string | null
    IDSTRUCTURE?: IntNullableWithAggregatesFilter<"encadreur"> | number | null
    POSTE?: StringNullableWithAggregatesFilter<"encadreur"> | string | null
  }

  export type etudiantWhereInput = {
    AND?: etudiantWhereInput | etudiantWhereInput[]
    OR?: etudiantWhereInput[]
    NOT?: etudiantWhereInput | etudiantWhereInput[]
    MATRICULEETUDIANT?: StringFilter<"etudiant"> | string
    NOMETUDIANT?: StringNullableFilter<"etudiant"> | string | null
    PRENOMETUDIANT?: StringNullableFilter<"etudiant"> | string | null
    ETABLISSEMENT?: StringNullableFilter<"etudiant"> | string | null
    VILLERESIDENCE?: StringNullableFilter<"etudiant"> | string | null
    PARCOURS?: StringNullableFilter<"etudiant"> | string | null
    NIVEAU?: StringNullableFilter<"etudiant"> | string | null
    EMAIL?: StringFilter<"etudiant"> | string
    TEL?: StringFilter<"etudiant"> | string
    FILIERE?: StringFilter<"etudiant"> | string
    SEXE?: StringFilter<"etudiant"> | string
    DATE?: DateTimeFilter<"etudiant"> | Date | string
    dossier?: DossierListRelationFilter
    rapport?: RapportListRelationFilter
  }

  export type etudiantOrderByWithRelationInput = {
    MATRICULEETUDIANT?: SortOrder
    NOMETUDIANT?: SortOrderInput | SortOrder
    PRENOMETUDIANT?: SortOrderInput | SortOrder
    ETABLISSEMENT?: SortOrderInput | SortOrder
    VILLERESIDENCE?: SortOrderInput | SortOrder
    PARCOURS?: SortOrderInput | SortOrder
    NIVEAU?: SortOrderInput | SortOrder
    EMAIL?: SortOrder
    TEL?: SortOrder
    FILIERE?: SortOrder
    SEXE?: SortOrder
    DATE?: SortOrder
    dossier?: dossierOrderByRelationAggregateInput
    rapport?: rapportOrderByRelationAggregateInput
    _relevance?: etudiantOrderByRelevanceInput
  }

  export type etudiantWhereUniqueInput = Prisma.AtLeast<{
    MATRICULEETUDIANT?: string
    AND?: etudiantWhereInput | etudiantWhereInput[]
    OR?: etudiantWhereInput[]
    NOT?: etudiantWhereInput | etudiantWhereInput[]
    NOMETUDIANT?: StringNullableFilter<"etudiant"> | string | null
    PRENOMETUDIANT?: StringNullableFilter<"etudiant"> | string | null
    ETABLISSEMENT?: StringNullableFilter<"etudiant"> | string | null
    VILLERESIDENCE?: StringNullableFilter<"etudiant"> | string | null
    PARCOURS?: StringNullableFilter<"etudiant"> | string | null
    NIVEAU?: StringNullableFilter<"etudiant"> | string | null
    EMAIL?: StringFilter<"etudiant"> | string
    TEL?: StringFilter<"etudiant"> | string
    FILIERE?: StringFilter<"etudiant"> | string
    SEXE?: StringFilter<"etudiant"> | string
    DATE?: DateTimeFilter<"etudiant"> | Date | string
    dossier?: DossierListRelationFilter
    rapport?: RapportListRelationFilter
  }, "MATRICULEETUDIANT">

  export type etudiantOrderByWithAggregationInput = {
    MATRICULEETUDIANT?: SortOrder
    NOMETUDIANT?: SortOrderInput | SortOrder
    PRENOMETUDIANT?: SortOrderInput | SortOrder
    ETABLISSEMENT?: SortOrderInput | SortOrder
    VILLERESIDENCE?: SortOrderInput | SortOrder
    PARCOURS?: SortOrderInput | SortOrder
    NIVEAU?: SortOrderInput | SortOrder
    EMAIL?: SortOrder
    TEL?: SortOrder
    FILIERE?: SortOrder
    SEXE?: SortOrder
    DATE?: SortOrder
    _count?: etudiantCountOrderByAggregateInput
    _max?: etudiantMaxOrderByAggregateInput
    _min?: etudiantMinOrderByAggregateInput
  }

  export type etudiantScalarWhereWithAggregatesInput = {
    AND?: etudiantScalarWhereWithAggregatesInput | etudiantScalarWhereWithAggregatesInput[]
    OR?: etudiantScalarWhereWithAggregatesInput[]
    NOT?: etudiantScalarWhereWithAggregatesInput | etudiantScalarWhereWithAggregatesInput[]
    MATRICULEETUDIANT?: StringWithAggregatesFilter<"etudiant"> | string
    NOMETUDIANT?: StringNullableWithAggregatesFilter<"etudiant"> | string | null
    PRENOMETUDIANT?: StringNullableWithAggregatesFilter<"etudiant"> | string | null
    ETABLISSEMENT?: StringNullableWithAggregatesFilter<"etudiant"> | string | null
    VILLERESIDENCE?: StringNullableWithAggregatesFilter<"etudiant"> | string | null
    PARCOURS?: StringNullableWithAggregatesFilter<"etudiant"> | string | null
    NIVEAU?: StringNullableWithAggregatesFilter<"etudiant"> | string | null
    EMAIL?: StringWithAggregatesFilter<"etudiant"> | string
    TEL?: StringWithAggregatesFilter<"etudiant"> | string
    FILIERE?: StringWithAggregatesFilter<"etudiant"> | string
    SEXE?: StringWithAggregatesFilter<"etudiant"> | string
    DATE?: DateTimeWithAggregatesFilter<"etudiant"> | Date | string
  }

  export type logs_actionsWhereInput = {
    AND?: logs_actionsWhereInput | logs_actionsWhereInput[]
    OR?: logs_actionsWhereInput[]
    NOT?: logs_actionsWhereInput | logs_actionsWhereInput[]
    id?: IntFilter<"logs_actions"> | number
    user_email?: StringNullableFilter<"logs_actions"> | string | null
    user_name?: StringNullableFilter<"logs_actions"> | string | null
    action?: StringNullableFilter<"logs_actions"> | string | null
    methode_http?: StringNullableFilter<"logs_actions"> | string | null
    endpoint?: StringNullableFilter<"logs_actions"> | string | null
    requete_executee?: StringNullableFilter<"logs_actions"> | string | null
    ip_address?: StringNullableFilter<"logs_actions"> | string | null
    user_agent?: StringNullableFilter<"logs_actions"> | string | null
    status_code?: IntNullableFilter<"logs_actions"> | number | null
    horodatage?: DateTimeNullableFilter<"logs_actions"> | Date | string | null
  }

  export type logs_actionsOrderByWithRelationInput = {
    id?: SortOrder
    user_email?: SortOrderInput | SortOrder
    user_name?: SortOrderInput | SortOrder
    action?: SortOrderInput | SortOrder
    methode_http?: SortOrderInput | SortOrder
    endpoint?: SortOrderInput | SortOrder
    requete_executee?: SortOrderInput | SortOrder
    ip_address?: SortOrderInput | SortOrder
    user_agent?: SortOrderInput | SortOrder
    status_code?: SortOrderInput | SortOrder
    horodatage?: SortOrderInput | SortOrder
    _relevance?: logs_actionsOrderByRelevanceInput
  }

  export type logs_actionsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: logs_actionsWhereInput | logs_actionsWhereInput[]
    OR?: logs_actionsWhereInput[]
    NOT?: logs_actionsWhereInput | logs_actionsWhereInput[]
    user_email?: StringNullableFilter<"logs_actions"> | string | null
    user_name?: StringNullableFilter<"logs_actions"> | string | null
    action?: StringNullableFilter<"logs_actions"> | string | null
    methode_http?: StringNullableFilter<"logs_actions"> | string | null
    endpoint?: StringNullableFilter<"logs_actions"> | string | null
    requete_executee?: StringNullableFilter<"logs_actions"> | string | null
    ip_address?: StringNullableFilter<"logs_actions"> | string | null
    user_agent?: StringNullableFilter<"logs_actions"> | string | null
    status_code?: IntNullableFilter<"logs_actions"> | number | null
    horodatage?: DateTimeNullableFilter<"logs_actions"> | Date | string | null
  }, "id">

  export type logs_actionsOrderByWithAggregationInput = {
    id?: SortOrder
    user_email?: SortOrderInput | SortOrder
    user_name?: SortOrderInput | SortOrder
    action?: SortOrderInput | SortOrder
    methode_http?: SortOrderInput | SortOrder
    endpoint?: SortOrderInput | SortOrder
    requete_executee?: SortOrderInput | SortOrder
    ip_address?: SortOrderInput | SortOrder
    user_agent?: SortOrderInput | SortOrder
    status_code?: SortOrderInput | SortOrder
    horodatage?: SortOrderInput | SortOrder
    _count?: logs_actionsCountOrderByAggregateInput
    _avg?: logs_actionsAvgOrderByAggregateInput
    _max?: logs_actionsMaxOrderByAggregateInput
    _min?: logs_actionsMinOrderByAggregateInput
    _sum?: logs_actionsSumOrderByAggregateInput
  }

  export type logs_actionsScalarWhereWithAggregatesInput = {
    AND?: logs_actionsScalarWhereWithAggregatesInput | logs_actionsScalarWhereWithAggregatesInput[]
    OR?: logs_actionsScalarWhereWithAggregatesInput[]
    NOT?: logs_actionsScalarWhereWithAggregatesInput | logs_actionsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"logs_actions"> | number
    user_email?: StringNullableWithAggregatesFilter<"logs_actions"> | string | null
    user_name?: StringNullableWithAggregatesFilter<"logs_actions"> | string | null
    action?: StringNullableWithAggregatesFilter<"logs_actions"> | string | null
    methode_http?: StringNullableWithAggregatesFilter<"logs_actions"> | string | null
    endpoint?: StringNullableWithAggregatesFilter<"logs_actions"> | string | null
    requete_executee?: StringNullableWithAggregatesFilter<"logs_actions"> | string | null
    ip_address?: StringNullableWithAggregatesFilter<"logs_actions"> | string | null
    user_agent?: StringNullableWithAggregatesFilter<"logs_actions"> | string | null
    status_code?: IntNullableWithAggregatesFilter<"logs_actions"> | number | null
    horodatage?: DateTimeNullableWithAggregatesFilter<"logs_actions"> | Date | string | null
  }

  export type rapportWhereInput = {
    AND?: rapportWhereInput | rapportWhereInput[]
    OR?: rapportWhereInput[]
    NOT?: rapportWhereInput | rapportWhereInput[]
    IDDOSSIER?: IntFilter<"rapport"> | number
    MATRICULE?: StringFilter<"rapport"> | string
    COMMENTAIRE?: StringFilter<"rapport"> | string
    THEME?: StringFilter<"rapport"> | string
    FICHIER?: StringFilter<"rapport"> | string
    DATE?: DateTimeFilter<"rapport"> | Date | string
    etudiant?: XOR<EtudiantScalarRelationFilter, etudiantWhereInput>
  }

  export type rapportOrderByWithRelationInput = {
    IDDOSSIER?: SortOrder
    MATRICULE?: SortOrder
    COMMENTAIRE?: SortOrder
    THEME?: SortOrder
    FICHIER?: SortOrder
    DATE?: SortOrder
    etudiant?: etudiantOrderByWithRelationInput
    _relevance?: rapportOrderByRelevanceInput
  }

  export type rapportWhereUniqueInput = Prisma.AtLeast<{
    IDDOSSIER?: number
    AND?: rapportWhereInput | rapportWhereInput[]
    OR?: rapportWhereInput[]
    NOT?: rapportWhereInput | rapportWhereInput[]
    MATRICULE?: StringFilter<"rapport"> | string
    COMMENTAIRE?: StringFilter<"rapport"> | string
    THEME?: StringFilter<"rapport"> | string
    FICHIER?: StringFilter<"rapport"> | string
    DATE?: DateTimeFilter<"rapport"> | Date | string
    etudiant?: XOR<EtudiantScalarRelationFilter, etudiantWhereInput>
  }, "IDDOSSIER">

  export type rapportOrderByWithAggregationInput = {
    IDDOSSIER?: SortOrder
    MATRICULE?: SortOrder
    COMMENTAIRE?: SortOrder
    THEME?: SortOrder
    FICHIER?: SortOrder
    DATE?: SortOrder
    _count?: rapportCountOrderByAggregateInput
    _avg?: rapportAvgOrderByAggregateInput
    _max?: rapportMaxOrderByAggregateInput
    _min?: rapportMinOrderByAggregateInput
    _sum?: rapportSumOrderByAggregateInput
  }

  export type rapportScalarWhereWithAggregatesInput = {
    AND?: rapportScalarWhereWithAggregatesInput | rapportScalarWhereWithAggregatesInput[]
    OR?: rapportScalarWhereWithAggregatesInput[]
    NOT?: rapportScalarWhereWithAggregatesInput | rapportScalarWhereWithAggregatesInput[]
    IDDOSSIER?: IntWithAggregatesFilter<"rapport"> | number
    MATRICULE?: StringWithAggregatesFilter<"rapport"> | string
    COMMENTAIRE?: StringWithAggregatesFilter<"rapport"> | string
    THEME?: StringWithAggregatesFilter<"rapport"> | string
    FICHIER?: StringWithAggregatesFilter<"rapport"> | string
    DATE?: DateTimeWithAggregatesFilter<"rapport"> | Date | string
  }

  export type lettreAcceptationWhereInput = {
    AND?: lettreAcceptationWhereInput | lettreAcceptationWhereInput[]
    OR?: lettreAcceptationWhereInput[]
    NOT?: lettreAcceptationWhereInput | lettreAcceptationWhereInput[]
    IDLETTRE?: IntFilter<"lettreAcceptation"> | number
    IDDOSSIER?: IntFilter<"lettreAcceptation"> | number
    COMMENTAIRE?: StringFilter<"lettreAcceptation"> | string
    FICHIER?: StringFilter<"lettreAcceptation"> | string
    DATEUPLOAD?: DateTimeFilter<"lettreAcceptation"> | Date | string
    EMAILSENT?: BoolFilter<"lettreAcceptation"> | boolean
    dossier?: XOR<DossierScalarRelationFilter, dossierWhereInput>
  }

  export type lettreAcceptationOrderByWithRelationInput = {
    IDLETTRE?: SortOrder
    IDDOSSIER?: SortOrder
    COMMENTAIRE?: SortOrder
    FICHIER?: SortOrder
    DATEUPLOAD?: SortOrder
    EMAILSENT?: SortOrder
    dossier?: dossierOrderByWithRelationInput
    _relevance?: lettreAcceptationOrderByRelevanceInput
  }

  export type lettreAcceptationWhereUniqueInput = Prisma.AtLeast<{
    IDLETTRE?: number
    AND?: lettreAcceptationWhereInput | lettreAcceptationWhereInput[]
    OR?: lettreAcceptationWhereInput[]
    NOT?: lettreAcceptationWhereInput | lettreAcceptationWhereInput[]
    IDDOSSIER?: IntFilter<"lettreAcceptation"> | number
    COMMENTAIRE?: StringFilter<"lettreAcceptation"> | string
    FICHIER?: StringFilter<"lettreAcceptation"> | string
    DATEUPLOAD?: DateTimeFilter<"lettreAcceptation"> | Date | string
    EMAILSENT?: BoolFilter<"lettreAcceptation"> | boolean
    dossier?: XOR<DossierScalarRelationFilter, dossierWhereInput>
  }, "IDLETTRE">

  export type lettreAcceptationOrderByWithAggregationInput = {
    IDLETTRE?: SortOrder
    IDDOSSIER?: SortOrder
    COMMENTAIRE?: SortOrder
    FICHIER?: SortOrder
    DATEUPLOAD?: SortOrder
    EMAILSENT?: SortOrder
    _count?: lettreAcceptationCountOrderByAggregateInput
    _avg?: lettreAcceptationAvgOrderByAggregateInput
    _max?: lettreAcceptationMaxOrderByAggregateInput
    _min?: lettreAcceptationMinOrderByAggregateInput
    _sum?: lettreAcceptationSumOrderByAggregateInput
  }

  export type lettreAcceptationScalarWhereWithAggregatesInput = {
    AND?: lettreAcceptationScalarWhereWithAggregatesInput | lettreAcceptationScalarWhereWithAggregatesInput[]
    OR?: lettreAcceptationScalarWhereWithAggregatesInput[]
    NOT?: lettreAcceptationScalarWhereWithAggregatesInput | lettreAcceptationScalarWhereWithAggregatesInput[]
    IDLETTRE?: IntWithAggregatesFilter<"lettreAcceptation"> | number
    IDDOSSIER?: IntWithAggregatesFilter<"lettreAcceptation"> | number
    COMMENTAIRE?: StringWithAggregatesFilter<"lettreAcceptation"> | string
    FICHIER?: StringWithAggregatesFilter<"lettreAcceptation"> | string
    DATEUPLOAD?: DateTimeWithAggregatesFilter<"lettreAcceptation"> | Date | string
    EMAILSENT?: BoolWithAggregatesFilter<"lettreAcceptation"> | boolean
  }

  export type structuresWhereInput = {
    AND?: structuresWhereInput | structuresWhereInput[]
    OR?: structuresWhereInput[]
    NOT?: structuresWhereInput | structuresWhereInput[]
    IDSTRUCTURE?: IntFilter<"structures"> | number
    NOMSTRUCTURE?: StringFilter<"structures"> | string
    ABBREVIATION?: StringFilter<"structures"> | string
    IDPARENT?: IntNullableFilter<"structures"> | number | null
    affectation?: AffectationListRelationFilter
    encadreur?: EncadreurListRelationFilter
    structures?: XOR<StructuresNullableScalarRelationFilter, structuresWhereInput> | null
    other_structures?: StructuresListRelationFilter
  }

  export type structuresOrderByWithRelationInput = {
    IDSTRUCTURE?: SortOrder
    NOMSTRUCTURE?: SortOrder
    ABBREVIATION?: SortOrder
    IDPARENT?: SortOrderInput | SortOrder
    affectation?: affectationOrderByRelationAggregateInput
    encadreur?: encadreurOrderByRelationAggregateInput
    structures?: structuresOrderByWithRelationInput
    other_structures?: structuresOrderByRelationAggregateInput
    _relevance?: structuresOrderByRelevanceInput
  }

  export type structuresWhereUniqueInput = Prisma.AtLeast<{
    IDSTRUCTURE?: number
    AND?: structuresWhereInput | structuresWhereInput[]
    OR?: structuresWhereInput[]
    NOT?: structuresWhereInput | structuresWhereInput[]
    NOMSTRUCTURE?: StringFilter<"structures"> | string
    ABBREVIATION?: StringFilter<"structures"> | string
    IDPARENT?: IntNullableFilter<"structures"> | number | null
    affectation?: AffectationListRelationFilter
    encadreur?: EncadreurListRelationFilter
    structures?: XOR<StructuresNullableScalarRelationFilter, structuresWhereInput> | null
    other_structures?: StructuresListRelationFilter
  }, "IDSTRUCTURE">

  export type structuresOrderByWithAggregationInput = {
    IDSTRUCTURE?: SortOrder
    NOMSTRUCTURE?: SortOrder
    ABBREVIATION?: SortOrder
    IDPARENT?: SortOrderInput | SortOrder
    _count?: structuresCountOrderByAggregateInput
    _avg?: structuresAvgOrderByAggregateInput
    _max?: structuresMaxOrderByAggregateInput
    _min?: structuresMinOrderByAggregateInput
    _sum?: structuresSumOrderByAggregateInput
  }

  export type structuresScalarWhereWithAggregatesInput = {
    AND?: structuresScalarWhereWithAggregatesInput | structuresScalarWhereWithAggregatesInput[]
    OR?: structuresScalarWhereWithAggregatesInput[]
    NOT?: structuresScalarWhereWithAggregatesInput | structuresScalarWhereWithAggregatesInput[]
    IDSTRUCTURE?: IntWithAggregatesFilter<"structures"> | number
    NOMSTRUCTURE?: StringWithAggregatesFilter<"structures"> | string
    ABBREVIATION?: StringWithAggregatesFilter<"structures"> | string
    IDPARENT?: IntNullableWithAggregatesFilter<"structures"> | number | null
  }

  export type administrateurCreateInput = {
    MATRICULEADMIN: string
    NOMADMIN: string
    PRENOMADMIN: string
    EMAILADMIN: string
    PASSWARDADMIN: string
    PHOTOADMIN: string
    affectation?: affectationCreateNestedManyWithoutAdministrateurInput
  }

  export type administrateurUncheckedCreateInput = {
    IDADMIN?: number
    MATRICULEADMIN: string
    NOMADMIN: string
    PRENOMADMIN: string
    EMAILADMIN: string
    PASSWARDADMIN: string
    PHOTOADMIN: string
    affectation?: affectationUncheckedCreateNestedManyWithoutAdministrateurInput
  }

  export type administrateurUpdateInput = {
    MATRICULEADMIN?: StringFieldUpdateOperationsInput | string
    NOMADMIN?: StringFieldUpdateOperationsInput | string
    PRENOMADMIN?: StringFieldUpdateOperationsInput | string
    EMAILADMIN?: StringFieldUpdateOperationsInput | string
    PASSWARDADMIN?: StringFieldUpdateOperationsInput | string
    PHOTOADMIN?: StringFieldUpdateOperationsInput | string
    affectation?: affectationUpdateManyWithoutAdministrateurNestedInput
  }

  export type administrateurUncheckedUpdateInput = {
    IDADMIN?: IntFieldUpdateOperationsInput | number
    MATRICULEADMIN?: StringFieldUpdateOperationsInput | string
    NOMADMIN?: StringFieldUpdateOperationsInput | string
    PRENOMADMIN?: StringFieldUpdateOperationsInput | string
    EMAILADMIN?: StringFieldUpdateOperationsInput | string
    PASSWARDADMIN?: StringFieldUpdateOperationsInput | string
    PHOTOADMIN?: StringFieldUpdateOperationsInput | string
    affectation?: affectationUncheckedUpdateManyWithoutAdministrateurNestedInput
  }

  export type administrateurCreateManyInput = {
    IDADMIN?: number
    MATRICULEADMIN: string
    NOMADMIN: string
    PRENOMADMIN: string
    EMAILADMIN: string
    PASSWARDADMIN: string
    PHOTOADMIN: string
  }

  export type administrateurUpdateManyMutationInput = {
    MATRICULEADMIN?: StringFieldUpdateOperationsInput | string
    NOMADMIN?: StringFieldUpdateOperationsInput | string
    PRENOMADMIN?: StringFieldUpdateOperationsInput | string
    EMAILADMIN?: StringFieldUpdateOperationsInput | string
    PASSWARDADMIN?: StringFieldUpdateOperationsInput | string
    PHOTOADMIN?: StringFieldUpdateOperationsInput | string
  }

  export type administrateurUncheckedUpdateManyInput = {
    IDADMIN?: IntFieldUpdateOperationsInput | number
    MATRICULEADMIN?: StringFieldUpdateOperationsInput | string
    NOMADMIN?: StringFieldUpdateOperationsInput | string
    PRENOMADMIN?: StringFieldUpdateOperationsInput | string
    EMAILADMIN?: StringFieldUpdateOperationsInput | string
    PASSWARDADMIN?: StringFieldUpdateOperationsInput | string
    PHOTOADMIN?: StringFieldUpdateOperationsInput | string
  }

  export type affectationCreateInput = {
    administrateur: administrateurCreateNestedOneWithoutAffectationInput
    encadreur: encadreurCreateNestedOneWithoutAffectationInput
    dossier: dossierCreateNestedOneWithoutAffectationInput
    structures: structuresCreateNestedOneWithoutAffectationInput
  }

  export type affectationUncheckedCreateInput = {
    IDADMIN: number
    IDENCADREUR: number
    IDDOSSIER: number
    IDSTRUCTURE: number
  }

  export type affectationUpdateInput = {
    administrateur?: administrateurUpdateOneRequiredWithoutAffectationNestedInput
    encadreur?: encadreurUpdateOneRequiredWithoutAffectationNestedInput
    dossier?: dossierUpdateOneRequiredWithoutAffectationNestedInput
    structures?: structuresUpdateOneRequiredWithoutAffectationNestedInput
  }

  export type affectationUncheckedUpdateInput = {
    IDADMIN?: IntFieldUpdateOperationsInput | number
    IDENCADREUR?: IntFieldUpdateOperationsInput | number
    IDDOSSIER?: IntFieldUpdateOperationsInput | number
    IDSTRUCTURE?: IntFieldUpdateOperationsInput | number
  }

  export type affectationCreateManyInput = {
    IDADMIN: number
    IDENCADREUR: number
    IDDOSSIER: number
    IDSTRUCTURE: number
  }

  export type affectationUpdateManyMutationInput = {

  }

  export type affectationUncheckedUpdateManyInput = {
    IDADMIN?: IntFieldUpdateOperationsInput | number
    IDENCADREUR?: IntFieldUpdateOperationsInput | number
    IDDOSSIER?: IntFieldUpdateOperationsInput | number
    IDSTRUCTURE?: IntFieldUpdateOperationsInput | number
  }

  export type dossierCreateInput = {
    DATEDEBUTDESEANCE?: Date | string | null
    DATEFINDESEANCE?: Date | string | null
    ETAT?: string | null
    THEME?: string | null
    CNI: string
    CERTIFICAT: string
    LETTREMOTIVATION: string
    LETTRERECOMMENDATION: string
    PHOTOPROFIL: string
    CV?: string | null
    CAHIERDECHARGE?: string | null
    DATEDEPOT?: Date | string
    EMAILSENT?: boolean | null
    affectation?: affectationCreateNestedManyWithoutDossierInput
    etudiant?: etudiantCreateNestedOneWithoutDossierInput
    lettreAcceptation?: lettreAcceptationCreateNestedManyWithoutDossierInput
  }

  export type dossierUncheckedCreateInput = {
    IDDOSSIER?: number
    MATRICULEETUDIANT?: string | null
    DATEDEBUTDESEANCE?: Date | string | null
    DATEFINDESEANCE?: Date | string | null
    ETAT?: string | null
    THEME?: string | null
    CNI: string
    CERTIFICAT: string
    LETTREMOTIVATION: string
    LETTRERECOMMENDATION: string
    PHOTOPROFIL: string
    CV?: string | null
    CAHIERDECHARGE?: string | null
    DATEDEPOT?: Date | string
    EMAILSENT?: boolean | null
    affectation?: affectationUncheckedCreateNestedManyWithoutDossierInput
    lettreAcceptation?: lettreAcceptationUncheckedCreateNestedManyWithoutDossierInput
  }

  export type dossierUpdateInput = {
    DATEDEBUTDESEANCE?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    DATEFINDESEANCE?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ETAT?: NullableStringFieldUpdateOperationsInput | string | null
    THEME?: NullableStringFieldUpdateOperationsInput | string | null
    CNI?: StringFieldUpdateOperationsInput | string
    CERTIFICAT?: StringFieldUpdateOperationsInput | string
    LETTREMOTIVATION?: StringFieldUpdateOperationsInput | string
    LETTRERECOMMENDATION?: StringFieldUpdateOperationsInput | string
    PHOTOPROFIL?: StringFieldUpdateOperationsInput | string
    CV?: NullableStringFieldUpdateOperationsInput | string | null
    CAHIERDECHARGE?: NullableStringFieldUpdateOperationsInput | string | null
    DATEDEPOT?: DateTimeFieldUpdateOperationsInput | Date | string
    EMAILSENT?: NullableBoolFieldUpdateOperationsInput | boolean | null
    affectation?: affectationUpdateManyWithoutDossierNestedInput
    etudiant?: etudiantUpdateOneWithoutDossierNestedInput
    lettreAcceptation?: lettreAcceptationUpdateManyWithoutDossierNestedInput
  }

  export type dossierUncheckedUpdateInput = {
    IDDOSSIER?: IntFieldUpdateOperationsInput | number
    MATRICULEETUDIANT?: NullableStringFieldUpdateOperationsInput | string | null
    DATEDEBUTDESEANCE?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    DATEFINDESEANCE?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ETAT?: NullableStringFieldUpdateOperationsInput | string | null
    THEME?: NullableStringFieldUpdateOperationsInput | string | null
    CNI?: StringFieldUpdateOperationsInput | string
    CERTIFICAT?: StringFieldUpdateOperationsInput | string
    LETTREMOTIVATION?: StringFieldUpdateOperationsInput | string
    LETTRERECOMMENDATION?: StringFieldUpdateOperationsInput | string
    PHOTOPROFIL?: StringFieldUpdateOperationsInput | string
    CV?: NullableStringFieldUpdateOperationsInput | string | null
    CAHIERDECHARGE?: NullableStringFieldUpdateOperationsInput | string | null
    DATEDEPOT?: DateTimeFieldUpdateOperationsInput | Date | string
    EMAILSENT?: NullableBoolFieldUpdateOperationsInput | boolean | null
    affectation?: affectationUncheckedUpdateManyWithoutDossierNestedInput
    lettreAcceptation?: lettreAcceptationUncheckedUpdateManyWithoutDossierNestedInput
  }

  export type dossierCreateManyInput = {
    IDDOSSIER?: number
    MATRICULEETUDIANT?: string | null
    DATEDEBUTDESEANCE?: Date | string | null
    DATEFINDESEANCE?: Date | string | null
    ETAT?: string | null
    THEME?: string | null
    CNI: string
    CERTIFICAT: string
    LETTREMOTIVATION: string
    LETTRERECOMMENDATION: string
    PHOTOPROFIL: string
    CV?: string | null
    CAHIERDECHARGE?: string | null
    DATEDEPOT?: Date | string
    EMAILSENT?: boolean | null
  }

  export type dossierUpdateManyMutationInput = {
    DATEDEBUTDESEANCE?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    DATEFINDESEANCE?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ETAT?: NullableStringFieldUpdateOperationsInput | string | null
    THEME?: NullableStringFieldUpdateOperationsInput | string | null
    CNI?: StringFieldUpdateOperationsInput | string
    CERTIFICAT?: StringFieldUpdateOperationsInput | string
    LETTREMOTIVATION?: StringFieldUpdateOperationsInput | string
    LETTRERECOMMENDATION?: StringFieldUpdateOperationsInput | string
    PHOTOPROFIL?: StringFieldUpdateOperationsInput | string
    CV?: NullableStringFieldUpdateOperationsInput | string | null
    CAHIERDECHARGE?: NullableStringFieldUpdateOperationsInput | string | null
    DATEDEPOT?: DateTimeFieldUpdateOperationsInput | Date | string
    EMAILSENT?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type dossierUncheckedUpdateManyInput = {
    IDDOSSIER?: IntFieldUpdateOperationsInput | number
    MATRICULEETUDIANT?: NullableStringFieldUpdateOperationsInput | string | null
    DATEDEBUTDESEANCE?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    DATEFINDESEANCE?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ETAT?: NullableStringFieldUpdateOperationsInput | string | null
    THEME?: NullableStringFieldUpdateOperationsInput | string | null
    CNI?: StringFieldUpdateOperationsInput | string
    CERTIFICAT?: StringFieldUpdateOperationsInput | string
    LETTREMOTIVATION?: StringFieldUpdateOperationsInput | string
    LETTRERECOMMENDATION?: StringFieldUpdateOperationsInput | string
    PHOTOPROFIL?: StringFieldUpdateOperationsInput | string
    CV?: NullableStringFieldUpdateOperationsInput | string | null
    CAHIERDECHARGE?: NullableStringFieldUpdateOperationsInput | string | null
    DATEDEPOT?: DateTimeFieldUpdateOperationsInput | Date | string
    EMAILSENT?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type encadreurCreateInput = {
    MATRICULEENCADREUR: string
    NOMENCADREUR?: string | null
    PRENOMENCADREUR?: string | null
    POSTE?: string | null
    affectation?: affectationCreateNestedManyWithoutEncadreurInput
    structures?: structuresCreateNestedOneWithoutEncadreurInput
  }

  export type encadreurUncheckedCreateInput = {
    IDENCADREUR?: number
    MATRICULEENCADREUR: string
    NOMENCADREUR?: string | null
    PRENOMENCADREUR?: string | null
    IDSTRUCTURE?: number | null
    POSTE?: string | null
    affectation?: affectationUncheckedCreateNestedManyWithoutEncadreurInput
  }

  export type encadreurUpdateInput = {
    MATRICULEENCADREUR?: StringFieldUpdateOperationsInput | string
    NOMENCADREUR?: NullableStringFieldUpdateOperationsInput | string | null
    PRENOMENCADREUR?: NullableStringFieldUpdateOperationsInput | string | null
    POSTE?: NullableStringFieldUpdateOperationsInput | string | null
    affectation?: affectationUpdateManyWithoutEncadreurNestedInput
    structures?: structuresUpdateOneWithoutEncadreurNestedInput
  }

  export type encadreurUncheckedUpdateInput = {
    IDENCADREUR?: IntFieldUpdateOperationsInput | number
    MATRICULEENCADREUR?: StringFieldUpdateOperationsInput | string
    NOMENCADREUR?: NullableStringFieldUpdateOperationsInput | string | null
    PRENOMENCADREUR?: NullableStringFieldUpdateOperationsInput | string | null
    IDSTRUCTURE?: NullableIntFieldUpdateOperationsInput | number | null
    POSTE?: NullableStringFieldUpdateOperationsInput | string | null
    affectation?: affectationUncheckedUpdateManyWithoutEncadreurNestedInput
  }

  export type encadreurCreateManyInput = {
    IDENCADREUR?: number
    MATRICULEENCADREUR: string
    NOMENCADREUR?: string | null
    PRENOMENCADREUR?: string | null
    IDSTRUCTURE?: number | null
    POSTE?: string | null
  }

  export type encadreurUpdateManyMutationInput = {
    MATRICULEENCADREUR?: StringFieldUpdateOperationsInput | string
    NOMENCADREUR?: NullableStringFieldUpdateOperationsInput | string | null
    PRENOMENCADREUR?: NullableStringFieldUpdateOperationsInput | string | null
    POSTE?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type encadreurUncheckedUpdateManyInput = {
    IDENCADREUR?: IntFieldUpdateOperationsInput | number
    MATRICULEENCADREUR?: StringFieldUpdateOperationsInput | string
    NOMENCADREUR?: NullableStringFieldUpdateOperationsInput | string | null
    PRENOMENCADREUR?: NullableStringFieldUpdateOperationsInput | string | null
    IDSTRUCTURE?: NullableIntFieldUpdateOperationsInput | number | null
    POSTE?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type etudiantCreateInput = {
    MATRICULEETUDIANT: string
    NOMETUDIANT?: string | null
    PRENOMETUDIANT?: string | null
    ETABLISSEMENT?: string | null
    VILLERESIDENCE?: string | null
    PARCOURS?: string | null
    NIVEAU?: string | null
    EMAIL: string
    TEL: string
    FILIERE: string
    SEXE: string
    DATE?: Date | string
    dossier?: dossierCreateNestedManyWithoutEtudiantInput
    rapport?: rapportCreateNestedManyWithoutEtudiantInput
  }

  export type etudiantUncheckedCreateInput = {
    MATRICULEETUDIANT: string
    NOMETUDIANT?: string | null
    PRENOMETUDIANT?: string | null
    ETABLISSEMENT?: string | null
    VILLERESIDENCE?: string | null
    PARCOURS?: string | null
    NIVEAU?: string | null
    EMAIL: string
    TEL: string
    FILIERE: string
    SEXE: string
    DATE?: Date | string
    dossier?: dossierUncheckedCreateNestedManyWithoutEtudiantInput
    rapport?: rapportUncheckedCreateNestedManyWithoutEtudiantInput
  }

  export type etudiantUpdateInput = {
    MATRICULEETUDIANT?: StringFieldUpdateOperationsInput | string
    NOMETUDIANT?: NullableStringFieldUpdateOperationsInput | string | null
    PRENOMETUDIANT?: NullableStringFieldUpdateOperationsInput | string | null
    ETABLISSEMENT?: NullableStringFieldUpdateOperationsInput | string | null
    VILLERESIDENCE?: NullableStringFieldUpdateOperationsInput | string | null
    PARCOURS?: NullableStringFieldUpdateOperationsInput | string | null
    NIVEAU?: NullableStringFieldUpdateOperationsInput | string | null
    EMAIL?: StringFieldUpdateOperationsInput | string
    TEL?: StringFieldUpdateOperationsInput | string
    FILIERE?: StringFieldUpdateOperationsInput | string
    SEXE?: StringFieldUpdateOperationsInput | string
    DATE?: DateTimeFieldUpdateOperationsInput | Date | string
    dossier?: dossierUpdateManyWithoutEtudiantNestedInput
    rapport?: rapportUpdateManyWithoutEtudiantNestedInput
  }

  export type etudiantUncheckedUpdateInput = {
    MATRICULEETUDIANT?: StringFieldUpdateOperationsInput | string
    NOMETUDIANT?: NullableStringFieldUpdateOperationsInput | string | null
    PRENOMETUDIANT?: NullableStringFieldUpdateOperationsInput | string | null
    ETABLISSEMENT?: NullableStringFieldUpdateOperationsInput | string | null
    VILLERESIDENCE?: NullableStringFieldUpdateOperationsInput | string | null
    PARCOURS?: NullableStringFieldUpdateOperationsInput | string | null
    NIVEAU?: NullableStringFieldUpdateOperationsInput | string | null
    EMAIL?: StringFieldUpdateOperationsInput | string
    TEL?: StringFieldUpdateOperationsInput | string
    FILIERE?: StringFieldUpdateOperationsInput | string
    SEXE?: StringFieldUpdateOperationsInput | string
    DATE?: DateTimeFieldUpdateOperationsInput | Date | string
    dossier?: dossierUncheckedUpdateManyWithoutEtudiantNestedInput
    rapport?: rapportUncheckedUpdateManyWithoutEtudiantNestedInput
  }

  export type etudiantCreateManyInput = {
    MATRICULEETUDIANT: string
    NOMETUDIANT?: string | null
    PRENOMETUDIANT?: string | null
    ETABLISSEMENT?: string | null
    VILLERESIDENCE?: string | null
    PARCOURS?: string | null
    NIVEAU?: string | null
    EMAIL: string
    TEL: string
    FILIERE: string
    SEXE: string
    DATE?: Date | string
  }

  export type etudiantUpdateManyMutationInput = {
    MATRICULEETUDIANT?: StringFieldUpdateOperationsInput | string
    NOMETUDIANT?: NullableStringFieldUpdateOperationsInput | string | null
    PRENOMETUDIANT?: NullableStringFieldUpdateOperationsInput | string | null
    ETABLISSEMENT?: NullableStringFieldUpdateOperationsInput | string | null
    VILLERESIDENCE?: NullableStringFieldUpdateOperationsInput | string | null
    PARCOURS?: NullableStringFieldUpdateOperationsInput | string | null
    NIVEAU?: NullableStringFieldUpdateOperationsInput | string | null
    EMAIL?: StringFieldUpdateOperationsInput | string
    TEL?: StringFieldUpdateOperationsInput | string
    FILIERE?: StringFieldUpdateOperationsInput | string
    SEXE?: StringFieldUpdateOperationsInput | string
    DATE?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type etudiantUncheckedUpdateManyInput = {
    MATRICULEETUDIANT?: StringFieldUpdateOperationsInput | string
    NOMETUDIANT?: NullableStringFieldUpdateOperationsInput | string | null
    PRENOMETUDIANT?: NullableStringFieldUpdateOperationsInput | string | null
    ETABLISSEMENT?: NullableStringFieldUpdateOperationsInput | string | null
    VILLERESIDENCE?: NullableStringFieldUpdateOperationsInput | string | null
    PARCOURS?: NullableStringFieldUpdateOperationsInput | string | null
    NIVEAU?: NullableStringFieldUpdateOperationsInput | string | null
    EMAIL?: StringFieldUpdateOperationsInput | string
    TEL?: StringFieldUpdateOperationsInput | string
    FILIERE?: StringFieldUpdateOperationsInput | string
    SEXE?: StringFieldUpdateOperationsInput | string
    DATE?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type logs_actionsCreateInput = {
    user_email?: string | null
    user_name?: string | null
    action?: string | null
    methode_http?: string | null
    endpoint?: string | null
    requete_executee?: string | null
    ip_address?: string | null
    user_agent?: string | null
    status_code?: number | null
    horodatage?: Date | string | null
  }

  export type logs_actionsUncheckedCreateInput = {
    id?: number
    user_email?: string | null
    user_name?: string | null
    action?: string | null
    methode_http?: string | null
    endpoint?: string | null
    requete_executee?: string | null
    ip_address?: string | null
    user_agent?: string | null
    status_code?: number | null
    horodatage?: Date | string | null
  }

  export type logs_actionsUpdateInput = {
    user_email?: NullableStringFieldUpdateOperationsInput | string | null
    user_name?: NullableStringFieldUpdateOperationsInput | string | null
    action?: NullableStringFieldUpdateOperationsInput | string | null
    methode_http?: NullableStringFieldUpdateOperationsInput | string | null
    endpoint?: NullableStringFieldUpdateOperationsInput | string | null
    requete_executee?: NullableStringFieldUpdateOperationsInput | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    status_code?: NullableIntFieldUpdateOperationsInput | number | null
    horodatage?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type logs_actionsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_email?: NullableStringFieldUpdateOperationsInput | string | null
    user_name?: NullableStringFieldUpdateOperationsInput | string | null
    action?: NullableStringFieldUpdateOperationsInput | string | null
    methode_http?: NullableStringFieldUpdateOperationsInput | string | null
    endpoint?: NullableStringFieldUpdateOperationsInput | string | null
    requete_executee?: NullableStringFieldUpdateOperationsInput | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    status_code?: NullableIntFieldUpdateOperationsInput | number | null
    horodatage?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type logs_actionsCreateManyInput = {
    id?: number
    user_email?: string | null
    user_name?: string | null
    action?: string | null
    methode_http?: string | null
    endpoint?: string | null
    requete_executee?: string | null
    ip_address?: string | null
    user_agent?: string | null
    status_code?: number | null
    horodatage?: Date | string | null
  }

  export type logs_actionsUpdateManyMutationInput = {
    user_email?: NullableStringFieldUpdateOperationsInput | string | null
    user_name?: NullableStringFieldUpdateOperationsInput | string | null
    action?: NullableStringFieldUpdateOperationsInput | string | null
    methode_http?: NullableStringFieldUpdateOperationsInput | string | null
    endpoint?: NullableStringFieldUpdateOperationsInput | string | null
    requete_executee?: NullableStringFieldUpdateOperationsInput | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    status_code?: NullableIntFieldUpdateOperationsInput | number | null
    horodatage?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type logs_actionsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    user_email?: NullableStringFieldUpdateOperationsInput | string | null
    user_name?: NullableStringFieldUpdateOperationsInput | string | null
    action?: NullableStringFieldUpdateOperationsInput | string | null
    methode_http?: NullableStringFieldUpdateOperationsInput | string | null
    endpoint?: NullableStringFieldUpdateOperationsInput | string | null
    requete_executee?: NullableStringFieldUpdateOperationsInput | string | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    status_code?: NullableIntFieldUpdateOperationsInput | number | null
    horodatage?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type rapportCreateInput = {
    COMMENTAIRE: string
    THEME: string
    FICHIER: string
    DATE?: Date | string
    etudiant: etudiantCreateNestedOneWithoutRapportInput
  }

  export type rapportUncheckedCreateInput = {
    IDDOSSIER?: number
    MATRICULE: string
    COMMENTAIRE: string
    THEME: string
    FICHIER: string
    DATE?: Date | string
  }

  export type rapportUpdateInput = {
    COMMENTAIRE?: StringFieldUpdateOperationsInput | string
    THEME?: StringFieldUpdateOperationsInput | string
    FICHIER?: StringFieldUpdateOperationsInput | string
    DATE?: DateTimeFieldUpdateOperationsInput | Date | string
    etudiant?: etudiantUpdateOneRequiredWithoutRapportNestedInput
  }

  export type rapportUncheckedUpdateInput = {
    IDDOSSIER?: IntFieldUpdateOperationsInput | number
    MATRICULE?: StringFieldUpdateOperationsInput | string
    COMMENTAIRE?: StringFieldUpdateOperationsInput | string
    THEME?: StringFieldUpdateOperationsInput | string
    FICHIER?: StringFieldUpdateOperationsInput | string
    DATE?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type rapportCreateManyInput = {
    IDDOSSIER?: number
    MATRICULE: string
    COMMENTAIRE: string
    THEME: string
    FICHIER: string
    DATE?: Date | string
  }

  export type rapportUpdateManyMutationInput = {
    COMMENTAIRE?: StringFieldUpdateOperationsInput | string
    THEME?: StringFieldUpdateOperationsInput | string
    FICHIER?: StringFieldUpdateOperationsInput | string
    DATE?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type rapportUncheckedUpdateManyInput = {
    IDDOSSIER?: IntFieldUpdateOperationsInput | number
    MATRICULE?: StringFieldUpdateOperationsInput | string
    COMMENTAIRE?: StringFieldUpdateOperationsInput | string
    THEME?: StringFieldUpdateOperationsInput | string
    FICHIER?: StringFieldUpdateOperationsInput | string
    DATE?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type lettreAcceptationCreateInput = {
    COMMENTAIRE: string
    FICHIER: string
    DATEUPLOAD?: Date | string
    EMAILSENT?: boolean
    dossier: dossierCreateNestedOneWithoutLettreAcceptationInput
  }

  export type lettreAcceptationUncheckedCreateInput = {
    IDLETTRE?: number
    IDDOSSIER: number
    COMMENTAIRE: string
    FICHIER: string
    DATEUPLOAD?: Date | string
    EMAILSENT?: boolean
  }

  export type lettreAcceptationUpdateInput = {
    COMMENTAIRE?: StringFieldUpdateOperationsInput | string
    FICHIER?: StringFieldUpdateOperationsInput | string
    DATEUPLOAD?: DateTimeFieldUpdateOperationsInput | Date | string
    EMAILSENT?: BoolFieldUpdateOperationsInput | boolean
    dossier?: dossierUpdateOneRequiredWithoutLettreAcceptationNestedInput
  }

  export type lettreAcceptationUncheckedUpdateInput = {
    IDLETTRE?: IntFieldUpdateOperationsInput | number
    IDDOSSIER?: IntFieldUpdateOperationsInput | number
    COMMENTAIRE?: StringFieldUpdateOperationsInput | string
    FICHIER?: StringFieldUpdateOperationsInput | string
    DATEUPLOAD?: DateTimeFieldUpdateOperationsInput | Date | string
    EMAILSENT?: BoolFieldUpdateOperationsInput | boolean
  }

  export type lettreAcceptationCreateManyInput = {
    IDLETTRE?: number
    IDDOSSIER: number
    COMMENTAIRE: string
    FICHIER: string
    DATEUPLOAD?: Date | string
    EMAILSENT?: boolean
  }

  export type lettreAcceptationUpdateManyMutationInput = {
    COMMENTAIRE?: StringFieldUpdateOperationsInput | string
    FICHIER?: StringFieldUpdateOperationsInput | string
    DATEUPLOAD?: DateTimeFieldUpdateOperationsInput | Date | string
    EMAILSENT?: BoolFieldUpdateOperationsInput | boolean
  }

  export type lettreAcceptationUncheckedUpdateManyInput = {
    IDLETTRE?: IntFieldUpdateOperationsInput | number
    IDDOSSIER?: IntFieldUpdateOperationsInput | number
    COMMENTAIRE?: StringFieldUpdateOperationsInput | string
    FICHIER?: StringFieldUpdateOperationsInput | string
    DATEUPLOAD?: DateTimeFieldUpdateOperationsInput | Date | string
    EMAILSENT?: BoolFieldUpdateOperationsInput | boolean
  }

  export type structuresCreateInput = {
    NOMSTRUCTURE: string
    ABBREVIATION: string
    affectation?: affectationCreateNestedManyWithoutStructuresInput
    encadreur?: encadreurCreateNestedManyWithoutStructuresInput
    structures?: structuresCreateNestedOneWithoutOther_structuresInput
    other_structures?: structuresCreateNestedManyWithoutStructuresInput
  }

  export type structuresUncheckedCreateInput = {
    IDSTRUCTURE?: number
    NOMSTRUCTURE: string
    ABBREVIATION: string
    IDPARENT?: number | null
    affectation?: affectationUncheckedCreateNestedManyWithoutStructuresInput
    encadreur?: encadreurUncheckedCreateNestedManyWithoutStructuresInput
    other_structures?: structuresUncheckedCreateNestedManyWithoutStructuresInput
  }

  export type structuresUpdateInput = {
    NOMSTRUCTURE?: StringFieldUpdateOperationsInput | string
    ABBREVIATION?: StringFieldUpdateOperationsInput | string
    affectation?: affectationUpdateManyWithoutStructuresNestedInput
    encadreur?: encadreurUpdateManyWithoutStructuresNestedInput
    structures?: structuresUpdateOneWithoutOther_structuresNestedInput
    other_structures?: structuresUpdateManyWithoutStructuresNestedInput
  }

  export type structuresUncheckedUpdateInput = {
    IDSTRUCTURE?: IntFieldUpdateOperationsInput | number
    NOMSTRUCTURE?: StringFieldUpdateOperationsInput | string
    ABBREVIATION?: StringFieldUpdateOperationsInput | string
    IDPARENT?: NullableIntFieldUpdateOperationsInput | number | null
    affectation?: affectationUncheckedUpdateManyWithoutStructuresNestedInput
    encadreur?: encadreurUncheckedUpdateManyWithoutStructuresNestedInput
    other_structures?: structuresUncheckedUpdateManyWithoutStructuresNestedInput
  }

  export type structuresCreateManyInput = {
    IDSTRUCTURE?: number
    NOMSTRUCTURE: string
    ABBREVIATION: string
    IDPARENT?: number | null
  }

  export type structuresUpdateManyMutationInput = {
    NOMSTRUCTURE?: StringFieldUpdateOperationsInput | string
    ABBREVIATION?: StringFieldUpdateOperationsInput | string
  }

  export type structuresUncheckedUpdateManyInput = {
    IDSTRUCTURE?: IntFieldUpdateOperationsInput | number
    NOMSTRUCTURE?: StringFieldUpdateOperationsInput | string
    ABBREVIATION?: StringFieldUpdateOperationsInput | string
    IDPARENT?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type AffectationListRelationFilter = {
    every?: affectationWhereInput
    some?: affectationWhereInput
    none?: affectationWhereInput
  }

  export type affectationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type administrateurOrderByRelevanceInput = {
    fields: administrateurOrderByRelevanceFieldEnum | administrateurOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type administrateurCountOrderByAggregateInput = {
    IDADMIN?: SortOrder
    MATRICULEADMIN?: SortOrder
    NOMADMIN?: SortOrder
    PRENOMADMIN?: SortOrder
    EMAILADMIN?: SortOrder
    PASSWARDADMIN?: SortOrder
    PHOTOADMIN?: SortOrder
  }

  export type administrateurAvgOrderByAggregateInput = {
    IDADMIN?: SortOrder
  }

  export type administrateurMaxOrderByAggregateInput = {
    IDADMIN?: SortOrder
    MATRICULEADMIN?: SortOrder
    NOMADMIN?: SortOrder
    PRENOMADMIN?: SortOrder
    EMAILADMIN?: SortOrder
    PASSWARDADMIN?: SortOrder
    PHOTOADMIN?: SortOrder
  }

  export type administrateurMinOrderByAggregateInput = {
    IDADMIN?: SortOrder
    MATRICULEADMIN?: SortOrder
    NOMADMIN?: SortOrder
    PRENOMADMIN?: SortOrder
    EMAILADMIN?: SortOrder
    PASSWARDADMIN?: SortOrder
    PHOTOADMIN?: SortOrder
  }

  export type administrateurSumOrderByAggregateInput = {
    IDADMIN?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type AdministrateurScalarRelationFilter = {
    is?: administrateurWhereInput
    isNot?: administrateurWhereInput
  }

  export type EncadreurScalarRelationFilter = {
    is?: encadreurWhereInput
    isNot?: encadreurWhereInput
  }

  export type DossierScalarRelationFilter = {
    is?: dossierWhereInput
    isNot?: dossierWhereInput
  }

  export type StructuresScalarRelationFilter = {
    is?: structuresWhereInput
    isNot?: structuresWhereInput
  }

  export type affectationIDADMINIDENCADREURIDDOSSIERIDSTRUCTURECompoundUniqueInput = {
    IDADMIN: number
    IDENCADREUR: number
    IDDOSSIER: number
    IDSTRUCTURE: number
  }

  export type affectationCountOrderByAggregateInput = {
    IDADMIN?: SortOrder
    IDENCADREUR?: SortOrder
    IDDOSSIER?: SortOrder
    IDSTRUCTURE?: SortOrder
  }

  export type affectationAvgOrderByAggregateInput = {
    IDADMIN?: SortOrder
    IDENCADREUR?: SortOrder
    IDDOSSIER?: SortOrder
    IDSTRUCTURE?: SortOrder
  }

  export type affectationMaxOrderByAggregateInput = {
    IDADMIN?: SortOrder
    IDENCADREUR?: SortOrder
    IDDOSSIER?: SortOrder
    IDSTRUCTURE?: SortOrder
  }

  export type affectationMinOrderByAggregateInput = {
    IDADMIN?: SortOrder
    IDENCADREUR?: SortOrder
    IDDOSSIER?: SortOrder
    IDSTRUCTURE?: SortOrder
  }

  export type affectationSumOrderByAggregateInput = {
    IDADMIN?: SortOrder
    IDENCADREUR?: SortOrder
    IDDOSSIER?: SortOrder
    IDSTRUCTURE?: SortOrder
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type EtudiantNullableScalarRelationFilter = {
    is?: etudiantWhereInput | null
    isNot?: etudiantWhereInput | null
  }

  export type LettreAcceptationListRelationFilter = {
    every?: lettreAcceptationWhereInput
    some?: lettreAcceptationWhereInput
    none?: lettreAcceptationWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type lettreAcceptationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type dossierOrderByRelevanceInput = {
    fields: dossierOrderByRelevanceFieldEnum | dossierOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type dossierCountOrderByAggregateInput = {
    IDDOSSIER?: SortOrder
    MATRICULEETUDIANT?: SortOrder
    DATEDEBUTDESEANCE?: SortOrder
    DATEFINDESEANCE?: SortOrder
    ETAT?: SortOrder
    THEME?: SortOrder
    CNI?: SortOrder
    CERTIFICAT?: SortOrder
    LETTREMOTIVATION?: SortOrder
    LETTRERECOMMENDATION?: SortOrder
    PHOTOPROFIL?: SortOrder
    CV?: SortOrder
    CAHIERDECHARGE?: SortOrder
    DATEDEPOT?: SortOrder
    EMAILSENT?: SortOrder
  }

  export type dossierAvgOrderByAggregateInput = {
    IDDOSSIER?: SortOrder
  }

  export type dossierMaxOrderByAggregateInput = {
    IDDOSSIER?: SortOrder
    MATRICULEETUDIANT?: SortOrder
    DATEDEBUTDESEANCE?: SortOrder
    DATEFINDESEANCE?: SortOrder
    ETAT?: SortOrder
    THEME?: SortOrder
    CNI?: SortOrder
    CERTIFICAT?: SortOrder
    LETTREMOTIVATION?: SortOrder
    LETTRERECOMMENDATION?: SortOrder
    PHOTOPROFIL?: SortOrder
    CV?: SortOrder
    CAHIERDECHARGE?: SortOrder
    DATEDEPOT?: SortOrder
    EMAILSENT?: SortOrder
  }

  export type dossierMinOrderByAggregateInput = {
    IDDOSSIER?: SortOrder
    MATRICULEETUDIANT?: SortOrder
    DATEDEBUTDESEANCE?: SortOrder
    DATEFINDESEANCE?: SortOrder
    ETAT?: SortOrder
    THEME?: SortOrder
    CNI?: SortOrder
    CERTIFICAT?: SortOrder
    LETTREMOTIVATION?: SortOrder
    LETTRERECOMMENDATION?: SortOrder
    PHOTOPROFIL?: SortOrder
    CV?: SortOrder
    CAHIERDECHARGE?: SortOrder
    DATEDEPOT?: SortOrder
    EMAILSENT?: SortOrder
  }

  export type dossierSumOrderByAggregateInput = {
    IDDOSSIER?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type StructuresNullableScalarRelationFilter = {
    is?: structuresWhereInput | null
    isNot?: structuresWhereInput | null
  }

  export type encadreurOrderByRelevanceInput = {
    fields: encadreurOrderByRelevanceFieldEnum | encadreurOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type encadreurCountOrderByAggregateInput = {
    IDENCADREUR?: SortOrder
    MATRICULEENCADREUR?: SortOrder
    NOMENCADREUR?: SortOrder
    PRENOMENCADREUR?: SortOrder
    IDSTRUCTURE?: SortOrder
    POSTE?: SortOrder
  }

  export type encadreurAvgOrderByAggregateInput = {
    IDENCADREUR?: SortOrder
    IDSTRUCTURE?: SortOrder
  }

  export type encadreurMaxOrderByAggregateInput = {
    IDENCADREUR?: SortOrder
    MATRICULEENCADREUR?: SortOrder
    NOMENCADREUR?: SortOrder
    PRENOMENCADREUR?: SortOrder
    IDSTRUCTURE?: SortOrder
    POSTE?: SortOrder
  }

  export type encadreurMinOrderByAggregateInput = {
    IDENCADREUR?: SortOrder
    MATRICULEENCADREUR?: SortOrder
    NOMENCADREUR?: SortOrder
    PRENOMENCADREUR?: SortOrder
    IDSTRUCTURE?: SortOrder
    POSTE?: SortOrder
  }

  export type encadreurSumOrderByAggregateInput = {
    IDENCADREUR?: SortOrder
    IDSTRUCTURE?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DossierListRelationFilter = {
    every?: dossierWhereInput
    some?: dossierWhereInput
    none?: dossierWhereInput
  }

  export type RapportListRelationFilter = {
    every?: rapportWhereInput
    some?: rapportWhereInput
    none?: rapportWhereInput
  }

  export type dossierOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type rapportOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type etudiantOrderByRelevanceInput = {
    fields: etudiantOrderByRelevanceFieldEnum | etudiantOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type etudiantCountOrderByAggregateInput = {
    MATRICULEETUDIANT?: SortOrder
    NOMETUDIANT?: SortOrder
    PRENOMETUDIANT?: SortOrder
    ETABLISSEMENT?: SortOrder
    VILLERESIDENCE?: SortOrder
    PARCOURS?: SortOrder
    NIVEAU?: SortOrder
    EMAIL?: SortOrder
    TEL?: SortOrder
    FILIERE?: SortOrder
    SEXE?: SortOrder
    DATE?: SortOrder
  }

  export type etudiantMaxOrderByAggregateInput = {
    MATRICULEETUDIANT?: SortOrder
    NOMETUDIANT?: SortOrder
    PRENOMETUDIANT?: SortOrder
    ETABLISSEMENT?: SortOrder
    VILLERESIDENCE?: SortOrder
    PARCOURS?: SortOrder
    NIVEAU?: SortOrder
    EMAIL?: SortOrder
    TEL?: SortOrder
    FILIERE?: SortOrder
    SEXE?: SortOrder
    DATE?: SortOrder
  }

  export type etudiantMinOrderByAggregateInput = {
    MATRICULEETUDIANT?: SortOrder
    NOMETUDIANT?: SortOrder
    PRENOMETUDIANT?: SortOrder
    ETABLISSEMENT?: SortOrder
    VILLERESIDENCE?: SortOrder
    PARCOURS?: SortOrder
    NIVEAU?: SortOrder
    EMAIL?: SortOrder
    TEL?: SortOrder
    FILIERE?: SortOrder
    SEXE?: SortOrder
    DATE?: SortOrder
  }

  export type logs_actionsOrderByRelevanceInput = {
    fields: logs_actionsOrderByRelevanceFieldEnum | logs_actionsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type logs_actionsCountOrderByAggregateInput = {
    id?: SortOrder
    user_email?: SortOrder
    user_name?: SortOrder
    action?: SortOrder
    methode_http?: SortOrder
    endpoint?: SortOrder
    requete_executee?: SortOrder
    ip_address?: SortOrder
    user_agent?: SortOrder
    status_code?: SortOrder
    horodatage?: SortOrder
  }

  export type logs_actionsAvgOrderByAggregateInput = {
    id?: SortOrder
    status_code?: SortOrder
  }

  export type logs_actionsMaxOrderByAggregateInput = {
    id?: SortOrder
    user_email?: SortOrder
    user_name?: SortOrder
    action?: SortOrder
    methode_http?: SortOrder
    endpoint?: SortOrder
    requete_executee?: SortOrder
    ip_address?: SortOrder
    user_agent?: SortOrder
    status_code?: SortOrder
    horodatage?: SortOrder
  }

  export type logs_actionsMinOrderByAggregateInput = {
    id?: SortOrder
    user_email?: SortOrder
    user_name?: SortOrder
    action?: SortOrder
    methode_http?: SortOrder
    endpoint?: SortOrder
    requete_executee?: SortOrder
    ip_address?: SortOrder
    user_agent?: SortOrder
    status_code?: SortOrder
    horodatage?: SortOrder
  }

  export type logs_actionsSumOrderByAggregateInput = {
    id?: SortOrder
    status_code?: SortOrder
  }

  export type EtudiantScalarRelationFilter = {
    is?: etudiantWhereInput
    isNot?: etudiantWhereInput
  }

  export type rapportOrderByRelevanceInput = {
    fields: rapportOrderByRelevanceFieldEnum | rapportOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type rapportCountOrderByAggregateInput = {
    IDDOSSIER?: SortOrder
    MATRICULE?: SortOrder
    COMMENTAIRE?: SortOrder
    THEME?: SortOrder
    FICHIER?: SortOrder
    DATE?: SortOrder
  }

  export type rapportAvgOrderByAggregateInput = {
    IDDOSSIER?: SortOrder
  }

  export type rapportMaxOrderByAggregateInput = {
    IDDOSSIER?: SortOrder
    MATRICULE?: SortOrder
    COMMENTAIRE?: SortOrder
    THEME?: SortOrder
    FICHIER?: SortOrder
    DATE?: SortOrder
  }

  export type rapportMinOrderByAggregateInput = {
    IDDOSSIER?: SortOrder
    MATRICULE?: SortOrder
    COMMENTAIRE?: SortOrder
    THEME?: SortOrder
    FICHIER?: SortOrder
    DATE?: SortOrder
  }

  export type rapportSumOrderByAggregateInput = {
    IDDOSSIER?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type lettreAcceptationOrderByRelevanceInput = {
    fields: lettreAcceptationOrderByRelevanceFieldEnum | lettreAcceptationOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type lettreAcceptationCountOrderByAggregateInput = {
    IDLETTRE?: SortOrder
    IDDOSSIER?: SortOrder
    COMMENTAIRE?: SortOrder
    FICHIER?: SortOrder
    DATEUPLOAD?: SortOrder
    EMAILSENT?: SortOrder
  }

  export type lettreAcceptationAvgOrderByAggregateInput = {
    IDLETTRE?: SortOrder
    IDDOSSIER?: SortOrder
  }

  export type lettreAcceptationMaxOrderByAggregateInput = {
    IDLETTRE?: SortOrder
    IDDOSSIER?: SortOrder
    COMMENTAIRE?: SortOrder
    FICHIER?: SortOrder
    DATEUPLOAD?: SortOrder
    EMAILSENT?: SortOrder
  }

  export type lettreAcceptationMinOrderByAggregateInput = {
    IDLETTRE?: SortOrder
    IDDOSSIER?: SortOrder
    COMMENTAIRE?: SortOrder
    FICHIER?: SortOrder
    DATEUPLOAD?: SortOrder
    EMAILSENT?: SortOrder
  }

  export type lettreAcceptationSumOrderByAggregateInput = {
    IDLETTRE?: SortOrder
    IDDOSSIER?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type EncadreurListRelationFilter = {
    every?: encadreurWhereInput
    some?: encadreurWhereInput
    none?: encadreurWhereInput
  }

  export type StructuresListRelationFilter = {
    every?: structuresWhereInput
    some?: structuresWhereInput
    none?: structuresWhereInput
  }

  export type encadreurOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type structuresOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type structuresOrderByRelevanceInput = {
    fields: structuresOrderByRelevanceFieldEnum | structuresOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type structuresCountOrderByAggregateInput = {
    IDSTRUCTURE?: SortOrder
    NOMSTRUCTURE?: SortOrder
    ABBREVIATION?: SortOrder
    IDPARENT?: SortOrder
  }

  export type structuresAvgOrderByAggregateInput = {
    IDSTRUCTURE?: SortOrder
    IDPARENT?: SortOrder
  }

  export type structuresMaxOrderByAggregateInput = {
    IDSTRUCTURE?: SortOrder
    NOMSTRUCTURE?: SortOrder
    ABBREVIATION?: SortOrder
    IDPARENT?: SortOrder
  }

  export type structuresMinOrderByAggregateInput = {
    IDSTRUCTURE?: SortOrder
    NOMSTRUCTURE?: SortOrder
    ABBREVIATION?: SortOrder
    IDPARENT?: SortOrder
  }

  export type structuresSumOrderByAggregateInput = {
    IDSTRUCTURE?: SortOrder
    IDPARENT?: SortOrder
  }

  export type affectationCreateNestedManyWithoutAdministrateurInput = {
    create?: XOR<affectationCreateWithoutAdministrateurInput, affectationUncheckedCreateWithoutAdministrateurInput> | affectationCreateWithoutAdministrateurInput[] | affectationUncheckedCreateWithoutAdministrateurInput[]
    connectOrCreate?: affectationCreateOrConnectWithoutAdministrateurInput | affectationCreateOrConnectWithoutAdministrateurInput[]
    createMany?: affectationCreateManyAdministrateurInputEnvelope
    connect?: affectationWhereUniqueInput | affectationWhereUniqueInput[]
  }

  export type affectationUncheckedCreateNestedManyWithoutAdministrateurInput = {
    create?: XOR<affectationCreateWithoutAdministrateurInput, affectationUncheckedCreateWithoutAdministrateurInput> | affectationCreateWithoutAdministrateurInput[] | affectationUncheckedCreateWithoutAdministrateurInput[]
    connectOrCreate?: affectationCreateOrConnectWithoutAdministrateurInput | affectationCreateOrConnectWithoutAdministrateurInput[]
    createMany?: affectationCreateManyAdministrateurInputEnvelope
    connect?: affectationWhereUniqueInput | affectationWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type affectationUpdateManyWithoutAdministrateurNestedInput = {
    create?: XOR<affectationCreateWithoutAdministrateurInput, affectationUncheckedCreateWithoutAdministrateurInput> | affectationCreateWithoutAdministrateurInput[] | affectationUncheckedCreateWithoutAdministrateurInput[]
    connectOrCreate?: affectationCreateOrConnectWithoutAdministrateurInput | affectationCreateOrConnectWithoutAdministrateurInput[]
    upsert?: affectationUpsertWithWhereUniqueWithoutAdministrateurInput | affectationUpsertWithWhereUniqueWithoutAdministrateurInput[]
    createMany?: affectationCreateManyAdministrateurInputEnvelope
    set?: affectationWhereUniqueInput | affectationWhereUniqueInput[]
    disconnect?: affectationWhereUniqueInput | affectationWhereUniqueInput[]
    delete?: affectationWhereUniqueInput | affectationWhereUniqueInput[]
    connect?: affectationWhereUniqueInput | affectationWhereUniqueInput[]
    update?: affectationUpdateWithWhereUniqueWithoutAdministrateurInput | affectationUpdateWithWhereUniqueWithoutAdministrateurInput[]
    updateMany?: affectationUpdateManyWithWhereWithoutAdministrateurInput | affectationUpdateManyWithWhereWithoutAdministrateurInput[]
    deleteMany?: affectationScalarWhereInput | affectationScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type affectationUncheckedUpdateManyWithoutAdministrateurNestedInput = {
    create?: XOR<affectationCreateWithoutAdministrateurInput, affectationUncheckedCreateWithoutAdministrateurInput> | affectationCreateWithoutAdministrateurInput[] | affectationUncheckedCreateWithoutAdministrateurInput[]
    connectOrCreate?: affectationCreateOrConnectWithoutAdministrateurInput | affectationCreateOrConnectWithoutAdministrateurInput[]
    upsert?: affectationUpsertWithWhereUniqueWithoutAdministrateurInput | affectationUpsertWithWhereUniqueWithoutAdministrateurInput[]
    createMany?: affectationCreateManyAdministrateurInputEnvelope
    set?: affectationWhereUniqueInput | affectationWhereUniqueInput[]
    disconnect?: affectationWhereUniqueInput | affectationWhereUniqueInput[]
    delete?: affectationWhereUniqueInput | affectationWhereUniqueInput[]
    connect?: affectationWhereUniqueInput | affectationWhereUniqueInput[]
    update?: affectationUpdateWithWhereUniqueWithoutAdministrateurInput | affectationUpdateWithWhereUniqueWithoutAdministrateurInput[]
    updateMany?: affectationUpdateManyWithWhereWithoutAdministrateurInput | affectationUpdateManyWithWhereWithoutAdministrateurInput[]
    deleteMany?: affectationScalarWhereInput | affectationScalarWhereInput[]
  }

  export type administrateurCreateNestedOneWithoutAffectationInput = {
    create?: XOR<administrateurCreateWithoutAffectationInput, administrateurUncheckedCreateWithoutAffectationInput>
    connectOrCreate?: administrateurCreateOrConnectWithoutAffectationInput
    connect?: administrateurWhereUniqueInput
  }

  export type encadreurCreateNestedOneWithoutAffectationInput = {
    create?: XOR<encadreurCreateWithoutAffectationInput, encadreurUncheckedCreateWithoutAffectationInput>
    connectOrCreate?: encadreurCreateOrConnectWithoutAffectationInput
    connect?: encadreurWhereUniqueInput
  }

  export type dossierCreateNestedOneWithoutAffectationInput = {
    create?: XOR<dossierCreateWithoutAffectationInput, dossierUncheckedCreateWithoutAffectationInput>
    connectOrCreate?: dossierCreateOrConnectWithoutAffectationInput
    connect?: dossierWhereUniqueInput
  }

  export type structuresCreateNestedOneWithoutAffectationInput = {
    create?: XOR<structuresCreateWithoutAffectationInput, structuresUncheckedCreateWithoutAffectationInput>
    connectOrCreate?: structuresCreateOrConnectWithoutAffectationInput
    connect?: structuresWhereUniqueInput
  }

  export type administrateurUpdateOneRequiredWithoutAffectationNestedInput = {
    create?: XOR<administrateurCreateWithoutAffectationInput, administrateurUncheckedCreateWithoutAffectationInput>
    connectOrCreate?: administrateurCreateOrConnectWithoutAffectationInput
    upsert?: administrateurUpsertWithoutAffectationInput
    connect?: administrateurWhereUniqueInput
    update?: XOR<XOR<administrateurUpdateToOneWithWhereWithoutAffectationInput, administrateurUpdateWithoutAffectationInput>, administrateurUncheckedUpdateWithoutAffectationInput>
  }

  export type encadreurUpdateOneRequiredWithoutAffectationNestedInput = {
    create?: XOR<encadreurCreateWithoutAffectationInput, encadreurUncheckedCreateWithoutAffectationInput>
    connectOrCreate?: encadreurCreateOrConnectWithoutAffectationInput
    upsert?: encadreurUpsertWithoutAffectationInput
    connect?: encadreurWhereUniqueInput
    update?: XOR<XOR<encadreurUpdateToOneWithWhereWithoutAffectationInput, encadreurUpdateWithoutAffectationInput>, encadreurUncheckedUpdateWithoutAffectationInput>
  }

  export type dossierUpdateOneRequiredWithoutAffectationNestedInput = {
    create?: XOR<dossierCreateWithoutAffectationInput, dossierUncheckedCreateWithoutAffectationInput>
    connectOrCreate?: dossierCreateOrConnectWithoutAffectationInput
    upsert?: dossierUpsertWithoutAffectationInput
    connect?: dossierWhereUniqueInput
    update?: XOR<XOR<dossierUpdateToOneWithWhereWithoutAffectationInput, dossierUpdateWithoutAffectationInput>, dossierUncheckedUpdateWithoutAffectationInput>
  }

  export type structuresUpdateOneRequiredWithoutAffectationNestedInput = {
    create?: XOR<structuresCreateWithoutAffectationInput, structuresUncheckedCreateWithoutAffectationInput>
    connectOrCreate?: structuresCreateOrConnectWithoutAffectationInput
    upsert?: structuresUpsertWithoutAffectationInput
    connect?: structuresWhereUniqueInput
    update?: XOR<XOR<structuresUpdateToOneWithWhereWithoutAffectationInput, structuresUpdateWithoutAffectationInput>, structuresUncheckedUpdateWithoutAffectationInput>
  }

  export type affectationCreateNestedManyWithoutDossierInput = {
    create?: XOR<affectationCreateWithoutDossierInput, affectationUncheckedCreateWithoutDossierInput> | affectationCreateWithoutDossierInput[] | affectationUncheckedCreateWithoutDossierInput[]
    connectOrCreate?: affectationCreateOrConnectWithoutDossierInput | affectationCreateOrConnectWithoutDossierInput[]
    createMany?: affectationCreateManyDossierInputEnvelope
    connect?: affectationWhereUniqueInput | affectationWhereUniqueInput[]
  }

  export type etudiantCreateNestedOneWithoutDossierInput = {
    create?: XOR<etudiantCreateWithoutDossierInput, etudiantUncheckedCreateWithoutDossierInput>
    connectOrCreate?: etudiantCreateOrConnectWithoutDossierInput
    connect?: etudiantWhereUniqueInput
  }

  export type lettreAcceptationCreateNestedManyWithoutDossierInput = {
    create?: XOR<lettreAcceptationCreateWithoutDossierInput, lettreAcceptationUncheckedCreateWithoutDossierInput> | lettreAcceptationCreateWithoutDossierInput[] | lettreAcceptationUncheckedCreateWithoutDossierInput[]
    connectOrCreate?: lettreAcceptationCreateOrConnectWithoutDossierInput | lettreAcceptationCreateOrConnectWithoutDossierInput[]
    createMany?: lettreAcceptationCreateManyDossierInputEnvelope
    connect?: lettreAcceptationWhereUniqueInput | lettreAcceptationWhereUniqueInput[]
  }

  export type affectationUncheckedCreateNestedManyWithoutDossierInput = {
    create?: XOR<affectationCreateWithoutDossierInput, affectationUncheckedCreateWithoutDossierInput> | affectationCreateWithoutDossierInput[] | affectationUncheckedCreateWithoutDossierInput[]
    connectOrCreate?: affectationCreateOrConnectWithoutDossierInput | affectationCreateOrConnectWithoutDossierInput[]
    createMany?: affectationCreateManyDossierInputEnvelope
    connect?: affectationWhereUniqueInput | affectationWhereUniqueInput[]
  }

  export type lettreAcceptationUncheckedCreateNestedManyWithoutDossierInput = {
    create?: XOR<lettreAcceptationCreateWithoutDossierInput, lettreAcceptationUncheckedCreateWithoutDossierInput> | lettreAcceptationCreateWithoutDossierInput[] | lettreAcceptationUncheckedCreateWithoutDossierInput[]
    connectOrCreate?: lettreAcceptationCreateOrConnectWithoutDossierInput | lettreAcceptationCreateOrConnectWithoutDossierInput[]
    createMany?: lettreAcceptationCreateManyDossierInputEnvelope
    connect?: lettreAcceptationWhereUniqueInput | lettreAcceptationWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type affectationUpdateManyWithoutDossierNestedInput = {
    create?: XOR<affectationCreateWithoutDossierInput, affectationUncheckedCreateWithoutDossierInput> | affectationCreateWithoutDossierInput[] | affectationUncheckedCreateWithoutDossierInput[]
    connectOrCreate?: affectationCreateOrConnectWithoutDossierInput | affectationCreateOrConnectWithoutDossierInput[]
    upsert?: affectationUpsertWithWhereUniqueWithoutDossierInput | affectationUpsertWithWhereUniqueWithoutDossierInput[]
    createMany?: affectationCreateManyDossierInputEnvelope
    set?: affectationWhereUniqueInput | affectationWhereUniqueInput[]
    disconnect?: affectationWhereUniqueInput | affectationWhereUniqueInput[]
    delete?: affectationWhereUniqueInput | affectationWhereUniqueInput[]
    connect?: affectationWhereUniqueInput | affectationWhereUniqueInput[]
    update?: affectationUpdateWithWhereUniqueWithoutDossierInput | affectationUpdateWithWhereUniqueWithoutDossierInput[]
    updateMany?: affectationUpdateManyWithWhereWithoutDossierInput | affectationUpdateManyWithWhereWithoutDossierInput[]
    deleteMany?: affectationScalarWhereInput | affectationScalarWhereInput[]
  }

  export type etudiantUpdateOneWithoutDossierNestedInput = {
    create?: XOR<etudiantCreateWithoutDossierInput, etudiantUncheckedCreateWithoutDossierInput>
    connectOrCreate?: etudiantCreateOrConnectWithoutDossierInput
    upsert?: etudiantUpsertWithoutDossierInput
    disconnect?: etudiantWhereInput | boolean
    delete?: etudiantWhereInput | boolean
    connect?: etudiantWhereUniqueInput
    update?: XOR<XOR<etudiantUpdateToOneWithWhereWithoutDossierInput, etudiantUpdateWithoutDossierInput>, etudiantUncheckedUpdateWithoutDossierInput>
  }

  export type lettreAcceptationUpdateManyWithoutDossierNestedInput = {
    create?: XOR<lettreAcceptationCreateWithoutDossierInput, lettreAcceptationUncheckedCreateWithoutDossierInput> | lettreAcceptationCreateWithoutDossierInput[] | lettreAcceptationUncheckedCreateWithoutDossierInput[]
    connectOrCreate?: lettreAcceptationCreateOrConnectWithoutDossierInput | lettreAcceptationCreateOrConnectWithoutDossierInput[]
    upsert?: lettreAcceptationUpsertWithWhereUniqueWithoutDossierInput | lettreAcceptationUpsertWithWhereUniqueWithoutDossierInput[]
    createMany?: lettreAcceptationCreateManyDossierInputEnvelope
    set?: lettreAcceptationWhereUniqueInput | lettreAcceptationWhereUniqueInput[]
    disconnect?: lettreAcceptationWhereUniqueInput | lettreAcceptationWhereUniqueInput[]
    delete?: lettreAcceptationWhereUniqueInput | lettreAcceptationWhereUniqueInput[]
    connect?: lettreAcceptationWhereUniqueInput | lettreAcceptationWhereUniqueInput[]
    update?: lettreAcceptationUpdateWithWhereUniqueWithoutDossierInput | lettreAcceptationUpdateWithWhereUniqueWithoutDossierInput[]
    updateMany?: lettreAcceptationUpdateManyWithWhereWithoutDossierInput | lettreAcceptationUpdateManyWithWhereWithoutDossierInput[]
    deleteMany?: lettreAcceptationScalarWhereInput | lettreAcceptationScalarWhereInput[]
  }

  export type affectationUncheckedUpdateManyWithoutDossierNestedInput = {
    create?: XOR<affectationCreateWithoutDossierInput, affectationUncheckedCreateWithoutDossierInput> | affectationCreateWithoutDossierInput[] | affectationUncheckedCreateWithoutDossierInput[]
    connectOrCreate?: affectationCreateOrConnectWithoutDossierInput | affectationCreateOrConnectWithoutDossierInput[]
    upsert?: affectationUpsertWithWhereUniqueWithoutDossierInput | affectationUpsertWithWhereUniqueWithoutDossierInput[]
    createMany?: affectationCreateManyDossierInputEnvelope
    set?: affectationWhereUniqueInput | affectationWhereUniqueInput[]
    disconnect?: affectationWhereUniqueInput | affectationWhereUniqueInput[]
    delete?: affectationWhereUniqueInput | affectationWhereUniqueInput[]
    connect?: affectationWhereUniqueInput | affectationWhereUniqueInput[]
    update?: affectationUpdateWithWhereUniqueWithoutDossierInput | affectationUpdateWithWhereUniqueWithoutDossierInput[]
    updateMany?: affectationUpdateManyWithWhereWithoutDossierInput | affectationUpdateManyWithWhereWithoutDossierInput[]
    deleteMany?: affectationScalarWhereInput | affectationScalarWhereInput[]
  }

  export type lettreAcceptationUncheckedUpdateManyWithoutDossierNestedInput = {
    create?: XOR<lettreAcceptationCreateWithoutDossierInput, lettreAcceptationUncheckedCreateWithoutDossierInput> | lettreAcceptationCreateWithoutDossierInput[] | lettreAcceptationUncheckedCreateWithoutDossierInput[]
    connectOrCreate?: lettreAcceptationCreateOrConnectWithoutDossierInput | lettreAcceptationCreateOrConnectWithoutDossierInput[]
    upsert?: lettreAcceptationUpsertWithWhereUniqueWithoutDossierInput | lettreAcceptationUpsertWithWhereUniqueWithoutDossierInput[]
    createMany?: lettreAcceptationCreateManyDossierInputEnvelope
    set?: lettreAcceptationWhereUniqueInput | lettreAcceptationWhereUniqueInput[]
    disconnect?: lettreAcceptationWhereUniqueInput | lettreAcceptationWhereUniqueInput[]
    delete?: lettreAcceptationWhereUniqueInput | lettreAcceptationWhereUniqueInput[]
    connect?: lettreAcceptationWhereUniqueInput | lettreAcceptationWhereUniqueInput[]
    update?: lettreAcceptationUpdateWithWhereUniqueWithoutDossierInput | lettreAcceptationUpdateWithWhereUniqueWithoutDossierInput[]
    updateMany?: lettreAcceptationUpdateManyWithWhereWithoutDossierInput | lettreAcceptationUpdateManyWithWhereWithoutDossierInput[]
    deleteMany?: lettreAcceptationScalarWhereInput | lettreAcceptationScalarWhereInput[]
  }

  export type affectationCreateNestedManyWithoutEncadreurInput = {
    create?: XOR<affectationCreateWithoutEncadreurInput, affectationUncheckedCreateWithoutEncadreurInput> | affectationCreateWithoutEncadreurInput[] | affectationUncheckedCreateWithoutEncadreurInput[]
    connectOrCreate?: affectationCreateOrConnectWithoutEncadreurInput | affectationCreateOrConnectWithoutEncadreurInput[]
    createMany?: affectationCreateManyEncadreurInputEnvelope
    connect?: affectationWhereUniqueInput | affectationWhereUniqueInput[]
  }

  export type structuresCreateNestedOneWithoutEncadreurInput = {
    create?: XOR<structuresCreateWithoutEncadreurInput, structuresUncheckedCreateWithoutEncadreurInput>
    connectOrCreate?: structuresCreateOrConnectWithoutEncadreurInput
    connect?: structuresWhereUniqueInput
  }

  export type affectationUncheckedCreateNestedManyWithoutEncadreurInput = {
    create?: XOR<affectationCreateWithoutEncadreurInput, affectationUncheckedCreateWithoutEncadreurInput> | affectationCreateWithoutEncadreurInput[] | affectationUncheckedCreateWithoutEncadreurInput[]
    connectOrCreate?: affectationCreateOrConnectWithoutEncadreurInput | affectationCreateOrConnectWithoutEncadreurInput[]
    createMany?: affectationCreateManyEncadreurInputEnvelope
    connect?: affectationWhereUniqueInput | affectationWhereUniqueInput[]
  }

  export type affectationUpdateManyWithoutEncadreurNestedInput = {
    create?: XOR<affectationCreateWithoutEncadreurInput, affectationUncheckedCreateWithoutEncadreurInput> | affectationCreateWithoutEncadreurInput[] | affectationUncheckedCreateWithoutEncadreurInput[]
    connectOrCreate?: affectationCreateOrConnectWithoutEncadreurInput | affectationCreateOrConnectWithoutEncadreurInput[]
    upsert?: affectationUpsertWithWhereUniqueWithoutEncadreurInput | affectationUpsertWithWhereUniqueWithoutEncadreurInput[]
    createMany?: affectationCreateManyEncadreurInputEnvelope
    set?: affectationWhereUniqueInput | affectationWhereUniqueInput[]
    disconnect?: affectationWhereUniqueInput | affectationWhereUniqueInput[]
    delete?: affectationWhereUniqueInput | affectationWhereUniqueInput[]
    connect?: affectationWhereUniqueInput | affectationWhereUniqueInput[]
    update?: affectationUpdateWithWhereUniqueWithoutEncadreurInput | affectationUpdateWithWhereUniqueWithoutEncadreurInput[]
    updateMany?: affectationUpdateManyWithWhereWithoutEncadreurInput | affectationUpdateManyWithWhereWithoutEncadreurInput[]
    deleteMany?: affectationScalarWhereInput | affectationScalarWhereInput[]
  }

  export type structuresUpdateOneWithoutEncadreurNestedInput = {
    create?: XOR<structuresCreateWithoutEncadreurInput, structuresUncheckedCreateWithoutEncadreurInput>
    connectOrCreate?: structuresCreateOrConnectWithoutEncadreurInput
    upsert?: structuresUpsertWithoutEncadreurInput
    disconnect?: structuresWhereInput | boolean
    delete?: structuresWhereInput | boolean
    connect?: structuresWhereUniqueInput
    update?: XOR<XOR<structuresUpdateToOneWithWhereWithoutEncadreurInput, structuresUpdateWithoutEncadreurInput>, structuresUncheckedUpdateWithoutEncadreurInput>
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type affectationUncheckedUpdateManyWithoutEncadreurNestedInput = {
    create?: XOR<affectationCreateWithoutEncadreurInput, affectationUncheckedCreateWithoutEncadreurInput> | affectationCreateWithoutEncadreurInput[] | affectationUncheckedCreateWithoutEncadreurInput[]
    connectOrCreate?: affectationCreateOrConnectWithoutEncadreurInput | affectationCreateOrConnectWithoutEncadreurInput[]
    upsert?: affectationUpsertWithWhereUniqueWithoutEncadreurInput | affectationUpsertWithWhereUniqueWithoutEncadreurInput[]
    createMany?: affectationCreateManyEncadreurInputEnvelope
    set?: affectationWhereUniqueInput | affectationWhereUniqueInput[]
    disconnect?: affectationWhereUniqueInput | affectationWhereUniqueInput[]
    delete?: affectationWhereUniqueInput | affectationWhereUniqueInput[]
    connect?: affectationWhereUniqueInput | affectationWhereUniqueInput[]
    update?: affectationUpdateWithWhereUniqueWithoutEncadreurInput | affectationUpdateWithWhereUniqueWithoutEncadreurInput[]
    updateMany?: affectationUpdateManyWithWhereWithoutEncadreurInput | affectationUpdateManyWithWhereWithoutEncadreurInput[]
    deleteMany?: affectationScalarWhereInput | affectationScalarWhereInput[]
  }

  export type dossierCreateNestedManyWithoutEtudiantInput = {
    create?: XOR<dossierCreateWithoutEtudiantInput, dossierUncheckedCreateWithoutEtudiantInput> | dossierCreateWithoutEtudiantInput[] | dossierUncheckedCreateWithoutEtudiantInput[]
    connectOrCreate?: dossierCreateOrConnectWithoutEtudiantInput | dossierCreateOrConnectWithoutEtudiantInput[]
    createMany?: dossierCreateManyEtudiantInputEnvelope
    connect?: dossierWhereUniqueInput | dossierWhereUniqueInput[]
  }

  export type rapportCreateNestedManyWithoutEtudiantInput = {
    create?: XOR<rapportCreateWithoutEtudiantInput, rapportUncheckedCreateWithoutEtudiantInput> | rapportCreateWithoutEtudiantInput[] | rapportUncheckedCreateWithoutEtudiantInput[]
    connectOrCreate?: rapportCreateOrConnectWithoutEtudiantInput | rapportCreateOrConnectWithoutEtudiantInput[]
    createMany?: rapportCreateManyEtudiantInputEnvelope
    connect?: rapportWhereUniqueInput | rapportWhereUniqueInput[]
  }

  export type dossierUncheckedCreateNestedManyWithoutEtudiantInput = {
    create?: XOR<dossierCreateWithoutEtudiantInput, dossierUncheckedCreateWithoutEtudiantInput> | dossierCreateWithoutEtudiantInput[] | dossierUncheckedCreateWithoutEtudiantInput[]
    connectOrCreate?: dossierCreateOrConnectWithoutEtudiantInput | dossierCreateOrConnectWithoutEtudiantInput[]
    createMany?: dossierCreateManyEtudiantInputEnvelope
    connect?: dossierWhereUniqueInput | dossierWhereUniqueInput[]
  }

  export type rapportUncheckedCreateNestedManyWithoutEtudiantInput = {
    create?: XOR<rapportCreateWithoutEtudiantInput, rapportUncheckedCreateWithoutEtudiantInput> | rapportCreateWithoutEtudiantInput[] | rapportUncheckedCreateWithoutEtudiantInput[]
    connectOrCreate?: rapportCreateOrConnectWithoutEtudiantInput | rapportCreateOrConnectWithoutEtudiantInput[]
    createMany?: rapportCreateManyEtudiantInputEnvelope
    connect?: rapportWhereUniqueInput | rapportWhereUniqueInput[]
  }

  export type dossierUpdateManyWithoutEtudiantNestedInput = {
    create?: XOR<dossierCreateWithoutEtudiantInput, dossierUncheckedCreateWithoutEtudiantInput> | dossierCreateWithoutEtudiantInput[] | dossierUncheckedCreateWithoutEtudiantInput[]
    connectOrCreate?: dossierCreateOrConnectWithoutEtudiantInput | dossierCreateOrConnectWithoutEtudiantInput[]
    upsert?: dossierUpsertWithWhereUniqueWithoutEtudiantInput | dossierUpsertWithWhereUniqueWithoutEtudiantInput[]
    createMany?: dossierCreateManyEtudiantInputEnvelope
    set?: dossierWhereUniqueInput | dossierWhereUniqueInput[]
    disconnect?: dossierWhereUniqueInput | dossierWhereUniqueInput[]
    delete?: dossierWhereUniqueInput | dossierWhereUniqueInput[]
    connect?: dossierWhereUniqueInput | dossierWhereUniqueInput[]
    update?: dossierUpdateWithWhereUniqueWithoutEtudiantInput | dossierUpdateWithWhereUniqueWithoutEtudiantInput[]
    updateMany?: dossierUpdateManyWithWhereWithoutEtudiantInput | dossierUpdateManyWithWhereWithoutEtudiantInput[]
    deleteMany?: dossierScalarWhereInput | dossierScalarWhereInput[]
  }

  export type rapportUpdateManyWithoutEtudiantNestedInput = {
    create?: XOR<rapportCreateWithoutEtudiantInput, rapportUncheckedCreateWithoutEtudiantInput> | rapportCreateWithoutEtudiantInput[] | rapportUncheckedCreateWithoutEtudiantInput[]
    connectOrCreate?: rapportCreateOrConnectWithoutEtudiantInput | rapportCreateOrConnectWithoutEtudiantInput[]
    upsert?: rapportUpsertWithWhereUniqueWithoutEtudiantInput | rapportUpsertWithWhereUniqueWithoutEtudiantInput[]
    createMany?: rapportCreateManyEtudiantInputEnvelope
    set?: rapportWhereUniqueInput | rapportWhereUniqueInput[]
    disconnect?: rapportWhereUniqueInput | rapportWhereUniqueInput[]
    delete?: rapportWhereUniqueInput | rapportWhereUniqueInput[]
    connect?: rapportWhereUniqueInput | rapportWhereUniqueInput[]
    update?: rapportUpdateWithWhereUniqueWithoutEtudiantInput | rapportUpdateWithWhereUniqueWithoutEtudiantInput[]
    updateMany?: rapportUpdateManyWithWhereWithoutEtudiantInput | rapportUpdateManyWithWhereWithoutEtudiantInput[]
    deleteMany?: rapportScalarWhereInput | rapportScalarWhereInput[]
  }

  export type dossierUncheckedUpdateManyWithoutEtudiantNestedInput = {
    create?: XOR<dossierCreateWithoutEtudiantInput, dossierUncheckedCreateWithoutEtudiantInput> | dossierCreateWithoutEtudiantInput[] | dossierUncheckedCreateWithoutEtudiantInput[]
    connectOrCreate?: dossierCreateOrConnectWithoutEtudiantInput | dossierCreateOrConnectWithoutEtudiantInput[]
    upsert?: dossierUpsertWithWhereUniqueWithoutEtudiantInput | dossierUpsertWithWhereUniqueWithoutEtudiantInput[]
    createMany?: dossierCreateManyEtudiantInputEnvelope
    set?: dossierWhereUniqueInput | dossierWhereUniqueInput[]
    disconnect?: dossierWhereUniqueInput | dossierWhereUniqueInput[]
    delete?: dossierWhereUniqueInput | dossierWhereUniqueInput[]
    connect?: dossierWhereUniqueInput | dossierWhereUniqueInput[]
    update?: dossierUpdateWithWhereUniqueWithoutEtudiantInput | dossierUpdateWithWhereUniqueWithoutEtudiantInput[]
    updateMany?: dossierUpdateManyWithWhereWithoutEtudiantInput | dossierUpdateManyWithWhereWithoutEtudiantInput[]
    deleteMany?: dossierScalarWhereInput | dossierScalarWhereInput[]
  }

  export type rapportUncheckedUpdateManyWithoutEtudiantNestedInput = {
    create?: XOR<rapportCreateWithoutEtudiantInput, rapportUncheckedCreateWithoutEtudiantInput> | rapportCreateWithoutEtudiantInput[] | rapportUncheckedCreateWithoutEtudiantInput[]
    connectOrCreate?: rapportCreateOrConnectWithoutEtudiantInput | rapportCreateOrConnectWithoutEtudiantInput[]
    upsert?: rapportUpsertWithWhereUniqueWithoutEtudiantInput | rapportUpsertWithWhereUniqueWithoutEtudiantInput[]
    createMany?: rapportCreateManyEtudiantInputEnvelope
    set?: rapportWhereUniqueInput | rapportWhereUniqueInput[]
    disconnect?: rapportWhereUniqueInput | rapportWhereUniqueInput[]
    delete?: rapportWhereUniqueInput | rapportWhereUniqueInput[]
    connect?: rapportWhereUniqueInput | rapportWhereUniqueInput[]
    update?: rapportUpdateWithWhereUniqueWithoutEtudiantInput | rapportUpdateWithWhereUniqueWithoutEtudiantInput[]
    updateMany?: rapportUpdateManyWithWhereWithoutEtudiantInput | rapportUpdateManyWithWhereWithoutEtudiantInput[]
    deleteMany?: rapportScalarWhereInput | rapportScalarWhereInput[]
  }

  export type etudiantCreateNestedOneWithoutRapportInput = {
    create?: XOR<etudiantCreateWithoutRapportInput, etudiantUncheckedCreateWithoutRapportInput>
    connectOrCreate?: etudiantCreateOrConnectWithoutRapportInput
    connect?: etudiantWhereUniqueInput
  }

  export type etudiantUpdateOneRequiredWithoutRapportNestedInput = {
    create?: XOR<etudiantCreateWithoutRapportInput, etudiantUncheckedCreateWithoutRapportInput>
    connectOrCreate?: etudiantCreateOrConnectWithoutRapportInput
    upsert?: etudiantUpsertWithoutRapportInput
    connect?: etudiantWhereUniqueInput
    update?: XOR<XOR<etudiantUpdateToOneWithWhereWithoutRapportInput, etudiantUpdateWithoutRapportInput>, etudiantUncheckedUpdateWithoutRapportInput>
  }

  export type dossierCreateNestedOneWithoutLettreAcceptationInput = {
    create?: XOR<dossierCreateWithoutLettreAcceptationInput, dossierUncheckedCreateWithoutLettreAcceptationInput>
    connectOrCreate?: dossierCreateOrConnectWithoutLettreAcceptationInput
    connect?: dossierWhereUniqueInput
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type dossierUpdateOneRequiredWithoutLettreAcceptationNestedInput = {
    create?: XOR<dossierCreateWithoutLettreAcceptationInput, dossierUncheckedCreateWithoutLettreAcceptationInput>
    connectOrCreate?: dossierCreateOrConnectWithoutLettreAcceptationInput
    upsert?: dossierUpsertWithoutLettreAcceptationInput
    connect?: dossierWhereUniqueInput
    update?: XOR<XOR<dossierUpdateToOneWithWhereWithoutLettreAcceptationInput, dossierUpdateWithoutLettreAcceptationInput>, dossierUncheckedUpdateWithoutLettreAcceptationInput>
  }

  export type affectationCreateNestedManyWithoutStructuresInput = {
    create?: XOR<affectationCreateWithoutStructuresInput, affectationUncheckedCreateWithoutStructuresInput> | affectationCreateWithoutStructuresInput[] | affectationUncheckedCreateWithoutStructuresInput[]
    connectOrCreate?: affectationCreateOrConnectWithoutStructuresInput | affectationCreateOrConnectWithoutStructuresInput[]
    createMany?: affectationCreateManyStructuresInputEnvelope
    connect?: affectationWhereUniqueInput | affectationWhereUniqueInput[]
  }

  export type encadreurCreateNestedManyWithoutStructuresInput = {
    create?: XOR<encadreurCreateWithoutStructuresInput, encadreurUncheckedCreateWithoutStructuresInput> | encadreurCreateWithoutStructuresInput[] | encadreurUncheckedCreateWithoutStructuresInput[]
    connectOrCreate?: encadreurCreateOrConnectWithoutStructuresInput | encadreurCreateOrConnectWithoutStructuresInput[]
    createMany?: encadreurCreateManyStructuresInputEnvelope
    connect?: encadreurWhereUniqueInput | encadreurWhereUniqueInput[]
  }

  export type structuresCreateNestedOneWithoutOther_structuresInput = {
    create?: XOR<structuresCreateWithoutOther_structuresInput, structuresUncheckedCreateWithoutOther_structuresInput>
    connectOrCreate?: structuresCreateOrConnectWithoutOther_structuresInput
    connect?: structuresWhereUniqueInput
  }

  export type structuresCreateNestedManyWithoutStructuresInput = {
    create?: XOR<structuresCreateWithoutStructuresInput, structuresUncheckedCreateWithoutStructuresInput> | structuresCreateWithoutStructuresInput[] | structuresUncheckedCreateWithoutStructuresInput[]
    connectOrCreate?: structuresCreateOrConnectWithoutStructuresInput | structuresCreateOrConnectWithoutStructuresInput[]
    createMany?: structuresCreateManyStructuresInputEnvelope
    connect?: structuresWhereUniqueInput | structuresWhereUniqueInput[]
  }

  export type affectationUncheckedCreateNestedManyWithoutStructuresInput = {
    create?: XOR<affectationCreateWithoutStructuresInput, affectationUncheckedCreateWithoutStructuresInput> | affectationCreateWithoutStructuresInput[] | affectationUncheckedCreateWithoutStructuresInput[]
    connectOrCreate?: affectationCreateOrConnectWithoutStructuresInput | affectationCreateOrConnectWithoutStructuresInput[]
    createMany?: affectationCreateManyStructuresInputEnvelope
    connect?: affectationWhereUniqueInput | affectationWhereUniqueInput[]
  }

  export type encadreurUncheckedCreateNestedManyWithoutStructuresInput = {
    create?: XOR<encadreurCreateWithoutStructuresInput, encadreurUncheckedCreateWithoutStructuresInput> | encadreurCreateWithoutStructuresInput[] | encadreurUncheckedCreateWithoutStructuresInput[]
    connectOrCreate?: encadreurCreateOrConnectWithoutStructuresInput | encadreurCreateOrConnectWithoutStructuresInput[]
    createMany?: encadreurCreateManyStructuresInputEnvelope
    connect?: encadreurWhereUniqueInput | encadreurWhereUniqueInput[]
  }

  export type structuresUncheckedCreateNestedManyWithoutStructuresInput = {
    create?: XOR<structuresCreateWithoutStructuresInput, structuresUncheckedCreateWithoutStructuresInput> | structuresCreateWithoutStructuresInput[] | structuresUncheckedCreateWithoutStructuresInput[]
    connectOrCreate?: structuresCreateOrConnectWithoutStructuresInput | structuresCreateOrConnectWithoutStructuresInput[]
    createMany?: structuresCreateManyStructuresInputEnvelope
    connect?: structuresWhereUniqueInput | structuresWhereUniqueInput[]
  }

  export type affectationUpdateManyWithoutStructuresNestedInput = {
    create?: XOR<affectationCreateWithoutStructuresInput, affectationUncheckedCreateWithoutStructuresInput> | affectationCreateWithoutStructuresInput[] | affectationUncheckedCreateWithoutStructuresInput[]
    connectOrCreate?: affectationCreateOrConnectWithoutStructuresInput | affectationCreateOrConnectWithoutStructuresInput[]
    upsert?: affectationUpsertWithWhereUniqueWithoutStructuresInput | affectationUpsertWithWhereUniqueWithoutStructuresInput[]
    createMany?: affectationCreateManyStructuresInputEnvelope
    set?: affectationWhereUniqueInput | affectationWhereUniqueInput[]
    disconnect?: affectationWhereUniqueInput | affectationWhereUniqueInput[]
    delete?: affectationWhereUniqueInput | affectationWhereUniqueInput[]
    connect?: affectationWhereUniqueInput | affectationWhereUniqueInput[]
    update?: affectationUpdateWithWhereUniqueWithoutStructuresInput | affectationUpdateWithWhereUniqueWithoutStructuresInput[]
    updateMany?: affectationUpdateManyWithWhereWithoutStructuresInput | affectationUpdateManyWithWhereWithoutStructuresInput[]
    deleteMany?: affectationScalarWhereInput | affectationScalarWhereInput[]
  }

  export type encadreurUpdateManyWithoutStructuresNestedInput = {
    create?: XOR<encadreurCreateWithoutStructuresInput, encadreurUncheckedCreateWithoutStructuresInput> | encadreurCreateWithoutStructuresInput[] | encadreurUncheckedCreateWithoutStructuresInput[]
    connectOrCreate?: encadreurCreateOrConnectWithoutStructuresInput | encadreurCreateOrConnectWithoutStructuresInput[]
    upsert?: encadreurUpsertWithWhereUniqueWithoutStructuresInput | encadreurUpsertWithWhereUniqueWithoutStructuresInput[]
    createMany?: encadreurCreateManyStructuresInputEnvelope
    set?: encadreurWhereUniqueInput | encadreurWhereUniqueInput[]
    disconnect?: encadreurWhereUniqueInput | encadreurWhereUniqueInput[]
    delete?: encadreurWhereUniqueInput | encadreurWhereUniqueInput[]
    connect?: encadreurWhereUniqueInput | encadreurWhereUniqueInput[]
    update?: encadreurUpdateWithWhereUniqueWithoutStructuresInput | encadreurUpdateWithWhereUniqueWithoutStructuresInput[]
    updateMany?: encadreurUpdateManyWithWhereWithoutStructuresInput | encadreurUpdateManyWithWhereWithoutStructuresInput[]
    deleteMany?: encadreurScalarWhereInput | encadreurScalarWhereInput[]
  }

  export type structuresUpdateOneWithoutOther_structuresNestedInput = {
    create?: XOR<structuresCreateWithoutOther_structuresInput, structuresUncheckedCreateWithoutOther_structuresInput>
    connectOrCreate?: structuresCreateOrConnectWithoutOther_structuresInput
    upsert?: structuresUpsertWithoutOther_structuresInput
    disconnect?: structuresWhereInput | boolean
    delete?: structuresWhereInput | boolean
    connect?: structuresWhereUniqueInput
    update?: XOR<XOR<structuresUpdateToOneWithWhereWithoutOther_structuresInput, structuresUpdateWithoutOther_structuresInput>, structuresUncheckedUpdateWithoutOther_structuresInput>
  }

  export type structuresUpdateManyWithoutStructuresNestedInput = {
    create?: XOR<structuresCreateWithoutStructuresInput, structuresUncheckedCreateWithoutStructuresInput> | structuresCreateWithoutStructuresInput[] | structuresUncheckedCreateWithoutStructuresInput[]
    connectOrCreate?: structuresCreateOrConnectWithoutStructuresInput | structuresCreateOrConnectWithoutStructuresInput[]
    upsert?: structuresUpsertWithWhereUniqueWithoutStructuresInput | structuresUpsertWithWhereUniqueWithoutStructuresInput[]
    createMany?: structuresCreateManyStructuresInputEnvelope
    set?: structuresWhereUniqueInput | structuresWhereUniqueInput[]
    disconnect?: structuresWhereUniqueInput | structuresWhereUniqueInput[]
    delete?: structuresWhereUniqueInput | structuresWhereUniqueInput[]
    connect?: structuresWhereUniqueInput | structuresWhereUniqueInput[]
    update?: structuresUpdateWithWhereUniqueWithoutStructuresInput | structuresUpdateWithWhereUniqueWithoutStructuresInput[]
    updateMany?: structuresUpdateManyWithWhereWithoutStructuresInput | structuresUpdateManyWithWhereWithoutStructuresInput[]
    deleteMany?: structuresScalarWhereInput | structuresScalarWhereInput[]
  }

  export type affectationUncheckedUpdateManyWithoutStructuresNestedInput = {
    create?: XOR<affectationCreateWithoutStructuresInput, affectationUncheckedCreateWithoutStructuresInput> | affectationCreateWithoutStructuresInput[] | affectationUncheckedCreateWithoutStructuresInput[]
    connectOrCreate?: affectationCreateOrConnectWithoutStructuresInput | affectationCreateOrConnectWithoutStructuresInput[]
    upsert?: affectationUpsertWithWhereUniqueWithoutStructuresInput | affectationUpsertWithWhereUniqueWithoutStructuresInput[]
    createMany?: affectationCreateManyStructuresInputEnvelope
    set?: affectationWhereUniqueInput | affectationWhereUniqueInput[]
    disconnect?: affectationWhereUniqueInput | affectationWhereUniqueInput[]
    delete?: affectationWhereUniqueInput | affectationWhereUniqueInput[]
    connect?: affectationWhereUniqueInput | affectationWhereUniqueInput[]
    update?: affectationUpdateWithWhereUniqueWithoutStructuresInput | affectationUpdateWithWhereUniqueWithoutStructuresInput[]
    updateMany?: affectationUpdateManyWithWhereWithoutStructuresInput | affectationUpdateManyWithWhereWithoutStructuresInput[]
    deleteMany?: affectationScalarWhereInput | affectationScalarWhereInput[]
  }

  export type encadreurUncheckedUpdateManyWithoutStructuresNestedInput = {
    create?: XOR<encadreurCreateWithoutStructuresInput, encadreurUncheckedCreateWithoutStructuresInput> | encadreurCreateWithoutStructuresInput[] | encadreurUncheckedCreateWithoutStructuresInput[]
    connectOrCreate?: encadreurCreateOrConnectWithoutStructuresInput | encadreurCreateOrConnectWithoutStructuresInput[]
    upsert?: encadreurUpsertWithWhereUniqueWithoutStructuresInput | encadreurUpsertWithWhereUniqueWithoutStructuresInput[]
    createMany?: encadreurCreateManyStructuresInputEnvelope
    set?: encadreurWhereUniqueInput | encadreurWhereUniqueInput[]
    disconnect?: encadreurWhereUniqueInput | encadreurWhereUniqueInput[]
    delete?: encadreurWhereUniqueInput | encadreurWhereUniqueInput[]
    connect?: encadreurWhereUniqueInput | encadreurWhereUniqueInput[]
    update?: encadreurUpdateWithWhereUniqueWithoutStructuresInput | encadreurUpdateWithWhereUniqueWithoutStructuresInput[]
    updateMany?: encadreurUpdateManyWithWhereWithoutStructuresInput | encadreurUpdateManyWithWhereWithoutStructuresInput[]
    deleteMany?: encadreurScalarWhereInput | encadreurScalarWhereInput[]
  }

  export type structuresUncheckedUpdateManyWithoutStructuresNestedInput = {
    create?: XOR<structuresCreateWithoutStructuresInput, structuresUncheckedCreateWithoutStructuresInput> | structuresCreateWithoutStructuresInput[] | structuresUncheckedCreateWithoutStructuresInput[]
    connectOrCreate?: structuresCreateOrConnectWithoutStructuresInput | structuresCreateOrConnectWithoutStructuresInput[]
    upsert?: structuresUpsertWithWhereUniqueWithoutStructuresInput | structuresUpsertWithWhereUniqueWithoutStructuresInput[]
    createMany?: structuresCreateManyStructuresInputEnvelope
    set?: structuresWhereUniqueInput | structuresWhereUniqueInput[]
    disconnect?: structuresWhereUniqueInput | structuresWhereUniqueInput[]
    delete?: structuresWhereUniqueInput | structuresWhereUniqueInput[]
    connect?: structuresWhereUniqueInput | structuresWhereUniqueInput[]
    update?: structuresUpdateWithWhereUniqueWithoutStructuresInput | structuresUpdateWithWhereUniqueWithoutStructuresInput[]
    updateMany?: structuresUpdateManyWithWhereWithoutStructuresInput | structuresUpdateManyWithWhereWithoutStructuresInput[]
    deleteMany?: structuresScalarWhereInput | structuresScalarWhereInput[]
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type affectationCreateWithoutAdministrateurInput = {
    encadreur: encadreurCreateNestedOneWithoutAffectationInput
    dossier: dossierCreateNestedOneWithoutAffectationInput
    structures: structuresCreateNestedOneWithoutAffectationInput
  }

  export type affectationUncheckedCreateWithoutAdministrateurInput = {
    IDENCADREUR: number
    IDDOSSIER: number
    IDSTRUCTURE: number
  }

  export type affectationCreateOrConnectWithoutAdministrateurInput = {
    where: affectationWhereUniqueInput
    create: XOR<affectationCreateWithoutAdministrateurInput, affectationUncheckedCreateWithoutAdministrateurInput>
  }

  export type affectationCreateManyAdministrateurInputEnvelope = {
    data: affectationCreateManyAdministrateurInput | affectationCreateManyAdministrateurInput[]
    skipDuplicates?: boolean
  }

  export type affectationUpsertWithWhereUniqueWithoutAdministrateurInput = {
    where: affectationWhereUniqueInput
    update: XOR<affectationUpdateWithoutAdministrateurInput, affectationUncheckedUpdateWithoutAdministrateurInput>
    create: XOR<affectationCreateWithoutAdministrateurInput, affectationUncheckedCreateWithoutAdministrateurInput>
  }

  export type affectationUpdateWithWhereUniqueWithoutAdministrateurInput = {
    where: affectationWhereUniqueInput
    data: XOR<affectationUpdateWithoutAdministrateurInput, affectationUncheckedUpdateWithoutAdministrateurInput>
  }

  export type affectationUpdateManyWithWhereWithoutAdministrateurInput = {
    where: affectationScalarWhereInput
    data: XOR<affectationUpdateManyMutationInput, affectationUncheckedUpdateManyWithoutAdministrateurInput>
  }

  export type affectationScalarWhereInput = {
    AND?: affectationScalarWhereInput | affectationScalarWhereInput[]
    OR?: affectationScalarWhereInput[]
    NOT?: affectationScalarWhereInput | affectationScalarWhereInput[]
    IDADMIN?: IntFilter<"affectation"> | number
    IDENCADREUR?: IntFilter<"affectation"> | number
    IDDOSSIER?: IntFilter<"affectation"> | number
    IDSTRUCTURE?: IntFilter<"affectation"> | number
  }

  export type administrateurCreateWithoutAffectationInput = {
    MATRICULEADMIN: string
    NOMADMIN: string
    PRENOMADMIN: string
    EMAILADMIN: string
    PASSWARDADMIN: string
    PHOTOADMIN: string
  }

  export type administrateurUncheckedCreateWithoutAffectationInput = {
    IDADMIN?: number
    MATRICULEADMIN: string
    NOMADMIN: string
    PRENOMADMIN: string
    EMAILADMIN: string
    PASSWARDADMIN: string
    PHOTOADMIN: string
  }

  export type administrateurCreateOrConnectWithoutAffectationInput = {
    where: administrateurWhereUniqueInput
    create: XOR<administrateurCreateWithoutAffectationInput, administrateurUncheckedCreateWithoutAffectationInput>
  }

  export type encadreurCreateWithoutAffectationInput = {
    MATRICULEENCADREUR: string
    NOMENCADREUR?: string | null
    PRENOMENCADREUR?: string | null
    POSTE?: string | null
    structures?: structuresCreateNestedOneWithoutEncadreurInput
  }

  export type encadreurUncheckedCreateWithoutAffectationInput = {
    IDENCADREUR?: number
    MATRICULEENCADREUR: string
    NOMENCADREUR?: string | null
    PRENOMENCADREUR?: string | null
    IDSTRUCTURE?: number | null
    POSTE?: string | null
  }

  export type encadreurCreateOrConnectWithoutAffectationInput = {
    where: encadreurWhereUniqueInput
    create: XOR<encadreurCreateWithoutAffectationInput, encadreurUncheckedCreateWithoutAffectationInput>
  }

  export type dossierCreateWithoutAffectationInput = {
    DATEDEBUTDESEANCE?: Date | string | null
    DATEFINDESEANCE?: Date | string | null
    ETAT?: string | null
    THEME?: string | null
    CNI: string
    CERTIFICAT: string
    LETTREMOTIVATION: string
    LETTRERECOMMENDATION: string
    PHOTOPROFIL: string
    CV?: string | null
    CAHIERDECHARGE?: string | null
    DATEDEPOT?: Date | string
    EMAILSENT?: boolean | null
    etudiant?: etudiantCreateNestedOneWithoutDossierInput
    lettreAcceptation?: lettreAcceptationCreateNestedManyWithoutDossierInput
  }

  export type dossierUncheckedCreateWithoutAffectationInput = {
    IDDOSSIER?: number
    MATRICULEETUDIANT?: string | null
    DATEDEBUTDESEANCE?: Date | string | null
    DATEFINDESEANCE?: Date | string | null
    ETAT?: string | null
    THEME?: string | null
    CNI: string
    CERTIFICAT: string
    LETTREMOTIVATION: string
    LETTRERECOMMENDATION: string
    PHOTOPROFIL: string
    CV?: string | null
    CAHIERDECHARGE?: string | null
    DATEDEPOT?: Date | string
    EMAILSENT?: boolean | null
    lettreAcceptation?: lettreAcceptationUncheckedCreateNestedManyWithoutDossierInput
  }

  export type dossierCreateOrConnectWithoutAffectationInput = {
    where: dossierWhereUniqueInput
    create: XOR<dossierCreateWithoutAffectationInput, dossierUncheckedCreateWithoutAffectationInput>
  }

  export type structuresCreateWithoutAffectationInput = {
    NOMSTRUCTURE: string
    ABBREVIATION: string
    encadreur?: encadreurCreateNestedManyWithoutStructuresInput
    structures?: structuresCreateNestedOneWithoutOther_structuresInput
    other_structures?: structuresCreateNestedManyWithoutStructuresInput
  }

  export type structuresUncheckedCreateWithoutAffectationInput = {
    IDSTRUCTURE?: number
    NOMSTRUCTURE: string
    ABBREVIATION: string
    IDPARENT?: number | null
    encadreur?: encadreurUncheckedCreateNestedManyWithoutStructuresInput
    other_structures?: structuresUncheckedCreateNestedManyWithoutStructuresInput
  }

  export type structuresCreateOrConnectWithoutAffectationInput = {
    where: structuresWhereUniqueInput
    create: XOR<structuresCreateWithoutAffectationInput, structuresUncheckedCreateWithoutAffectationInput>
  }

  export type administrateurUpsertWithoutAffectationInput = {
    update: XOR<administrateurUpdateWithoutAffectationInput, administrateurUncheckedUpdateWithoutAffectationInput>
    create: XOR<administrateurCreateWithoutAffectationInput, administrateurUncheckedCreateWithoutAffectationInput>
    where?: administrateurWhereInput
  }

  export type administrateurUpdateToOneWithWhereWithoutAffectationInput = {
    where?: administrateurWhereInput
    data: XOR<administrateurUpdateWithoutAffectationInput, administrateurUncheckedUpdateWithoutAffectationInput>
  }

  export type administrateurUpdateWithoutAffectationInput = {
    MATRICULEADMIN?: StringFieldUpdateOperationsInput | string
    NOMADMIN?: StringFieldUpdateOperationsInput | string
    PRENOMADMIN?: StringFieldUpdateOperationsInput | string
    EMAILADMIN?: StringFieldUpdateOperationsInput | string
    PASSWARDADMIN?: StringFieldUpdateOperationsInput | string
    PHOTOADMIN?: StringFieldUpdateOperationsInput | string
  }

  export type administrateurUncheckedUpdateWithoutAffectationInput = {
    IDADMIN?: IntFieldUpdateOperationsInput | number
    MATRICULEADMIN?: StringFieldUpdateOperationsInput | string
    NOMADMIN?: StringFieldUpdateOperationsInput | string
    PRENOMADMIN?: StringFieldUpdateOperationsInput | string
    EMAILADMIN?: StringFieldUpdateOperationsInput | string
    PASSWARDADMIN?: StringFieldUpdateOperationsInput | string
    PHOTOADMIN?: StringFieldUpdateOperationsInput | string
  }

  export type encadreurUpsertWithoutAffectationInput = {
    update: XOR<encadreurUpdateWithoutAffectationInput, encadreurUncheckedUpdateWithoutAffectationInput>
    create: XOR<encadreurCreateWithoutAffectationInput, encadreurUncheckedCreateWithoutAffectationInput>
    where?: encadreurWhereInput
  }

  export type encadreurUpdateToOneWithWhereWithoutAffectationInput = {
    where?: encadreurWhereInput
    data: XOR<encadreurUpdateWithoutAffectationInput, encadreurUncheckedUpdateWithoutAffectationInput>
  }

  export type encadreurUpdateWithoutAffectationInput = {
    MATRICULEENCADREUR?: StringFieldUpdateOperationsInput | string
    NOMENCADREUR?: NullableStringFieldUpdateOperationsInput | string | null
    PRENOMENCADREUR?: NullableStringFieldUpdateOperationsInput | string | null
    POSTE?: NullableStringFieldUpdateOperationsInput | string | null
    structures?: structuresUpdateOneWithoutEncadreurNestedInput
  }

  export type encadreurUncheckedUpdateWithoutAffectationInput = {
    IDENCADREUR?: IntFieldUpdateOperationsInput | number
    MATRICULEENCADREUR?: StringFieldUpdateOperationsInput | string
    NOMENCADREUR?: NullableStringFieldUpdateOperationsInput | string | null
    PRENOMENCADREUR?: NullableStringFieldUpdateOperationsInput | string | null
    IDSTRUCTURE?: NullableIntFieldUpdateOperationsInput | number | null
    POSTE?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type dossierUpsertWithoutAffectationInput = {
    update: XOR<dossierUpdateWithoutAffectationInput, dossierUncheckedUpdateWithoutAffectationInput>
    create: XOR<dossierCreateWithoutAffectationInput, dossierUncheckedCreateWithoutAffectationInput>
    where?: dossierWhereInput
  }

  export type dossierUpdateToOneWithWhereWithoutAffectationInput = {
    where?: dossierWhereInput
    data: XOR<dossierUpdateWithoutAffectationInput, dossierUncheckedUpdateWithoutAffectationInput>
  }

  export type dossierUpdateWithoutAffectationInput = {
    DATEDEBUTDESEANCE?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    DATEFINDESEANCE?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ETAT?: NullableStringFieldUpdateOperationsInput | string | null
    THEME?: NullableStringFieldUpdateOperationsInput | string | null
    CNI?: StringFieldUpdateOperationsInput | string
    CERTIFICAT?: StringFieldUpdateOperationsInput | string
    LETTREMOTIVATION?: StringFieldUpdateOperationsInput | string
    LETTRERECOMMENDATION?: StringFieldUpdateOperationsInput | string
    PHOTOPROFIL?: StringFieldUpdateOperationsInput | string
    CV?: NullableStringFieldUpdateOperationsInput | string | null
    CAHIERDECHARGE?: NullableStringFieldUpdateOperationsInput | string | null
    DATEDEPOT?: DateTimeFieldUpdateOperationsInput | Date | string
    EMAILSENT?: NullableBoolFieldUpdateOperationsInput | boolean | null
    etudiant?: etudiantUpdateOneWithoutDossierNestedInput
    lettreAcceptation?: lettreAcceptationUpdateManyWithoutDossierNestedInput
  }

  export type dossierUncheckedUpdateWithoutAffectationInput = {
    IDDOSSIER?: IntFieldUpdateOperationsInput | number
    MATRICULEETUDIANT?: NullableStringFieldUpdateOperationsInput | string | null
    DATEDEBUTDESEANCE?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    DATEFINDESEANCE?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ETAT?: NullableStringFieldUpdateOperationsInput | string | null
    THEME?: NullableStringFieldUpdateOperationsInput | string | null
    CNI?: StringFieldUpdateOperationsInput | string
    CERTIFICAT?: StringFieldUpdateOperationsInput | string
    LETTREMOTIVATION?: StringFieldUpdateOperationsInput | string
    LETTRERECOMMENDATION?: StringFieldUpdateOperationsInput | string
    PHOTOPROFIL?: StringFieldUpdateOperationsInput | string
    CV?: NullableStringFieldUpdateOperationsInput | string | null
    CAHIERDECHARGE?: NullableStringFieldUpdateOperationsInput | string | null
    DATEDEPOT?: DateTimeFieldUpdateOperationsInput | Date | string
    EMAILSENT?: NullableBoolFieldUpdateOperationsInput | boolean | null
    lettreAcceptation?: lettreAcceptationUncheckedUpdateManyWithoutDossierNestedInput
  }

  export type structuresUpsertWithoutAffectationInput = {
    update: XOR<structuresUpdateWithoutAffectationInput, structuresUncheckedUpdateWithoutAffectationInput>
    create: XOR<structuresCreateWithoutAffectationInput, structuresUncheckedCreateWithoutAffectationInput>
    where?: structuresWhereInput
  }

  export type structuresUpdateToOneWithWhereWithoutAffectationInput = {
    where?: structuresWhereInput
    data: XOR<structuresUpdateWithoutAffectationInput, structuresUncheckedUpdateWithoutAffectationInput>
  }

  export type structuresUpdateWithoutAffectationInput = {
    NOMSTRUCTURE?: StringFieldUpdateOperationsInput | string
    ABBREVIATION?: StringFieldUpdateOperationsInput | string
    encadreur?: encadreurUpdateManyWithoutStructuresNestedInput
    structures?: structuresUpdateOneWithoutOther_structuresNestedInput
    other_structures?: structuresUpdateManyWithoutStructuresNestedInput
  }

  export type structuresUncheckedUpdateWithoutAffectationInput = {
    IDSTRUCTURE?: IntFieldUpdateOperationsInput | number
    NOMSTRUCTURE?: StringFieldUpdateOperationsInput | string
    ABBREVIATION?: StringFieldUpdateOperationsInput | string
    IDPARENT?: NullableIntFieldUpdateOperationsInput | number | null
    encadreur?: encadreurUncheckedUpdateManyWithoutStructuresNestedInput
    other_structures?: structuresUncheckedUpdateManyWithoutStructuresNestedInput
  }

  export type affectationCreateWithoutDossierInput = {
    administrateur: administrateurCreateNestedOneWithoutAffectationInput
    encadreur: encadreurCreateNestedOneWithoutAffectationInput
    structures: structuresCreateNestedOneWithoutAffectationInput
  }

  export type affectationUncheckedCreateWithoutDossierInput = {
    IDADMIN: number
    IDENCADREUR: number
    IDSTRUCTURE: number
  }

  export type affectationCreateOrConnectWithoutDossierInput = {
    where: affectationWhereUniqueInput
    create: XOR<affectationCreateWithoutDossierInput, affectationUncheckedCreateWithoutDossierInput>
  }

  export type affectationCreateManyDossierInputEnvelope = {
    data: affectationCreateManyDossierInput | affectationCreateManyDossierInput[]
    skipDuplicates?: boolean
  }

  export type etudiantCreateWithoutDossierInput = {
    MATRICULEETUDIANT: string
    NOMETUDIANT?: string | null
    PRENOMETUDIANT?: string | null
    ETABLISSEMENT?: string | null
    VILLERESIDENCE?: string | null
    PARCOURS?: string | null
    NIVEAU?: string | null
    EMAIL: string
    TEL: string
    FILIERE: string
    SEXE: string
    DATE?: Date | string
    rapport?: rapportCreateNestedManyWithoutEtudiantInput
  }

  export type etudiantUncheckedCreateWithoutDossierInput = {
    MATRICULEETUDIANT: string
    NOMETUDIANT?: string | null
    PRENOMETUDIANT?: string | null
    ETABLISSEMENT?: string | null
    VILLERESIDENCE?: string | null
    PARCOURS?: string | null
    NIVEAU?: string | null
    EMAIL: string
    TEL: string
    FILIERE: string
    SEXE: string
    DATE?: Date | string
    rapport?: rapportUncheckedCreateNestedManyWithoutEtudiantInput
  }

  export type etudiantCreateOrConnectWithoutDossierInput = {
    where: etudiantWhereUniqueInput
    create: XOR<etudiantCreateWithoutDossierInput, etudiantUncheckedCreateWithoutDossierInput>
  }

  export type lettreAcceptationCreateWithoutDossierInput = {
    COMMENTAIRE: string
    FICHIER: string
    DATEUPLOAD?: Date | string
    EMAILSENT?: boolean
  }

  export type lettreAcceptationUncheckedCreateWithoutDossierInput = {
    IDLETTRE?: number
    COMMENTAIRE: string
    FICHIER: string
    DATEUPLOAD?: Date | string
    EMAILSENT?: boolean
  }

  export type lettreAcceptationCreateOrConnectWithoutDossierInput = {
    where: lettreAcceptationWhereUniqueInput
    create: XOR<lettreAcceptationCreateWithoutDossierInput, lettreAcceptationUncheckedCreateWithoutDossierInput>
  }

  export type lettreAcceptationCreateManyDossierInputEnvelope = {
    data: lettreAcceptationCreateManyDossierInput | lettreAcceptationCreateManyDossierInput[]
    skipDuplicates?: boolean
  }

  export type affectationUpsertWithWhereUniqueWithoutDossierInput = {
    where: affectationWhereUniqueInput
    update: XOR<affectationUpdateWithoutDossierInput, affectationUncheckedUpdateWithoutDossierInput>
    create: XOR<affectationCreateWithoutDossierInput, affectationUncheckedCreateWithoutDossierInput>
  }

  export type affectationUpdateWithWhereUniqueWithoutDossierInput = {
    where: affectationWhereUniqueInput
    data: XOR<affectationUpdateWithoutDossierInput, affectationUncheckedUpdateWithoutDossierInput>
  }

  export type affectationUpdateManyWithWhereWithoutDossierInput = {
    where: affectationScalarWhereInput
    data: XOR<affectationUpdateManyMutationInput, affectationUncheckedUpdateManyWithoutDossierInput>
  }

  export type etudiantUpsertWithoutDossierInput = {
    update: XOR<etudiantUpdateWithoutDossierInput, etudiantUncheckedUpdateWithoutDossierInput>
    create: XOR<etudiantCreateWithoutDossierInput, etudiantUncheckedCreateWithoutDossierInput>
    where?: etudiantWhereInput
  }

  export type etudiantUpdateToOneWithWhereWithoutDossierInput = {
    where?: etudiantWhereInput
    data: XOR<etudiantUpdateWithoutDossierInput, etudiantUncheckedUpdateWithoutDossierInput>
  }

  export type etudiantUpdateWithoutDossierInput = {
    MATRICULEETUDIANT?: StringFieldUpdateOperationsInput | string
    NOMETUDIANT?: NullableStringFieldUpdateOperationsInput | string | null
    PRENOMETUDIANT?: NullableStringFieldUpdateOperationsInput | string | null
    ETABLISSEMENT?: NullableStringFieldUpdateOperationsInput | string | null
    VILLERESIDENCE?: NullableStringFieldUpdateOperationsInput | string | null
    PARCOURS?: NullableStringFieldUpdateOperationsInput | string | null
    NIVEAU?: NullableStringFieldUpdateOperationsInput | string | null
    EMAIL?: StringFieldUpdateOperationsInput | string
    TEL?: StringFieldUpdateOperationsInput | string
    FILIERE?: StringFieldUpdateOperationsInput | string
    SEXE?: StringFieldUpdateOperationsInput | string
    DATE?: DateTimeFieldUpdateOperationsInput | Date | string
    rapport?: rapportUpdateManyWithoutEtudiantNestedInput
  }

  export type etudiantUncheckedUpdateWithoutDossierInput = {
    MATRICULEETUDIANT?: StringFieldUpdateOperationsInput | string
    NOMETUDIANT?: NullableStringFieldUpdateOperationsInput | string | null
    PRENOMETUDIANT?: NullableStringFieldUpdateOperationsInput | string | null
    ETABLISSEMENT?: NullableStringFieldUpdateOperationsInput | string | null
    VILLERESIDENCE?: NullableStringFieldUpdateOperationsInput | string | null
    PARCOURS?: NullableStringFieldUpdateOperationsInput | string | null
    NIVEAU?: NullableStringFieldUpdateOperationsInput | string | null
    EMAIL?: StringFieldUpdateOperationsInput | string
    TEL?: StringFieldUpdateOperationsInput | string
    FILIERE?: StringFieldUpdateOperationsInput | string
    SEXE?: StringFieldUpdateOperationsInput | string
    DATE?: DateTimeFieldUpdateOperationsInput | Date | string
    rapport?: rapportUncheckedUpdateManyWithoutEtudiantNestedInput
  }

  export type lettreAcceptationUpsertWithWhereUniqueWithoutDossierInput = {
    where: lettreAcceptationWhereUniqueInput
    update: XOR<lettreAcceptationUpdateWithoutDossierInput, lettreAcceptationUncheckedUpdateWithoutDossierInput>
    create: XOR<lettreAcceptationCreateWithoutDossierInput, lettreAcceptationUncheckedCreateWithoutDossierInput>
  }

  export type lettreAcceptationUpdateWithWhereUniqueWithoutDossierInput = {
    where: lettreAcceptationWhereUniqueInput
    data: XOR<lettreAcceptationUpdateWithoutDossierInput, lettreAcceptationUncheckedUpdateWithoutDossierInput>
  }

  export type lettreAcceptationUpdateManyWithWhereWithoutDossierInput = {
    where: lettreAcceptationScalarWhereInput
    data: XOR<lettreAcceptationUpdateManyMutationInput, lettreAcceptationUncheckedUpdateManyWithoutDossierInput>
  }

  export type lettreAcceptationScalarWhereInput = {
    AND?: lettreAcceptationScalarWhereInput | lettreAcceptationScalarWhereInput[]
    OR?: lettreAcceptationScalarWhereInput[]
    NOT?: lettreAcceptationScalarWhereInput | lettreAcceptationScalarWhereInput[]
    IDLETTRE?: IntFilter<"lettreAcceptation"> | number
    IDDOSSIER?: IntFilter<"lettreAcceptation"> | number
    COMMENTAIRE?: StringFilter<"lettreAcceptation"> | string
    FICHIER?: StringFilter<"lettreAcceptation"> | string
    DATEUPLOAD?: DateTimeFilter<"lettreAcceptation"> | Date | string
    EMAILSENT?: BoolFilter<"lettreAcceptation"> | boolean
  }

  export type affectationCreateWithoutEncadreurInput = {
    administrateur: administrateurCreateNestedOneWithoutAffectationInput
    dossier: dossierCreateNestedOneWithoutAffectationInput
    structures: structuresCreateNestedOneWithoutAffectationInput
  }

  export type affectationUncheckedCreateWithoutEncadreurInput = {
    IDADMIN: number
    IDDOSSIER: number
    IDSTRUCTURE: number
  }

  export type affectationCreateOrConnectWithoutEncadreurInput = {
    where: affectationWhereUniqueInput
    create: XOR<affectationCreateWithoutEncadreurInput, affectationUncheckedCreateWithoutEncadreurInput>
  }

  export type affectationCreateManyEncadreurInputEnvelope = {
    data: affectationCreateManyEncadreurInput | affectationCreateManyEncadreurInput[]
    skipDuplicates?: boolean
  }

  export type structuresCreateWithoutEncadreurInput = {
    NOMSTRUCTURE: string
    ABBREVIATION: string
    affectation?: affectationCreateNestedManyWithoutStructuresInput
    structures?: structuresCreateNestedOneWithoutOther_structuresInput
    other_structures?: structuresCreateNestedManyWithoutStructuresInput
  }

  export type structuresUncheckedCreateWithoutEncadreurInput = {
    IDSTRUCTURE?: number
    NOMSTRUCTURE: string
    ABBREVIATION: string
    IDPARENT?: number | null
    affectation?: affectationUncheckedCreateNestedManyWithoutStructuresInput
    other_structures?: structuresUncheckedCreateNestedManyWithoutStructuresInput
  }

  export type structuresCreateOrConnectWithoutEncadreurInput = {
    where: structuresWhereUniqueInput
    create: XOR<structuresCreateWithoutEncadreurInput, structuresUncheckedCreateWithoutEncadreurInput>
  }

  export type affectationUpsertWithWhereUniqueWithoutEncadreurInput = {
    where: affectationWhereUniqueInput
    update: XOR<affectationUpdateWithoutEncadreurInput, affectationUncheckedUpdateWithoutEncadreurInput>
    create: XOR<affectationCreateWithoutEncadreurInput, affectationUncheckedCreateWithoutEncadreurInput>
  }

  export type affectationUpdateWithWhereUniqueWithoutEncadreurInput = {
    where: affectationWhereUniqueInput
    data: XOR<affectationUpdateWithoutEncadreurInput, affectationUncheckedUpdateWithoutEncadreurInput>
  }

  export type affectationUpdateManyWithWhereWithoutEncadreurInput = {
    where: affectationScalarWhereInput
    data: XOR<affectationUpdateManyMutationInput, affectationUncheckedUpdateManyWithoutEncadreurInput>
  }

  export type structuresUpsertWithoutEncadreurInput = {
    update: XOR<structuresUpdateWithoutEncadreurInput, structuresUncheckedUpdateWithoutEncadreurInput>
    create: XOR<structuresCreateWithoutEncadreurInput, structuresUncheckedCreateWithoutEncadreurInput>
    where?: structuresWhereInput
  }

  export type structuresUpdateToOneWithWhereWithoutEncadreurInput = {
    where?: structuresWhereInput
    data: XOR<structuresUpdateWithoutEncadreurInput, structuresUncheckedUpdateWithoutEncadreurInput>
  }

  export type structuresUpdateWithoutEncadreurInput = {
    NOMSTRUCTURE?: StringFieldUpdateOperationsInput | string
    ABBREVIATION?: StringFieldUpdateOperationsInput | string
    affectation?: affectationUpdateManyWithoutStructuresNestedInput
    structures?: structuresUpdateOneWithoutOther_structuresNestedInput
    other_structures?: structuresUpdateManyWithoutStructuresNestedInput
  }

  export type structuresUncheckedUpdateWithoutEncadreurInput = {
    IDSTRUCTURE?: IntFieldUpdateOperationsInput | number
    NOMSTRUCTURE?: StringFieldUpdateOperationsInput | string
    ABBREVIATION?: StringFieldUpdateOperationsInput | string
    IDPARENT?: NullableIntFieldUpdateOperationsInput | number | null
    affectation?: affectationUncheckedUpdateManyWithoutStructuresNestedInput
    other_structures?: structuresUncheckedUpdateManyWithoutStructuresNestedInput
  }

  export type dossierCreateWithoutEtudiantInput = {
    DATEDEBUTDESEANCE?: Date | string | null
    DATEFINDESEANCE?: Date | string | null
    ETAT?: string | null
    THEME?: string | null
    CNI: string
    CERTIFICAT: string
    LETTREMOTIVATION: string
    LETTRERECOMMENDATION: string
    PHOTOPROFIL: string
    CV?: string | null
    CAHIERDECHARGE?: string | null
    DATEDEPOT?: Date | string
    EMAILSENT?: boolean | null
    affectation?: affectationCreateNestedManyWithoutDossierInput
    lettreAcceptation?: lettreAcceptationCreateNestedManyWithoutDossierInput
  }

  export type dossierUncheckedCreateWithoutEtudiantInput = {
    IDDOSSIER?: number
    DATEDEBUTDESEANCE?: Date | string | null
    DATEFINDESEANCE?: Date | string | null
    ETAT?: string | null
    THEME?: string | null
    CNI: string
    CERTIFICAT: string
    LETTREMOTIVATION: string
    LETTRERECOMMENDATION: string
    PHOTOPROFIL: string
    CV?: string | null
    CAHIERDECHARGE?: string | null
    DATEDEPOT?: Date | string
    EMAILSENT?: boolean | null
    affectation?: affectationUncheckedCreateNestedManyWithoutDossierInput
    lettreAcceptation?: lettreAcceptationUncheckedCreateNestedManyWithoutDossierInput
  }

  export type dossierCreateOrConnectWithoutEtudiantInput = {
    where: dossierWhereUniqueInput
    create: XOR<dossierCreateWithoutEtudiantInput, dossierUncheckedCreateWithoutEtudiantInput>
  }

  export type dossierCreateManyEtudiantInputEnvelope = {
    data: dossierCreateManyEtudiantInput | dossierCreateManyEtudiantInput[]
    skipDuplicates?: boolean
  }

  export type rapportCreateWithoutEtudiantInput = {
    COMMENTAIRE: string
    THEME: string
    FICHIER: string
    DATE?: Date | string
  }

  export type rapportUncheckedCreateWithoutEtudiantInput = {
    IDDOSSIER?: number
    COMMENTAIRE: string
    THEME: string
    FICHIER: string
    DATE?: Date | string
  }

  export type rapportCreateOrConnectWithoutEtudiantInput = {
    where: rapportWhereUniqueInput
    create: XOR<rapportCreateWithoutEtudiantInput, rapportUncheckedCreateWithoutEtudiantInput>
  }

  export type rapportCreateManyEtudiantInputEnvelope = {
    data: rapportCreateManyEtudiantInput | rapportCreateManyEtudiantInput[]
    skipDuplicates?: boolean
  }

  export type dossierUpsertWithWhereUniqueWithoutEtudiantInput = {
    where: dossierWhereUniqueInput
    update: XOR<dossierUpdateWithoutEtudiantInput, dossierUncheckedUpdateWithoutEtudiantInput>
    create: XOR<dossierCreateWithoutEtudiantInput, dossierUncheckedCreateWithoutEtudiantInput>
  }

  export type dossierUpdateWithWhereUniqueWithoutEtudiantInput = {
    where: dossierWhereUniqueInput
    data: XOR<dossierUpdateWithoutEtudiantInput, dossierUncheckedUpdateWithoutEtudiantInput>
  }

  export type dossierUpdateManyWithWhereWithoutEtudiantInput = {
    where: dossierScalarWhereInput
    data: XOR<dossierUpdateManyMutationInput, dossierUncheckedUpdateManyWithoutEtudiantInput>
  }

  export type dossierScalarWhereInput = {
    AND?: dossierScalarWhereInput | dossierScalarWhereInput[]
    OR?: dossierScalarWhereInput[]
    NOT?: dossierScalarWhereInput | dossierScalarWhereInput[]
    IDDOSSIER?: IntFilter<"dossier"> | number
    MATRICULEETUDIANT?: StringNullableFilter<"dossier"> | string | null
    DATEDEBUTDESEANCE?: DateTimeNullableFilter<"dossier"> | Date | string | null
    DATEFINDESEANCE?: DateTimeNullableFilter<"dossier"> | Date | string | null
    ETAT?: StringNullableFilter<"dossier"> | string | null
    THEME?: StringNullableFilter<"dossier"> | string | null
    CNI?: StringFilter<"dossier"> | string
    CERTIFICAT?: StringFilter<"dossier"> | string
    LETTREMOTIVATION?: StringFilter<"dossier"> | string
    LETTRERECOMMENDATION?: StringFilter<"dossier"> | string
    PHOTOPROFIL?: StringFilter<"dossier"> | string
    CV?: StringNullableFilter<"dossier"> | string | null
    CAHIERDECHARGE?: StringNullableFilter<"dossier"> | string | null
    DATEDEPOT?: DateTimeFilter<"dossier"> | Date | string
    EMAILSENT?: BoolNullableFilter<"dossier"> | boolean | null
  }

  export type rapportUpsertWithWhereUniqueWithoutEtudiantInput = {
    where: rapportWhereUniqueInput
    update: XOR<rapportUpdateWithoutEtudiantInput, rapportUncheckedUpdateWithoutEtudiantInput>
    create: XOR<rapportCreateWithoutEtudiantInput, rapportUncheckedCreateWithoutEtudiantInput>
  }

  export type rapportUpdateWithWhereUniqueWithoutEtudiantInput = {
    where: rapportWhereUniqueInput
    data: XOR<rapportUpdateWithoutEtudiantInput, rapportUncheckedUpdateWithoutEtudiantInput>
  }

  export type rapportUpdateManyWithWhereWithoutEtudiantInput = {
    where: rapportScalarWhereInput
    data: XOR<rapportUpdateManyMutationInput, rapportUncheckedUpdateManyWithoutEtudiantInput>
  }

  export type rapportScalarWhereInput = {
    AND?: rapportScalarWhereInput | rapportScalarWhereInput[]
    OR?: rapportScalarWhereInput[]
    NOT?: rapportScalarWhereInput | rapportScalarWhereInput[]
    IDDOSSIER?: IntFilter<"rapport"> | number
    MATRICULE?: StringFilter<"rapport"> | string
    COMMENTAIRE?: StringFilter<"rapport"> | string
    THEME?: StringFilter<"rapport"> | string
    FICHIER?: StringFilter<"rapport"> | string
    DATE?: DateTimeFilter<"rapport"> | Date | string
  }

  export type etudiantCreateWithoutRapportInput = {
    MATRICULEETUDIANT: string
    NOMETUDIANT?: string | null
    PRENOMETUDIANT?: string | null
    ETABLISSEMENT?: string | null
    VILLERESIDENCE?: string | null
    PARCOURS?: string | null
    NIVEAU?: string | null
    EMAIL: string
    TEL: string
    FILIERE: string
    SEXE: string
    DATE?: Date | string
    dossier?: dossierCreateNestedManyWithoutEtudiantInput
  }

  export type etudiantUncheckedCreateWithoutRapportInput = {
    MATRICULEETUDIANT: string
    NOMETUDIANT?: string | null
    PRENOMETUDIANT?: string | null
    ETABLISSEMENT?: string | null
    VILLERESIDENCE?: string | null
    PARCOURS?: string | null
    NIVEAU?: string | null
    EMAIL: string
    TEL: string
    FILIERE: string
    SEXE: string
    DATE?: Date | string
    dossier?: dossierUncheckedCreateNestedManyWithoutEtudiantInput
  }

  export type etudiantCreateOrConnectWithoutRapportInput = {
    where: etudiantWhereUniqueInput
    create: XOR<etudiantCreateWithoutRapportInput, etudiantUncheckedCreateWithoutRapportInput>
  }

  export type etudiantUpsertWithoutRapportInput = {
    update: XOR<etudiantUpdateWithoutRapportInput, etudiantUncheckedUpdateWithoutRapportInput>
    create: XOR<etudiantCreateWithoutRapportInput, etudiantUncheckedCreateWithoutRapportInput>
    where?: etudiantWhereInput
  }

  export type etudiantUpdateToOneWithWhereWithoutRapportInput = {
    where?: etudiantWhereInput
    data: XOR<etudiantUpdateWithoutRapportInput, etudiantUncheckedUpdateWithoutRapportInput>
  }

  export type etudiantUpdateWithoutRapportInput = {
    MATRICULEETUDIANT?: StringFieldUpdateOperationsInput | string
    NOMETUDIANT?: NullableStringFieldUpdateOperationsInput | string | null
    PRENOMETUDIANT?: NullableStringFieldUpdateOperationsInput | string | null
    ETABLISSEMENT?: NullableStringFieldUpdateOperationsInput | string | null
    VILLERESIDENCE?: NullableStringFieldUpdateOperationsInput | string | null
    PARCOURS?: NullableStringFieldUpdateOperationsInput | string | null
    NIVEAU?: NullableStringFieldUpdateOperationsInput | string | null
    EMAIL?: StringFieldUpdateOperationsInput | string
    TEL?: StringFieldUpdateOperationsInput | string
    FILIERE?: StringFieldUpdateOperationsInput | string
    SEXE?: StringFieldUpdateOperationsInput | string
    DATE?: DateTimeFieldUpdateOperationsInput | Date | string
    dossier?: dossierUpdateManyWithoutEtudiantNestedInput
  }

  export type etudiantUncheckedUpdateWithoutRapportInput = {
    MATRICULEETUDIANT?: StringFieldUpdateOperationsInput | string
    NOMETUDIANT?: NullableStringFieldUpdateOperationsInput | string | null
    PRENOMETUDIANT?: NullableStringFieldUpdateOperationsInput | string | null
    ETABLISSEMENT?: NullableStringFieldUpdateOperationsInput | string | null
    VILLERESIDENCE?: NullableStringFieldUpdateOperationsInput | string | null
    PARCOURS?: NullableStringFieldUpdateOperationsInput | string | null
    NIVEAU?: NullableStringFieldUpdateOperationsInput | string | null
    EMAIL?: StringFieldUpdateOperationsInput | string
    TEL?: StringFieldUpdateOperationsInput | string
    FILIERE?: StringFieldUpdateOperationsInput | string
    SEXE?: StringFieldUpdateOperationsInput | string
    DATE?: DateTimeFieldUpdateOperationsInput | Date | string
    dossier?: dossierUncheckedUpdateManyWithoutEtudiantNestedInput
  }

  export type dossierCreateWithoutLettreAcceptationInput = {
    DATEDEBUTDESEANCE?: Date | string | null
    DATEFINDESEANCE?: Date | string | null
    ETAT?: string | null
    THEME?: string | null
    CNI: string
    CERTIFICAT: string
    LETTREMOTIVATION: string
    LETTRERECOMMENDATION: string
    PHOTOPROFIL: string
    CV?: string | null
    CAHIERDECHARGE?: string | null
    DATEDEPOT?: Date | string
    EMAILSENT?: boolean | null
    affectation?: affectationCreateNestedManyWithoutDossierInput
    etudiant?: etudiantCreateNestedOneWithoutDossierInput
  }

  export type dossierUncheckedCreateWithoutLettreAcceptationInput = {
    IDDOSSIER?: number
    MATRICULEETUDIANT?: string | null
    DATEDEBUTDESEANCE?: Date | string | null
    DATEFINDESEANCE?: Date | string | null
    ETAT?: string | null
    THEME?: string | null
    CNI: string
    CERTIFICAT: string
    LETTREMOTIVATION: string
    LETTRERECOMMENDATION: string
    PHOTOPROFIL: string
    CV?: string | null
    CAHIERDECHARGE?: string | null
    DATEDEPOT?: Date | string
    EMAILSENT?: boolean | null
    affectation?: affectationUncheckedCreateNestedManyWithoutDossierInput
  }

  export type dossierCreateOrConnectWithoutLettreAcceptationInput = {
    where: dossierWhereUniqueInput
    create: XOR<dossierCreateWithoutLettreAcceptationInput, dossierUncheckedCreateWithoutLettreAcceptationInput>
  }

  export type dossierUpsertWithoutLettreAcceptationInput = {
    update: XOR<dossierUpdateWithoutLettreAcceptationInput, dossierUncheckedUpdateWithoutLettreAcceptationInput>
    create: XOR<dossierCreateWithoutLettreAcceptationInput, dossierUncheckedCreateWithoutLettreAcceptationInput>
    where?: dossierWhereInput
  }

  export type dossierUpdateToOneWithWhereWithoutLettreAcceptationInput = {
    where?: dossierWhereInput
    data: XOR<dossierUpdateWithoutLettreAcceptationInput, dossierUncheckedUpdateWithoutLettreAcceptationInput>
  }

  export type dossierUpdateWithoutLettreAcceptationInput = {
    DATEDEBUTDESEANCE?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    DATEFINDESEANCE?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ETAT?: NullableStringFieldUpdateOperationsInput | string | null
    THEME?: NullableStringFieldUpdateOperationsInput | string | null
    CNI?: StringFieldUpdateOperationsInput | string
    CERTIFICAT?: StringFieldUpdateOperationsInput | string
    LETTREMOTIVATION?: StringFieldUpdateOperationsInput | string
    LETTRERECOMMENDATION?: StringFieldUpdateOperationsInput | string
    PHOTOPROFIL?: StringFieldUpdateOperationsInput | string
    CV?: NullableStringFieldUpdateOperationsInput | string | null
    CAHIERDECHARGE?: NullableStringFieldUpdateOperationsInput | string | null
    DATEDEPOT?: DateTimeFieldUpdateOperationsInput | Date | string
    EMAILSENT?: NullableBoolFieldUpdateOperationsInput | boolean | null
    affectation?: affectationUpdateManyWithoutDossierNestedInput
    etudiant?: etudiantUpdateOneWithoutDossierNestedInput
  }

  export type dossierUncheckedUpdateWithoutLettreAcceptationInput = {
    IDDOSSIER?: IntFieldUpdateOperationsInput | number
    MATRICULEETUDIANT?: NullableStringFieldUpdateOperationsInput | string | null
    DATEDEBUTDESEANCE?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    DATEFINDESEANCE?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ETAT?: NullableStringFieldUpdateOperationsInput | string | null
    THEME?: NullableStringFieldUpdateOperationsInput | string | null
    CNI?: StringFieldUpdateOperationsInput | string
    CERTIFICAT?: StringFieldUpdateOperationsInput | string
    LETTREMOTIVATION?: StringFieldUpdateOperationsInput | string
    LETTRERECOMMENDATION?: StringFieldUpdateOperationsInput | string
    PHOTOPROFIL?: StringFieldUpdateOperationsInput | string
    CV?: NullableStringFieldUpdateOperationsInput | string | null
    CAHIERDECHARGE?: NullableStringFieldUpdateOperationsInput | string | null
    DATEDEPOT?: DateTimeFieldUpdateOperationsInput | Date | string
    EMAILSENT?: NullableBoolFieldUpdateOperationsInput | boolean | null
    affectation?: affectationUncheckedUpdateManyWithoutDossierNestedInput
  }

  export type affectationCreateWithoutStructuresInput = {
    administrateur: administrateurCreateNestedOneWithoutAffectationInput
    encadreur: encadreurCreateNestedOneWithoutAffectationInput
    dossier: dossierCreateNestedOneWithoutAffectationInput
  }

  export type affectationUncheckedCreateWithoutStructuresInput = {
    IDADMIN: number
    IDENCADREUR: number
    IDDOSSIER: number
  }

  export type affectationCreateOrConnectWithoutStructuresInput = {
    where: affectationWhereUniqueInput
    create: XOR<affectationCreateWithoutStructuresInput, affectationUncheckedCreateWithoutStructuresInput>
  }

  export type affectationCreateManyStructuresInputEnvelope = {
    data: affectationCreateManyStructuresInput | affectationCreateManyStructuresInput[]
    skipDuplicates?: boolean
  }

  export type encadreurCreateWithoutStructuresInput = {
    MATRICULEENCADREUR: string
    NOMENCADREUR?: string | null
    PRENOMENCADREUR?: string | null
    POSTE?: string | null
    affectation?: affectationCreateNestedManyWithoutEncadreurInput
  }

  export type encadreurUncheckedCreateWithoutStructuresInput = {
    IDENCADREUR?: number
    MATRICULEENCADREUR: string
    NOMENCADREUR?: string | null
    PRENOMENCADREUR?: string | null
    POSTE?: string | null
    affectation?: affectationUncheckedCreateNestedManyWithoutEncadreurInput
  }

  export type encadreurCreateOrConnectWithoutStructuresInput = {
    where: encadreurWhereUniqueInput
    create: XOR<encadreurCreateWithoutStructuresInput, encadreurUncheckedCreateWithoutStructuresInput>
  }

  export type encadreurCreateManyStructuresInputEnvelope = {
    data: encadreurCreateManyStructuresInput | encadreurCreateManyStructuresInput[]
    skipDuplicates?: boolean
  }

  export type structuresCreateWithoutOther_structuresInput = {
    NOMSTRUCTURE: string
    ABBREVIATION: string
    affectation?: affectationCreateNestedManyWithoutStructuresInput
    encadreur?: encadreurCreateNestedManyWithoutStructuresInput
    structures?: structuresCreateNestedOneWithoutOther_structuresInput
  }

  export type structuresUncheckedCreateWithoutOther_structuresInput = {
    IDSTRUCTURE?: number
    NOMSTRUCTURE: string
    ABBREVIATION: string
    IDPARENT?: number | null
    affectation?: affectationUncheckedCreateNestedManyWithoutStructuresInput
    encadreur?: encadreurUncheckedCreateNestedManyWithoutStructuresInput
  }

  export type structuresCreateOrConnectWithoutOther_structuresInput = {
    where: structuresWhereUniqueInput
    create: XOR<structuresCreateWithoutOther_structuresInput, structuresUncheckedCreateWithoutOther_structuresInput>
  }

  export type structuresCreateWithoutStructuresInput = {
    NOMSTRUCTURE: string
    ABBREVIATION: string
    affectation?: affectationCreateNestedManyWithoutStructuresInput
    encadreur?: encadreurCreateNestedManyWithoutStructuresInput
    other_structures?: structuresCreateNestedManyWithoutStructuresInput
  }

  export type structuresUncheckedCreateWithoutStructuresInput = {
    IDSTRUCTURE?: number
    NOMSTRUCTURE: string
    ABBREVIATION: string
    affectation?: affectationUncheckedCreateNestedManyWithoutStructuresInput
    encadreur?: encadreurUncheckedCreateNestedManyWithoutStructuresInput
    other_structures?: structuresUncheckedCreateNestedManyWithoutStructuresInput
  }

  export type structuresCreateOrConnectWithoutStructuresInput = {
    where: structuresWhereUniqueInput
    create: XOR<structuresCreateWithoutStructuresInput, structuresUncheckedCreateWithoutStructuresInput>
  }

  export type structuresCreateManyStructuresInputEnvelope = {
    data: structuresCreateManyStructuresInput | structuresCreateManyStructuresInput[]
    skipDuplicates?: boolean
  }

  export type affectationUpsertWithWhereUniqueWithoutStructuresInput = {
    where: affectationWhereUniqueInput
    update: XOR<affectationUpdateWithoutStructuresInput, affectationUncheckedUpdateWithoutStructuresInput>
    create: XOR<affectationCreateWithoutStructuresInput, affectationUncheckedCreateWithoutStructuresInput>
  }

  export type affectationUpdateWithWhereUniqueWithoutStructuresInput = {
    where: affectationWhereUniqueInput
    data: XOR<affectationUpdateWithoutStructuresInput, affectationUncheckedUpdateWithoutStructuresInput>
  }

  export type affectationUpdateManyWithWhereWithoutStructuresInput = {
    where: affectationScalarWhereInput
    data: XOR<affectationUpdateManyMutationInput, affectationUncheckedUpdateManyWithoutStructuresInput>
  }

  export type encadreurUpsertWithWhereUniqueWithoutStructuresInput = {
    where: encadreurWhereUniqueInput
    update: XOR<encadreurUpdateWithoutStructuresInput, encadreurUncheckedUpdateWithoutStructuresInput>
    create: XOR<encadreurCreateWithoutStructuresInput, encadreurUncheckedCreateWithoutStructuresInput>
  }

  export type encadreurUpdateWithWhereUniqueWithoutStructuresInput = {
    where: encadreurWhereUniqueInput
    data: XOR<encadreurUpdateWithoutStructuresInput, encadreurUncheckedUpdateWithoutStructuresInput>
  }

  export type encadreurUpdateManyWithWhereWithoutStructuresInput = {
    where: encadreurScalarWhereInput
    data: XOR<encadreurUpdateManyMutationInput, encadreurUncheckedUpdateManyWithoutStructuresInput>
  }

  export type encadreurScalarWhereInput = {
    AND?: encadreurScalarWhereInput | encadreurScalarWhereInput[]
    OR?: encadreurScalarWhereInput[]
    NOT?: encadreurScalarWhereInput | encadreurScalarWhereInput[]
    IDENCADREUR?: IntFilter<"encadreur"> | number
    MATRICULEENCADREUR?: StringFilter<"encadreur"> | string
    NOMENCADREUR?: StringNullableFilter<"encadreur"> | string | null
    PRENOMENCADREUR?: StringNullableFilter<"encadreur"> | string | null
    IDSTRUCTURE?: IntNullableFilter<"encadreur"> | number | null
    POSTE?: StringNullableFilter<"encadreur"> | string | null
  }

  export type structuresUpsertWithoutOther_structuresInput = {
    update: XOR<structuresUpdateWithoutOther_structuresInput, structuresUncheckedUpdateWithoutOther_structuresInput>
    create: XOR<structuresCreateWithoutOther_structuresInput, structuresUncheckedCreateWithoutOther_structuresInput>
    where?: structuresWhereInput
  }

  export type structuresUpdateToOneWithWhereWithoutOther_structuresInput = {
    where?: structuresWhereInput
    data: XOR<structuresUpdateWithoutOther_structuresInput, structuresUncheckedUpdateWithoutOther_structuresInput>
  }

  export type structuresUpdateWithoutOther_structuresInput = {
    NOMSTRUCTURE?: StringFieldUpdateOperationsInput | string
    ABBREVIATION?: StringFieldUpdateOperationsInput | string
    affectation?: affectationUpdateManyWithoutStructuresNestedInput
    encadreur?: encadreurUpdateManyWithoutStructuresNestedInput
    structures?: structuresUpdateOneWithoutOther_structuresNestedInput
  }

  export type structuresUncheckedUpdateWithoutOther_structuresInput = {
    IDSTRUCTURE?: IntFieldUpdateOperationsInput | number
    NOMSTRUCTURE?: StringFieldUpdateOperationsInput | string
    ABBREVIATION?: StringFieldUpdateOperationsInput | string
    IDPARENT?: NullableIntFieldUpdateOperationsInput | number | null
    affectation?: affectationUncheckedUpdateManyWithoutStructuresNestedInput
    encadreur?: encadreurUncheckedUpdateManyWithoutStructuresNestedInput
  }

  export type structuresUpsertWithWhereUniqueWithoutStructuresInput = {
    where: structuresWhereUniqueInput
    update: XOR<structuresUpdateWithoutStructuresInput, structuresUncheckedUpdateWithoutStructuresInput>
    create: XOR<structuresCreateWithoutStructuresInput, structuresUncheckedCreateWithoutStructuresInput>
  }

  export type structuresUpdateWithWhereUniqueWithoutStructuresInput = {
    where: structuresWhereUniqueInput
    data: XOR<structuresUpdateWithoutStructuresInput, structuresUncheckedUpdateWithoutStructuresInput>
  }

  export type structuresUpdateManyWithWhereWithoutStructuresInput = {
    where: structuresScalarWhereInput
    data: XOR<structuresUpdateManyMutationInput, structuresUncheckedUpdateManyWithoutStructuresInput>
  }

  export type structuresScalarWhereInput = {
    AND?: structuresScalarWhereInput | structuresScalarWhereInput[]
    OR?: structuresScalarWhereInput[]
    NOT?: structuresScalarWhereInput | structuresScalarWhereInput[]
    IDSTRUCTURE?: IntFilter<"structures"> | number
    NOMSTRUCTURE?: StringFilter<"structures"> | string
    ABBREVIATION?: StringFilter<"structures"> | string
    IDPARENT?: IntNullableFilter<"structures"> | number | null
  }

  export type affectationCreateManyAdministrateurInput = {
    IDENCADREUR: number
    IDDOSSIER: number
    IDSTRUCTURE: number
  }

  export type affectationUpdateWithoutAdministrateurInput = {
    encadreur?: encadreurUpdateOneRequiredWithoutAffectationNestedInput
    dossier?: dossierUpdateOneRequiredWithoutAffectationNestedInput
    structures?: structuresUpdateOneRequiredWithoutAffectationNestedInput
  }

  export type affectationUncheckedUpdateWithoutAdministrateurInput = {
    IDENCADREUR?: IntFieldUpdateOperationsInput | number
    IDDOSSIER?: IntFieldUpdateOperationsInput | number
    IDSTRUCTURE?: IntFieldUpdateOperationsInput | number
  }

  export type affectationUncheckedUpdateManyWithoutAdministrateurInput = {
    IDENCADREUR?: IntFieldUpdateOperationsInput | number
    IDDOSSIER?: IntFieldUpdateOperationsInput | number
    IDSTRUCTURE?: IntFieldUpdateOperationsInput | number
  }

  export type affectationCreateManyDossierInput = {
    IDADMIN: number
    IDENCADREUR: number
    IDSTRUCTURE: number
  }

  export type lettreAcceptationCreateManyDossierInput = {
    IDLETTRE?: number
    COMMENTAIRE: string
    FICHIER: string
    DATEUPLOAD?: Date | string
    EMAILSENT?: boolean
  }

  export type affectationUpdateWithoutDossierInput = {
    administrateur?: administrateurUpdateOneRequiredWithoutAffectationNestedInput
    encadreur?: encadreurUpdateOneRequiredWithoutAffectationNestedInput
    structures?: structuresUpdateOneRequiredWithoutAffectationNestedInput
  }

  export type affectationUncheckedUpdateWithoutDossierInput = {
    IDADMIN?: IntFieldUpdateOperationsInput | number
    IDENCADREUR?: IntFieldUpdateOperationsInput | number
    IDSTRUCTURE?: IntFieldUpdateOperationsInput | number
  }

  export type affectationUncheckedUpdateManyWithoutDossierInput = {
    IDADMIN?: IntFieldUpdateOperationsInput | number
    IDENCADREUR?: IntFieldUpdateOperationsInput | number
    IDSTRUCTURE?: IntFieldUpdateOperationsInput | number
  }

  export type lettreAcceptationUpdateWithoutDossierInput = {
    COMMENTAIRE?: StringFieldUpdateOperationsInput | string
    FICHIER?: StringFieldUpdateOperationsInput | string
    DATEUPLOAD?: DateTimeFieldUpdateOperationsInput | Date | string
    EMAILSENT?: BoolFieldUpdateOperationsInput | boolean
  }

  export type lettreAcceptationUncheckedUpdateWithoutDossierInput = {
    IDLETTRE?: IntFieldUpdateOperationsInput | number
    COMMENTAIRE?: StringFieldUpdateOperationsInput | string
    FICHIER?: StringFieldUpdateOperationsInput | string
    DATEUPLOAD?: DateTimeFieldUpdateOperationsInput | Date | string
    EMAILSENT?: BoolFieldUpdateOperationsInput | boolean
  }

  export type lettreAcceptationUncheckedUpdateManyWithoutDossierInput = {
    IDLETTRE?: IntFieldUpdateOperationsInput | number
    COMMENTAIRE?: StringFieldUpdateOperationsInput | string
    FICHIER?: StringFieldUpdateOperationsInput | string
    DATEUPLOAD?: DateTimeFieldUpdateOperationsInput | Date | string
    EMAILSENT?: BoolFieldUpdateOperationsInput | boolean
  }

  export type affectationCreateManyEncadreurInput = {
    IDADMIN: number
    IDDOSSIER: number
    IDSTRUCTURE: number
  }

  export type affectationUpdateWithoutEncadreurInput = {
    administrateur?: administrateurUpdateOneRequiredWithoutAffectationNestedInput
    dossier?: dossierUpdateOneRequiredWithoutAffectationNestedInput
    structures?: structuresUpdateOneRequiredWithoutAffectationNestedInput
  }

  export type affectationUncheckedUpdateWithoutEncadreurInput = {
    IDADMIN?: IntFieldUpdateOperationsInput | number
    IDDOSSIER?: IntFieldUpdateOperationsInput | number
    IDSTRUCTURE?: IntFieldUpdateOperationsInput | number
  }

  export type affectationUncheckedUpdateManyWithoutEncadreurInput = {
    IDADMIN?: IntFieldUpdateOperationsInput | number
    IDDOSSIER?: IntFieldUpdateOperationsInput | number
    IDSTRUCTURE?: IntFieldUpdateOperationsInput | number
  }

  export type dossierCreateManyEtudiantInput = {
    IDDOSSIER?: number
    DATEDEBUTDESEANCE?: Date | string | null
    DATEFINDESEANCE?: Date | string | null
    ETAT?: string | null
    THEME?: string | null
    CNI: string
    CERTIFICAT: string
    LETTREMOTIVATION: string
    LETTRERECOMMENDATION: string
    PHOTOPROFIL: string
    CV?: string | null
    CAHIERDECHARGE?: string | null
    DATEDEPOT?: Date | string
    EMAILSENT?: boolean | null
  }

  export type rapportCreateManyEtudiantInput = {
    IDDOSSIER?: number
    COMMENTAIRE: string
    THEME: string
    FICHIER: string
    DATE?: Date | string
  }

  export type dossierUpdateWithoutEtudiantInput = {
    DATEDEBUTDESEANCE?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    DATEFINDESEANCE?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ETAT?: NullableStringFieldUpdateOperationsInput | string | null
    THEME?: NullableStringFieldUpdateOperationsInput | string | null
    CNI?: StringFieldUpdateOperationsInput | string
    CERTIFICAT?: StringFieldUpdateOperationsInput | string
    LETTREMOTIVATION?: StringFieldUpdateOperationsInput | string
    LETTRERECOMMENDATION?: StringFieldUpdateOperationsInput | string
    PHOTOPROFIL?: StringFieldUpdateOperationsInput | string
    CV?: NullableStringFieldUpdateOperationsInput | string | null
    CAHIERDECHARGE?: NullableStringFieldUpdateOperationsInput | string | null
    DATEDEPOT?: DateTimeFieldUpdateOperationsInput | Date | string
    EMAILSENT?: NullableBoolFieldUpdateOperationsInput | boolean | null
    affectation?: affectationUpdateManyWithoutDossierNestedInput
    lettreAcceptation?: lettreAcceptationUpdateManyWithoutDossierNestedInput
  }

  export type dossierUncheckedUpdateWithoutEtudiantInput = {
    IDDOSSIER?: IntFieldUpdateOperationsInput | number
    DATEDEBUTDESEANCE?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    DATEFINDESEANCE?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ETAT?: NullableStringFieldUpdateOperationsInput | string | null
    THEME?: NullableStringFieldUpdateOperationsInput | string | null
    CNI?: StringFieldUpdateOperationsInput | string
    CERTIFICAT?: StringFieldUpdateOperationsInput | string
    LETTREMOTIVATION?: StringFieldUpdateOperationsInput | string
    LETTRERECOMMENDATION?: StringFieldUpdateOperationsInput | string
    PHOTOPROFIL?: StringFieldUpdateOperationsInput | string
    CV?: NullableStringFieldUpdateOperationsInput | string | null
    CAHIERDECHARGE?: NullableStringFieldUpdateOperationsInput | string | null
    DATEDEPOT?: DateTimeFieldUpdateOperationsInput | Date | string
    EMAILSENT?: NullableBoolFieldUpdateOperationsInput | boolean | null
    affectation?: affectationUncheckedUpdateManyWithoutDossierNestedInput
    lettreAcceptation?: lettreAcceptationUncheckedUpdateManyWithoutDossierNestedInput
  }

  export type dossierUncheckedUpdateManyWithoutEtudiantInput = {
    IDDOSSIER?: IntFieldUpdateOperationsInput | number
    DATEDEBUTDESEANCE?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    DATEFINDESEANCE?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ETAT?: NullableStringFieldUpdateOperationsInput | string | null
    THEME?: NullableStringFieldUpdateOperationsInput | string | null
    CNI?: StringFieldUpdateOperationsInput | string
    CERTIFICAT?: StringFieldUpdateOperationsInput | string
    LETTREMOTIVATION?: StringFieldUpdateOperationsInput | string
    LETTRERECOMMENDATION?: StringFieldUpdateOperationsInput | string
    PHOTOPROFIL?: StringFieldUpdateOperationsInput | string
    CV?: NullableStringFieldUpdateOperationsInput | string | null
    CAHIERDECHARGE?: NullableStringFieldUpdateOperationsInput | string | null
    DATEDEPOT?: DateTimeFieldUpdateOperationsInput | Date | string
    EMAILSENT?: NullableBoolFieldUpdateOperationsInput | boolean | null
  }

  export type rapportUpdateWithoutEtudiantInput = {
    COMMENTAIRE?: StringFieldUpdateOperationsInput | string
    THEME?: StringFieldUpdateOperationsInput | string
    FICHIER?: StringFieldUpdateOperationsInput | string
    DATE?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type rapportUncheckedUpdateWithoutEtudiantInput = {
    IDDOSSIER?: IntFieldUpdateOperationsInput | number
    COMMENTAIRE?: StringFieldUpdateOperationsInput | string
    THEME?: StringFieldUpdateOperationsInput | string
    FICHIER?: StringFieldUpdateOperationsInput | string
    DATE?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type rapportUncheckedUpdateManyWithoutEtudiantInput = {
    IDDOSSIER?: IntFieldUpdateOperationsInput | number
    COMMENTAIRE?: StringFieldUpdateOperationsInput | string
    THEME?: StringFieldUpdateOperationsInput | string
    FICHIER?: StringFieldUpdateOperationsInput | string
    DATE?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type affectationCreateManyStructuresInput = {
    IDADMIN: number
    IDENCADREUR: number
    IDDOSSIER: number
  }

  export type encadreurCreateManyStructuresInput = {
    IDENCADREUR?: number
    MATRICULEENCADREUR: string
    NOMENCADREUR?: string | null
    PRENOMENCADREUR?: string | null
    POSTE?: string | null
  }

  export type structuresCreateManyStructuresInput = {
    IDSTRUCTURE?: number
    NOMSTRUCTURE: string
    ABBREVIATION: string
  }

  export type affectationUpdateWithoutStructuresInput = {
    administrateur?: administrateurUpdateOneRequiredWithoutAffectationNestedInput
    encadreur?: encadreurUpdateOneRequiredWithoutAffectationNestedInput
    dossier?: dossierUpdateOneRequiredWithoutAffectationNestedInput
  }

  export type affectationUncheckedUpdateWithoutStructuresInput = {
    IDADMIN?: IntFieldUpdateOperationsInput | number
    IDENCADREUR?: IntFieldUpdateOperationsInput | number
    IDDOSSIER?: IntFieldUpdateOperationsInput | number
  }

  export type affectationUncheckedUpdateManyWithoutStructuresInput = {
    IDADMIN?: IntFieldUpdateOperationsInput | number
    IDENCADREUR?: IntFieldUpdateOperationsInput | number
    IDDOSSIER?: IntFieldUpdateOperationsInput | number
  }

  export type encadreurUpdateWithoutStructuresInput = {
    MATRICULEENCADREUR?: StringFieldUpdateOperationsInput | string
    NOMENCADREUR?: NullableStringFieldUpdateOperationsInput | string | null
    PRENOMENCADREUR?: NullableStringFieldUpdateOperationsInput | string | null
    POSTE?: NullableStringFieldUpdateOperationsInput | string | null
    affectation?: affectationUpdateManyWithoutEncadreurNestedInput
  }

  export type encadreurUncheckedUpdateWithoutStructuresInput = {
    IDENCADREUR?: IntFieldUpdateOperationsInput | number
    MATRICULEENCADREUR?: StringFieldUpdateOperationsInput | string
    NOMENCADREUR?: NullableStringFieldUpdateOperationsInput | string | null
    PRENOMENCADREUR?: NullableStringFieldUpdateOperationsInput | string | null
    POSTE?: NullableStringFieldUpdateOperationsInput | string | null
    affectation?: affectationUncheckedUpdateManyWithoutEncadreurNestedInput
  }

  export type encadreurUncheckedUpdateManyWithoutStructuresInput = {
    IDENCADREUR?: IntFieldUpdateOperationsInput | number
    MATRICULEENCADREUR?: StringFieldUpdateOperationsInput | string
    NOMENCADREUR?: NullableStringFieldUpdateOperationsInput | string | null
    PRENOMENCADREUR?: NullableStringFieldUpdateOperationsInput | string | null
    POSTE?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type structuresUpdateWithoutStructuresInput = {
    NOMSTRUCTURE?: StringFieldUpdateOperationsInput | string
    ABBREVIATION?: StringFieldUpdateOperationsInput | string
    affectation?: affectationUpdateManyWithoutStructuresNestedInput
    encadreur?: encadreurUpdateManyWithoutStructuresNestedInput
    other_structures?: structuresUpdateManyWithoutStructuresNestedInput
  }

  export type structuresUncheckedUpdateWithoutStructuresInput = {
    IDSTRUCTURE?: IntFieldUpdateOperationsInput | number
    NOMSTRUCTURE?: StringFieldUpdateOperationsInput | string
    ABBREVIATION?: StringFieldUpdateOperationsInput | string
    affectation?: affectationUncheckedUpdateManyWithoutStructuresNestedInput
    encadreur?: encadreurUncheckedUpdateManyWithoutStructuresNestedInput
    other_structures?: structuresUncheckedUpdateManyWithoutStructuresNestedInput
  }

  export type structuresUncheckedUpdateManyWithoutStructuresInput = {
    IDSTRUCTURE?: IntFieldUpdateOperationsInput | number
    NOMSTRUCTURE?: StringFieldUpdateOperationsInput | string
    ABBREVIATION?: StringFieldUpdateOperationsInput | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}